@UTF8
@PID:	11312/a-00010189-1
@Begin
@Languages:	eng
@Participants:	S1 Lecturer Speaker, S2 Student Student, S3 Unknown
	Unidentified, S4 Student Student, S5 Student Student, S6
	Student Student, SS Unknown Unidentified
@ID:	eng|MICASE|S1|36;|female|NS||Speaker|JF||
@ID:	eng|MICASE|S2|20;|female|NS||Student|SU||
@ID:	eng|MICASE|S3||male|NS||Unidentified|UN||
@ID:	eng|MICASE|S4|27;|male|NS||Student|JG||
@ID:	eng|MICASE|S5|27;|female|NS||Student|JG||
@ID:	eng|MICASE|S6|20;|female|NNS||Student|UN||
@ID:	eng|MICASE|SS|||NS||Unidentified|UN||
@Media:	les235su099, audio, unlinked
@Date:	13-JUN-2000
@Situation:	Lecture Room, East Hall
*S1:	okay why don't we get started (.) alright as you see we've got a
	slightly unusual (.) event today we're being taped (.) and &-uh
	basically we'll just pretend they're not here which is +//.
%mor:	co|okay pro:int|why mod|do~neg|not pro:sub|we aux|get
	part|start-PASTP adj|alright prep|as pro:per|you v|see
	pro:sub|we~aux|have part|get&PASTP det:art|a adv|slight&dadj-LY
	un#adj|usual n|event adv:tem|today pro:sub|we~aux|be&PRES
	part|be-PRESP part|tape-PASTP coord|and adv|basic&dadj-AL-LY
	pro:sub|we~mod|will adv|just adj|pretend pro:sub|they~cop|be&PRES
	neg|not adv|here pro:rel|which cop|be&3S +//.
%gra:	1|7|COM 2|7|JCT 3|7|AUX 4|3|NEG 5|7|SUBJ 6|7|AUX 7|0|ROOT 8|7|PRED
	9|10|COORD 10|11|SUBJ 11|8|CMOD 12|14|SUBJ 13|14|AUX 14|11|COMP 15|18|DET
	16|17|JCT 17|18|MOD 18|14|OBJ 19|18|NJCT 20|22|SUBJ 21|22|AUX 22|19|CMOD
	23|22|PRED 24|35|LINK 25|29|JCT 26|29|SUBJ 27|29|AUX 28|29|JCT 29|35|SUBJ
	30|31|SUBJ 31|29|CMOD 32|29|NEG 33|35|JCT 34|35|LINK 35|22|CJCT
	36|7|PUNCT
*S1:	was their request &-uh before we get going with the selection sort
	again are there any questions about anything +..?
%mor:	cop|be&PAST&13S det:poss|their n|request conj|before pro:sub|we
	aux|get part|go-PRESP prep|with det:art|the n|selection n|sort
	adv|again cop|be&PRES adv|there qn|any n|question-PL prep|about
	pro:indef|anything +..?
%gra:	1|0|ROOT 2|3|DET 3|1|PRED 4|7|LINK 5|7|SUBJ 6|7|AUX 7|1|CJCT 8|7|JCT
	9|11|DET 10|11|MOD 11|8|POBJ 12|13|JCT 13|7|CJCT 14|13|JCT 15|16|QUANT
	16|13|PRED 17|16|NJCT 18|17|POBJ 19|1|PUNCT
*S1:	okay .
%mor:	co|okay .
%gra:	1|0|INCROOT 2|1|PUNCT
*S1:	well what I'd like to do first +...
%mor:	co|well pro:int|what pro:sub|I~mod|genmod v|like inf|to v|do
	adv|first +...
%gra:	1|5|COM 2|5|LINK 3|5|SUBJ 4|5|AUX 5|0|ROOT 6|7|INF 7|5|COMP 8|7|JCT
	9|5|PUNCT
*S1:	is review the algorithm (.) we did go through it yesterday but I
	think this is &-uh tough enough to understand that we probably
	oughta go through it &-uh quicker this time but go through it again
	(.) and then when we look at the code (.) I think it'll be easier to
	understand if we've just looked at these &-uh graphics again to see
	how the sort works .
%mor:	cop|be&3S v|review det:art|the n|algorithm pro:sub|we mod|do&PAST
	v|go adj|through pro:per|it adv:tem|yesterday conj|but pro:sub|I
	v|think det:dem|this cop|be&3S adj|tough adv|enough inf|to
	v|understand comp|that pro:sub|we adv|probable&dadj-LY
	mod|ought~inf|to v|go adj|through pro:per|it adj|quick-CP
	det:dem|this n|time conj|but v|go adj|through pro:per|it adv|again
	coord|and adv:tem|then conj|when pro:sub|we v|look prep|at
	det:art|the n|code pro:sub|I v|think pro:per|it~mod|will aux|be
	adj|ease&dn-Y-CP inf|to v|understand comp|if pro:sub|we~aux|have
	adv|just part|look-PASTP prep|at det:dem|these n:pt|graphics
	adv|again inf|to v|see pro:int|how det:art|the n|sort n|work-PL .
%gra:	1|0|ROOT 2|1|CPRED 3|4|DET 4|2|OBJ 5|7|SUBJ 6|7|AUX 7|4|CMOD 8|7|JCT
	9|8|OBJ 10|9|JCT 11|13|LINK 12|13|SUBJ 13|10|CJCT 14|15|DET 15|13|COMP
	16|15|PRED 17|16|JCT 18|19|INF 19|16|XMOD 20|25|LINK 21|25|SUBJ 22|25|JCT
	23|25|AUX 24|25|INF 25|19|COMP 26|30|MOD 27|30|MOD 28|30|MOD 29|30|DET
	30|25|OBJ 31|45|LINK 32|45|AUX 33|45|JCT 34|45|SUBJ 35|34|JCT 36|34|CONJ
	37|36|COORD 38|40|LINK 39|40|SUBJ 40|45|CJCT 41|40|JCT 42|43|DET
	43|41|POBJ 44|45|SUBJ 45|13|CJCT 46|48|SUBJ 47|48|AUX 48|45|OBJ 49|48|PRED
	50|51|INF 51|49|XMOD 52|56|LINK 53|56|SUBJ 54|56|AUX 55|56|JCT 56|51|COMP
	57|56|JCT 58|59|DET 59|57|POBJ 60|56|JCT 61|62|INF 62|56|XJCT 63|62|OBJ
	64|66|DET 65|66|MOD 66|63|OBJ 67|1|PUNCT
*S1:	so first of all the idea was to take this array (.) those five
	elements (.) and of_course put it in ascending numeric order (.) and
	that would give us (.) this array over here .
%mor:	adv|so adj|first prep|of qn|all det:art|the n|idea cop|be&PAST&13S
	inf|to v|take det:dem|this n|array det:dem|those det:num|five
	n|element-PL coord|and co|of_course v|put&ZERO pro:per|it prep|in
	part|ascend-PRESP adj|numeric n|order coord|and comp|that
	mod|will&COND v|give pro:obj|us det:dem|this n|array prep|over
	n|here .
%gra:	1|2|JCT 2|0|INCROOT 3|7|JCT 4|6|QUANT 5|6|DET 6|7|SUBJ 7|2|CMOD 8|9|INF
	9|7|CPRED 10|11|DET 11|9|OBJ 12|14|DET 13|14|QUANT 14|17|SUBJ
	15|14|CONJ 16|15|COORD 17|11|CMOD 18|17|OBJ 19|17|JCT 20|19|POBJ 21|22|MOD
	22|20|OBJ 23|26|LINK 24|26|SUBJ 25|26|AUX 26|9|CJCT 27|26|OBJ 28|29|DET
	29|26|OBJ 30|29|NJCT 31|30|POBJ 32|2|PUNCT
*S1:	&-uh one thing that I didn't mention yesterday is that (.) this
	sort is called a an in place sort because it sorts the array &-uh
	changes the contents of the actual array .
%mor:	det:num|one n|thing pro:rel|that pro:sub|I mod|do&PAST~neg|not
	v|mention adv:tem|yesterday cop|be&3S adv|that det:dem|this n|sort
	aux|be&3S part|call-PASTP det:art|a det:art|a prep|in n|place n|sort
	conj|because pro:per|it v|sort-3S det:art|the n|array v|change-3S
	det:art|the v|content-3S prep|of det:art|the adj|actual n|array .
%gra:	1|2|QUANT 2|25|SUBJ 3|7|LINK 4|7|SUBJ 5|7|AUX 6|5|NEG 7|2|CMOD 8|9|SUBJ
	9|7|COMP 10|14|JCT 11|12|DET 12|14|SUBJ 13|14|AUX 14|9|PRED 15|19|DET
	16|19|DET 17|19|MOD 18|17|POBJ 19|14|OBJ 20|22|LINK 21|22|SUBJ 22|25|CJCT
	23|24|DET 24|25|SUBJ 25|0|ROOT 26|27|DET 27|25|COMP 28|27|JCT 29|31|DET
	30|31|MOD 31|28|POBJ 32|25|PUNCT
*S1:	it's also possible to do a sort where you make a second copy (.)
	keep the original and then put a sorted (.) array in a second (.)
	data structure .
%mor:	pro:per|it~cop|be&3S adv|also adj|possible inf|to v|do det:art|a
	n|sort pro:rel|where pro:per|you v|make det:art|a n|second n|copy
	v|keep det:art|the adj|origin&dn-AL coord|and adv:tem|then
	v|put&ZERO det:art|a part|sort-PASTP n|array prep|in det:art|a
	adj|second n|data n|structure .
%gra:	1|2|SUBJ 2|0|ROOT 3|4|JCT 4|2|PRED 5|6|INF 6|4|XMOD 7|8|DET 8|6|OBJ
	9|11|LINK 10|11|SUBJ 11|8|CMOD 12|14|DET 13|14|MOD 14|15|SUBJ 15|11|COMP
	16|17|DET 17|15|OBJ 18|17|CONJ 19|18|COORD 20|17|CMOD 21|23|DET 22|23|MOD
	23|20|OBJ 24|20|JCT 25|28|DET 26|27|MOD 27|28|MOD 28|24|POBJ 29|2|PUNCT
*S1:	so that's not what we're doing we're actually doing the sort inside
	the array .
%mor:	co|so pro:dem|that~cop|be&3S neg|not pro:int|what
	pro:sub|we~aux|be&PRES part|do-PRESP pro:sub|we~aux|be&PRES
	adv|actual&dadj-LY part|do-PRESP det:art|the n|sort prep|inside
	det:art|the n|array .
%gra:	1|3|COM 2|3|SUBJ 3|0|ROOT 4|3|NEG 5|8|LINK 6|8|SUBJ 7|8|AUX 8|3|CPRED
	9|12|SUBJ 10|12|AUX 11|12|JCT 12|8|COMP 13|14|DET 14|12|OBJ 15|12|JCT
	16|17|DET 17|15|POBJ 18|3|PUNCT
*S1:	and let's actually go through this algorithm again .
%mor:	coord|and v|let~pro:obj|us adv|actual&dadj-LY v|go prep|through
	det:dem|this n|algorithm adv|again .
%gra:	1|2|LINK 2|0|ROOT 3|2|OBJ 4|5|JCT 5|2|COMP 6|5|JCT 7|8|DET 8|6|POBJ
	9|5|JCT 10|2|PUNCT
*S1:	we said there were N minus one passes .
%mor:	pro:sub|we v|say&PAST adv|there cop|be&PAST n:prop|N n|minus
	det:num|one n|pass-PL .
%gra:	1|2|SUBJ 2|0|ROOT 3|2|JCT 4|2|COMP 5|8|MOD 6|8|MOD 7|8|QUANT 8|4|PRED
	9|2|PUNCT
*S1:	here N is five so <we'll do> [/] we'll do four passes .
%mor:	adv|here n:prop|N cop|be&3S det:num|five adv|so pro:sub|we~mod|will
	v|do det:num|four n|pass-PL .
%gra:	1|3|JCT 2|3|SUBJ 3|0|ROOT 4|3|PRED 5|8|JCT 6|8|SUBJ 7|8|AUX 8|3|CPRED
	9|10|QUANT 10|8|OBJ 11|3|PUNCT
*S1:	and we said each one &-uh essentially takes us through the array
	elements one time .
%mor:	coord|and pro:sub|we v|say&PAST qn|each det:num|one
	adv|essential&dadj-LY v|take-3S pro:obj|us prep|through det:art|the
	n|array n|element-PL det:num|one n|time .
%gra:	1|3|LINK 2|3|SUBJ 3|0|ROOT 4|5|QUANT 5|3|OBJ 6|7|JCT 7|3|CJCT 8|7|OBJ
	9|7|JCT 10|14|DET 11|12|MOD 12|14|MOD 13|14|QUANT 14|9|POBJ 15|3|PUNCT
*S1:	we look at them all .
%mor:	pro:sub|we v|look prep|at pro:obj|them post|all .
%gra:	1|2|SUBJ 2|0|ROOT 3|2|JCT 4|3|POBJ 5|2|JCT 6|2|PUNCT
*S1:	we take the (.) item that's in the starting position for the
	current pass .
%mor:	pro:sub|we v|take det:art|the n|item pro:rel|that~aux|be&3S prep|in
	det:art|the part|start-PRESP n|position prep|for det:art|the
	n|current n|pass .
%gra:	1|2|SUBJ 2|0|ROOT 3|4|DET 4|2|OBJ 5|7|LINK 6|7|AUX 7|4|CMOD 8|10|DET
	9|10|MOD 10|7|POBJ 11|7|JCT 12|14|DET 13|14|MOD 14|11|POBJ 15|2|PUNCT
*S1:	and we exchange that or swap it (.) with the smallest item (.)
	that's in the unsorted part for the current pass .
%mor:	coord|and pro:sub|we v|exchange pro:dem|that coord|or v|swap
	pro:per|it prep|with det:art|the adj|small-SP n|item
	pro:rel|that~aux|be&3S prep|in det:art|the un#part|sort-PASTP n|part
	prep|for det:art|the n|current n|pass .
%gra:	1|3|LINK 2|3|SUBJ 3|0|ROOT 4|3|OBJ 5|3|CONJ 6|5|COORD 7|6|OBJ 8|6|JCT
	9|11|DET 10|11|MOD 11|8|POBJ 12|11|NJCT 13|12|INCROOT 14|13|JCT 15|17|DET
	16|17|MOD 17|14|POBJ 18|13|JCT 19|21|DET 20|21|MOD 21|18|POBJ
	22|13|PUNCT
*S1:	so essentially the idea is on one pass to sort one item (.) and we
	know from yesterday's (.) fairly quick discussion that after four
	passes (.) five elements would be sorted .
%mor:	co|so adv|essential&dadj-LY det:art|the n|idea cop|be&3S prep|on
	det:num|one n|pass prep|to n|sort pro:indef|one n|item coord|and
	pro:sub|we v|know prep|from adv:tem|yesterday~aux|be&3S
	adv|fair&dadj-LY adv|quick n|discussion pro:rel|that prep|after
	det:num|four n|pass-PL det:num|five n|element-PL mod|will&COND
	aux|be part|sort-PASTP .
%gra:	1|4|COM 2|4|JCT 3|4|DET 4|5|SUBJ 5|0|ROOT 6|5|JCT 7|8|QUANT 8|6|POBJ
	9|5|JCT 10|12|MOD 11|12|MOD 12|9|POBJ 13|15|LINK 14|15|SUBJ 15|5|PUNCT
	16|15|JCT 17|16|POBJ 18|15|INCROOT 19|20|JCT 20|18|JCT 21|20|POBJ 22|21|OM
	23|22|JCT 24|25|QUANT 25|23|POBJ 26|27|QUANT 27|30|SUBJ 28|30|AUX
	29|30|AUX 30|25|CMOD 31|18|PUNCT
*S1:	and that's always the case (.) always N minus one .
%mor:	coord|and pro:dem|that~cop|be&3S adv|always det:art|the n|case
	adv|always n:prop|N n|minus pro:indef|one .
%gra:	1|3|LINK 2|3|SUBJ 3|0|ROOT 4|3|JCT 5|6|DET 6|4|POBJ 7|6|NJCT 8|9|MOD
	9|10|MOD 10|7|POBJ 11|3|PUNCT
*S1:	&-uh it's worth noting at this point actually that this sort is not
	the most efficient sort (.) in the world we'll talk about that a
	little bit more later (.) but if you think about it (.) this sort
	does exactly the same process (.) even if the whole array is
	in_order_to begin with .
%mor:	pro:per|it~cop|be&3S adj|worth part|note-PRESP prep|at det:dem|this
	n|point adv|actual&dadj-LY adv|that det:dem|this n|sort cop|be&3S
	neg|not det:art|the qn|most adj|efficient n|sort prep|in det:art|the
	n|world pro:sub|we~mod|will v|talk prep|about comp|that det:art|a
	adj|little n|bit adv|more adv|later conj|but conj|if pro:per|you
	v|think prep|about pro:per|it det:dem|this n|sort mod|do&3S
	adv|exact&dadj-LY det:art|the adj|same n|process adv|even comp|if
	det:art|the adj|whole n|array cop|be&3S inf|in_order_to v|begin
	prep|with .
%gra:	1|2|SUBJ 2|0|ROOT 3|2|PRED 4|3|XMOD 5|4|JCT 6|7|DET 7|5|POBJ 8|12|JCT
	9|8|JCT 10|11|DET 11|9|POBJ 12|4|CJCT 13|12|NEG 14|17|DET 15|17|QUANT
	16|17|MOD 17|12|PRED 18|17|NJCT 19|20|DET 20|18|POBJ 21|23|SUBJ 22|23|AUX
	23|17|CMOD 24|23|JCT 25|28|DET 26|28|DET 27|28|MOD 28|24|POBJ 29|30|JCT
	30|28|NJCT 31|28|CONJ 32|34|LINK 33|34|SUBJ 34|31|COORD 35|49|JCT
	36|49|SUBJ 37|38|DET 38|43|SUBJ 39|43|AUX 40|43|JCT 41|43|DET 42|43|MOD
	43|49|SUBJ 44|49|JCT 45|49|LINK 46|48|DET 47|48|MOD 48|49|SUBJ 49|34|COMP
	50|51|INF 51|49|COMP 52|51|JCT 53|2|PUNCT
*S1:	it always does N minus one passes (.) it's not very intelligent it
	doesn't look to see &-uh if perhaps (.) something could be done
	quicker than that .
%mor:	pro:per|it adv|always mod|do&3S n:prop|N prep|minus det:num|one
	n|pass-PL pro:per|it~cop|be&3S neg|not adv|very adj|intelligent
	pro:per|it mod|do&3S~neg|not v|look inf|to v|see conj|if adv|perhaps
	pro:indef|something mod|could aux|be part|do&PASTP adj|quick-CP
	prep|than pro:dem|that .
%gra:	1|4|SUBJ 2|4|JCT 3|4|AUX 4|9|SUBJ 5|9|JCT 6|7|QUANT 7|5|POBJ 8|9|SUBJ
	9|0|ROOT 10|9|NEG 11|12|JCT 12|9|PRED 13|16|SUBJ 14|16|AUX 15|14|NEG
	16|12|CMOD 17|18|INF 18|16|COMP 19|24|LINK 20|24|JCT 21|24|SUBJ 22|24|AUX
	23|24|AUX 24|9|CJCT 25|24|PRED 26|25|JCT 27|26|POBJ 28|9|PUNCT
*S1:	(o)kay .
%mor:	co|okay .
%gra:	1|0|INCROOT 2|1|PUNCT
*S1:	so we keep doing this (.) and let's take a look again at these
	diagrams +...
%mor:	co|so pro:sub|we v|keep part|do-PRESP pro:dem|this coord|and
	v|let~pro:obj|us v|take det:art|a v|look adv|again prep|at
	det:dem|these n|diagram-PL +...
%gra:	1|3|COM 2|3|SUBJ 3|0|ROOT 4|3|COMP 5|4|OBJ 6|3|CONJ 7|6|COORD 8|7|OBJ
	9|7|COMP 10|11|DET 11|9|OBJ 12|11|JCT 13|11|JCT 14|15|DET 15|13|POBJ
	16|3|PUNCT
*S1:	so this is our starting point (.) initially the whole array's not
	sorted (.) that's the assumption (.) and the starting point would be
	the thirty two (.) that's the index of zero (.) and we know that on
	the first pass we took that element (.) and we exchanged it with the
	smallest item that's in the entire array .
%mor:	adv|so pro:dem|this cop|be&3S det:poss|our part|start-PRESP n|point
	adv|initial&dadj-LY det:art|the n|whole adj|array&dn-POSS neg|not
	part|sort-PASTP pro:dem|that~cop|be&3S det:art|the n|assumption
	coord|and det:art|the part|start-PRESP n|point mod|will&COND cop|be
	det:art|the det:num|thirty det:num|two pro:dem|that~cop|be&3S
	det:art|the n|index prep|of v|zero coord|and pro:sub|we v|know
	pro:dem|that prep|on det:art|the adj|first n|pass pro:sub|we
	v|take&PAST det:dem|that n|element coord|and pro:sub|we
	v|exchange-PAST pro:per|it prep|with det:art|the adj|small-SP n|item
	pro:rel|that~cop|be&3S prep|in det:art|the adj|entire n|array .
%gra:	1|2|JCT 2|3|SUBJ 3|0|ROOT 4|6|DET 5|6|XMOD 6|3|PRED 7|6|NJCT 8|9|DET
	9|7|POBJ 10|9|POSTMOD 11|10|NEG 12|10|XMOD 13|14|SUBJ 14|12|COMP 15|16|DET
	16|14|PRED 17|22|LINK 18|20|DET 19|20|MOD 20|22|SUBJ 21|22|AUX
	22|16|CMOD 23|24|DET 24|22|PRED 25|26|QUANT 26|27|SUBJ 27|24|CMOD 28|29|DET
	29|27|PRED 30|29|NJCT 31|30|POBJ 32|34|LINK 33|34|SUBJ 34|27|CJCT 35|34|OBJ
	36|34|JCT 37|39|DET 38|39|MOD 39|36|POBJ 40|41|SUBJ 41|34|CJCT 42|43|DET
	43|41|OBJ 44|46|LINK 45|46|SUBJ 46|41|CJCT 47|46|OBJ 48|46|JCT
	49|51|DET 50|51|MOD 51|48|POBJ 52|53|LINK 53|51|CMOD 54|53|JCT 55|57|DET
	56|57|MOD 57|54|POBJ 58|3|PUNCT
*S1:	so the thirty two and the minus sixteen get swapped (.) so in the
	array they have to trade places (.) and then what we have after that
	is (.) this (.) contents in the array where the minus sixteen is in
	the right spot (.) and the other items are still considered unsorted
	.
%mor:	adv|so det:art|the det:num|thirty det:num|two coord|and det:art|the
	n|minus det:num|sixteen aux|get part|swap-PASTP adv|so prep|in
	det:art|the n|array pro:sub|they v|have inf|to v|trade n|place-PL
	coord|and adv:tem|then pro:int|what pro:sub|we v|have prep|after
	pro:dem|that cop|be&3S det:dem|this v|content-3S prep|in det:art|the
	n|array pro:rel|where det:art|the n|minus det:num|sixteen aux|be&3S
	prep|in det:art|the adj|right n|spot coord|and det:art|the qn|other
	n|item-PL aux|be&PRES adv|still part|consider-PASTP
	un#part|sort-PASTP .
%gra:	1|3|JCT 2|3|DET 3|10|LINK 4|8|QUANT 5|4|CONJ 6|7|DET 7|5|COORD
	8|10|SUBJ 9|10|AUX 10|16|XJCT 11|10|JCT 12|10|JCT 13|14|DET 14|12|POBJ
	15|16|SUBJ 16|0|ROOT 17|18|INF 18|16|COMP 19|18|OBJ 20|18|CONJ 21|20|COORD
	22|24|LINK 23|24|SUBJ 24|27|CSUBJ 25|24|JCT 26|25|POBJ 27|21|CMOD 28|29|DET
	29|27|CPRED 30|29|JCT 31|32|DET 32|30|POBJ 33|48|LINK 34|35|DET 35|48|SUBJ
	36|37|QUANT 37|48|AUX 38|48|JCT 39|41|DET 40|41|MOD 41|38|POBJ
	42|41|CONJ 43|45|DET 44|45|QUANT 45|42|COORD 46|48|AUX 47|48|JCT 48|32|CMOD
	49|48|OBJ 50|16|PUNCT
*S1:	so we've got one item that got sorted on the first pass .
%mor:	adv|so pro:sub|we~aux|have part|get&PASTP pro:indef|one n|item
	pro:rel|that aux|get&PAST part|sort-PASTP prep|on det:art|the
	adj|first n|pass .
%gra:	1|4|JCT 2|4|SUBJ 3|4|AUX 4|0|ROOT 5|6|MOD 6|4|OBJ 7|9|LINK 8|9|AUX
	9|6|CMOD 10|9|JCT 11|13|DET 12|13|MOD 13|10|POBJ 14|4|PUNCT
*S1:	now (.) this is our starting point for the second pass (.) so let's
	take a look at that (0.6) (o)kay the other thing I've done here the
	(.) gray elements are intended to show you what is already sorted
	(.) and those are items we're not considering anymore .
%mor:	adv|now pro:dem|this cop|be&3S det:poss|our part|start-PRESP
	n|point prep|for det:art|the adj|second n|pass co|so
	v|let~pro:obj|us v|take det:art|a v|look prep|at det:dem|that
	adj|okay det:art|the qn|other n|thing pro:sub|I~aux|have
	part|do&PASTP adv|here det:art|the adj|gray n|element-PL aux|be&PRES
	part|intend-PASTP inf|to v|show pro:per|you pro:int|what aux|be&3S
	adv|already part|sort-PASTP coord|and pro:dem|those cop|be&PRES
	n|item-PL pro:sub|we~aux|be&PRES neg|not part|consider-PRESP
	adv|anymore .
%gra:	1|2|JCT 2|3|SUBJ 3|0|ROOT 4|6|DET 5|6|XMOD 6|3|PRED 7|6|NJCT 8|10|DET
	9|10|MOD 10|7|POBJ 11|12|COM 12|3|CPRED 13|12|OBJ 14|12|COMP 15|16|DET
	16|14|OBJ 17|16|JCT 18|19|DET 19|17|POBJ 20|22|DET 21|22|QUANT 22|17|POBJ
	23|25|SUBJ 24|25|AUX 25|22|CMOD 26|31|JCT 27|29|DET 28|29|MOD 29|31|SUBJ
	30|31|AUX 31|25|COMP 32|33|INF 33|31|COMP 34|33|OBJ 35|38|SUBJ
	36|38|AUX 37|38|JCT 38|33|COMP 39|41|LINK 40|41|SUBJ 41|38|CJCT 42|41|PRED
	43|46|SUBJ 44|46|AUX 45|44|NEG 46|42|CMOD 47|46|JCT 48|3|PUNCT
*S1:	so just like in the binary search where we eliminated parts of the
	array from (.) further consideration we're doing that with this (.)
	sort also .
%mor:	adv|so adj|just co|like prep|in det:art|the adj|binary n|search
	pro:rel|where pro:sub|we v|eliminate-PAST n|part-PL prep|of
	det:art|the n|array prep|from adj|further n|consider&dv-TION
	pro:sub|we~aux|be&PRES part|do-PRESP comp|that prep|with
	det:dem|this n|sort adv|also .
%gra:	1|2|JCT 2|20|JCT 3|2|COM 4|2|JCT 5|7|DET 6|7|MOD 7|4|POBJ 8|10|LINK
	9|10|SUBJ 10|7|CMOD 11|10|OBJ 12|11|NJCT 13|14|DET 14|12|POBJ 15|10|JCT
	16|17|MOD 17|15|POBJ 18|20|SUBJ 19|20|AUX 20|0|ROOT 21|25|LINK 22|25|JCT
	23|24|DET 24|22|POBJ 25|20|JCT 26|20|PUNCT
*S1:	so the minus sixteen at a@l sub zero is no longer being looked at
	(.) that means the starting point has an index of one (.) that's the
	one fifteen (.) and then we take the smallest item in (.) that part
	of the array (.) so the currently unsorted part (.) that would be
	the thirty two of_course (.) and then we swap those .
%mor:	co|so det:art|the n|minus det:num|sixteen prep|at n:let|a n|sub
	det:num|zero cop|be&3S qn|no adj|long-CP n|being v|look-PAST prep|at
	det:dem|that v|mean-3S det:art|the part|start-PRESP n|point
	v|have&3S det:art|a n|index prep|of det:num|one
	pro:dem|that~cop|be&3S det:art|the det:num|one det:num|fifteen
	coord|and adv:tem|then pro:sub|we v|take det:art|the adj|small-SP
	n|item prep|in adv|that n|part prep|of det:art|the n|array adv|so
	det:art|the adv|current&dadj-LY un#part|sort-PASTP adj|part adv|that
	mod|will&COND cop|be det:art|the det:num|thirty det:num|two
	co|of_course coord|and adv:tem|then pro:sub|we v|swap det:dem|those
	.
%gra:	1|3|COM 2|3|DET 3|0|INCROOT 4|5|QUANT 5|3|NJCT 6|9|COM 7|8|MOD 8|9|SUBJ
	9|5|POBJ 10|12|QUANT 11|12|MOD 12|13|JCT 13|9|CPRED 14|20|JCT 15|16|DET
	16|14|POBJ 17|19|DET 18|19|MOD 19|20|SUBJ 20|26|CJCT 21|22|DET
	22|20|OBJ 23|22|NJCT 24|23|POBJ 25|26|SUBJ 26|13|COMP 27|28|DET 28|26|PRED
	29|33|JCT 30|29|CONJ 31|30|COORD 32|33|SUBJ 33|28|CMOD 34|36|DET 35|36|MOD
	36|33|OBJ 37|33|JCT 38|37|POBJ 39|38|POBJ 40|39|NJCT 41|42|DET 42|40|POBJ
	43|46|JCT 44|46|DET 45|46|JCT 46|33|XJCT 47|50|SUBJ 48|50|JCT 49|50|AUX
	50|46|COMP 51|52|DET 52|50|PRED 53|54|QUANT 54|58|COM 55|54|CONJ
	56|55|COORD 57|58|SUBJ 58|52|CMOD 59|58|OBJ 60|3|PUNCT
*S1:	so again those trade places in the array (.) and we can see that
	after the second pass (.) two items are sorted .
%mor:	co|so adv|again det:dem|those n|trade n|place-PL prep|in
	det:art|the n|array coord|and pro:sub|we mod|can v|see comp|that
	prep|after det:art|the adj|second v|pass det:num|two n|item-PL
	aux|be&PRES part|sort-PASTP .
%gra:	1|5|COM 2|5|JCT 3|5|DET 4|5|MOD 5|0|INCROOT 6|5|NJCT 7|8|DET 8|6|POBJ
	9|12|LINK 10|12|SUBJ 11|12|AUX 12|5|CJCT 13|12|OBJ 14|13|JCT 15|17|DET
	16|17|MOD 17|14|CPOBJ 18|19|QUANT 19|21|SUBJ 20|21|AUX 21|17|COMP
	22|5|PUNCT
*S1:	so on the first pass we sorted one item (.) and on the second pass
	we sorted (.) the second item .
%mor:	adv|so prep|on det:art|the adj|first n|pass pro:sub|we v|sort-PAST
	det:num|one n|item coord|and prep|on det:art|the adj|second n|pass
	pro:sub|we v|sort-PAST det:art|the adj|second n|item .
%gra:	1|2|JCT 2|7|JCT 3|5|DET 4|5|MOD 5|2|POBJ 6|7|SUBJ 7|16|CJCT 8|9|QUANT
	9|7|OBJ 10|9|CONJ 11|10|COORD 12|14|DET 13|14|MOD 14|11|POBJ 15|16|SUBJ
	16|0|ROOT 17|19|DET 18|19|MOD 19|16|OBJ 20|16|PUNCT
*S1:	now that means that the (.) unsorted part again is shrinking (.)
	and now I've got three items that I have to sort (.) at that point .
%mor:	adv|now comp|that v|mean-3S comp|that det:art|the
	un#part|sort-PASTP adj|part adv|again aux|be&3S part|shrink-PRESP
	coord|and adv|now pro:sub|I~aux|have part|get&PASTP det:num|three
	n|item-PL pro:rel|that pro:sub|I v|have prep|to n|sort prep|at
	det:dem|that n|point .
%gra:	1|3|JCT 2|3|SUBJ 3|0|ROOT 4|10|LINK 5|10|DET 6|10|AUX 7|10|JCT 8|7|JCT
	9|10|AUX 10|3|COMP 11|10|CONJ 12|15|JCT 13|15|SUBJ 14|15|AUX 15|11|COORD
	16|17|QUANT 17|15|OBJ 18|20|LINK 19|20|SUBJ 20|17|CMOD 21|20|JCT
	22|21|POBJ 23|20|JCT 24|25|DET 25|23|POBJ 26|3|PUNCT
*S1:	(o)kay so let's look at the third pass (.) course that's this one
	(.) this is where we were after the second pass (.) with the top two
	items (.) sorted (.) and then we do the same process again .
%mor:	co|okay co|so v|let~pro:obj|us v|look prep|at det:art|the n|third
	n|pass n|course pro:rel|that~cop|be&3S det:dem|this pro:indef|one
	pro:dem|this cop|be&3S pro:int|where pro:sub|we cop|be&PAST
	prep|after det:art|the adj|second n|pass prep|with det:art|the n|top
	det:num|two n|item-PL v|sort-PAST coord|and adv:tem|then pro:sub|we
	v|do det:art|the adj|same n|process adv|again .
%gra:	1|3|COM 2|3|COM 3|0|ROOT 4|5|SUBJ 5|3|COMP 6|5|JCT 7|10|DET 8|10|MOD
	9|10|MOD 10|6|POBJ 11|12|LINK 12|10|CMOD 13|14|DET 14|12|PRED 15|16|SUBJ
	16|14|CMOD 17|19|LINK 18|19|SUBJ 19|16|PRED 20|19|JCT 21|23|DET 22|23|MOD
	23|20|POBJ 24|23|NJCT 25|26|DET 26|24|POBJ 27|28|QUANT 28|29|SUBJ
	29|26|CMOD 30|33|LINK 31|33|JCT 32|33|SUBJ 33|29|CJCT 34|36|DET 35|36|MOD
	36|33|OBJ 37|33|JCT 38|3|PUNCT
*S1:	it's really exactly the same process every time it's just that the
	(.) part of the array that we're looking at is shrinking .
%mor:	pro:per|it~cop|be&3S adv|real&dadj-LY adv|exact&dadj-LY det:art|the
	adj|same n|process qn|every n|time pro:per|it~cop|be&3S adj|just
	comp|that det:art|the n|part prep|of det:art|the n|array
	pro:rel|that pro:sub|we~aux|be&PRES part|look-PRESP prep|at
	aux|be&3S part|shrink-PRESP .
%gra:	1|2|SUBJ 2|0|ROOT 3|4|JCT 4|11|JCT 5|7|DET 6|7|MOD 7|11|SUBJ 8|9|QUANT
	9|11|JCT 10|11|SUBJ 11|2|ROOT 12|11|PRED 13|12|INCROOT 14|15|DET
	15|13|OBJ 16|15|NJCT 17|18|DET 18|16|POBJ 19|22|LINK 20|22|SUBJ 21|22|AUX
	22|18|CMOD 23|22|JCT 24|25|AUX 25|23|POBJ 26|13|PUNCT
*S1:	so the starting point now has an index of two (.) and that's the
	fifty six here (.) and then we can see that the smallest item in
	that part of your array is the forty three (.) and of_course we swap
	those (.) and then we end up (.) with this (.) array contents over
	here .
%mor:	co|so det:art|the part|start-PRESP n|point adv|now v|have&3S
	det:art|a n|index prep|of det:num|two coord|and
	pro:dem|that~cop|be&3S det:art|the det:num|fifty det:num|six
	adv|here coord|and adv:tem|then pro:sub|we mod|can v|see comp|that
	det:art|the adj|small-SP n|item prep|in det:dem|that n|part prep|of
	det:poss|your n|array cop|be&3S det:art|the det:num|forty
	det:num|three coord|and co|of_course pro:sub|we v|swap det:dem|those
	coord|and adv:tem|then pro:sub|we v|end adv|up prep|with
	det:dem|this n|array v|content-3S prep|over n|here .
%gra:	1|4|COM 2|4|DET 3|4|MOD 4|6|SUBJ 5|4|NJCT 6|0|ROOT 7|8|DET 8|6|OBJ
	9|13|LINK 10|13|SUBJ 11|10|CONJ 12|11|COORD 13|8|CMOD 14|15|DET 15|13|PRED
	16|17|QUANT 17|22|JCT 18|22|LINK 19|22|JCT 20|22|SUBJ 21|22|AUX
	22|15|CMOD 23|33|LINK 24|26|DET 25|26|MOD 26|33|SUBJ 27|26|NJCT 28|29|DET
	29|27|POBJ 30|29|NJCT 31|32|DET 32|30|POBJ 33|22|COMP 34|35|DET 35|40|QUANT
	36|40|JCT 37|36|CONJ 38|37|COORD 39|40|SUBJ 40|33|CPRED 41|45|DET
	42|41|CONJ 43|42|COORD 44|45|SUBJ 45|40|COMP 46|45|JCT 47|45|JCT 48|49|DET
	49|50|SUBJ 50|47|POBJ 51|50|JCT 52|51|POBJ 53|6|PUNCT
*S1:	so on the third pass the third item (.) lands in the correct spot
	+...
%mor:	adv|so prep|on det:art|the n|third n|pass det:art|the adj|third
	n|item n|land-PL prep|in det:art|the adj|correct n|spot +...
%gra:	1|2|JCT 2|0|INCROOT 3|5|DET 4|5|MOD 5|2|POBJ 6|9|DET 7|9|MOD 8|9|MOD
	9|2|POBJ 10|9|NJCT 11|13|DET 12|13|MOD 13|10|POBJ 14|2|PUNCT
*S1:	now the fourth pass is (.) the last one (0.5) we've only got two
	items left (.) and (.) you know from common sense if you've got two
	things and you sort them &-uh both of them will be in the correct
	order .
%mor:	adv|now det:art|the n|fourth n|pass cop|be&3S det:art|the adj|last
	pro:indef|one pro:sub|we~aux|have adv|only part|get&PASTP
	det:num|two n|item-PL adj|left coord|and pro:per|you v|know
	prep|from adj|common n|sense conj|if pro:per|you~aux|have
	part|get&PASTP det:num|two n|thing-PL coord|and pro:per|you v|sort
	pro:obj|them qn|both prep|of pro:obj|them mod|will cop|be prep|in
	det:art|the adj|correct n|order .
%gra:	1|5|JCT 2|4|DET 3|4|MOD 4|5|SUBJ 5|0|ROOT 6|8|DET 7|8|MOD 8|5|PRED
	9|12|SUBJ 10|12|AUX 11|12|JCT 12|8|CMOD 13|14|QUANT 14|12|OBJ 15|14|POSTMOD
	16|18|LINK 17|18|SUBJ 18|12|CJCT 19|18|JCT 20|21|MOD 21|19|POBJ
	22|25|LINK 23|25|SUBJ 24|25|AUX 25|18|CJCT 26|27|QUANT 27|25|OBJ 28|30|LINK
	29|30|SUBJ 30|25|CJCT 31|36|SUBJ 32|36|QUANT 33|36|JCT 34|33|POBJ 35|36|AUX
	36|30|COMP 37|36|JCT 38|40|DET 39|40|MOD 40|37|POBJ 41|5|PUNCT
*S1:	so we don't do five passes here we do four because that will take
	care of it (.) and the starting point now is at index three (.) and
	that's the one fifteen (.) the fifty six obviously is smaller than
	that so again we do a swap (.) and then we end up with the (.)
	correctly sorted array .
%mor:	co|so pro:sub|we mod|do~neg|not v|do det:num|five n|pass-PL
	adv|here pro:sub|we v|do det:num|four conj|because adv|that mod|will
	v|take n|care prep|of pro:per|it coord|and det:art|the
	part|start-PRESP n|point adv|now cop|be&3S prep|at n|index
	det:num|three coord|and pro:dem|that~cop|be&3S det:art|the
	det:num|one det:num|fifteen det:art|the det:num|fifty det:num|six
	adv|obvious&dadj-LY aux|be&3S adj|small-CP prep|than det:dem|that
	co|so adv|again pro:sub|we v|do det:art|a v|swap coord|and
	adv:tem|then pro:sub|we v|end adv|up prep|with det:art|the
	adv|correct&dadj-LY v|sort-PAST n|array .
%gra:	1|5|LINK 2|5|SUBJ 3|5|AUX 4|3|NEG 5|0|ROOT 6|7|QUANT 7|5|OBJ 8|5|JCT
	9|10|SUBJ 10|5|COMP 11|10|OBJ 12|15|LINK 13|15|JCT 14|15|AUX 15|5|CJCT
	16|15|OBJ 17|16|NJCT 18|17|POBJ 19|24|LINK 20|22|DET 21|22|MOD 22|24|SUBJ
	23|22|NJCT 24|15|CJCT 25|30|LINK 26|27|MOD 27|30|SUBJ 28|27|CONJ
	29|28|COORD 30|24|CJCT 31|32|DET 32|30|PRED 33|36|DATE 34|35|DET 35|36|DATE
	36|45|QUANT 37|45|JCT 38|45|AUX 39|38|PRED 40|39|JCT 41|42|DET 42|40|POBJ
	43|39|JCT 44|45|SUBJ 45|32|CMOD 46|47|DET 47|45|OBJ 48|51|LINK 49|51|JCT
	50|51|SUBJ 51|45|CJCT 52|51|JCT 53|51|JCT 54|56|DET 55|56|JCT 56|53|POBJ
	57|56|OBJ 58|5|PUNCT
*S1:	so at this point we're done .
%mor:	adv|so prep|at det:dem|this n|point pro:sub|we~aux|be&PRES
	part|do&PASTP .
%gra:	1|2|JCT 2|7|JCT 3|4|DET 4|2|POBJ 5|7|SUBJ 6|7|AUX 7|0|ROOT 8|7|PUNCT
*S1:	N minus one passes and that's it .
%mor:	n:prop|N prep|minus det:num|one n|pass-PL coord|and
	pro:dem|that~cop|be&3S pro:per|it .
%gra:	1|7|SUBJ 2|1|NJCT 3|4|QUANT 4|2|POBJ 5|1|CONJ 6|5|COORD 7|0|ROOT
	8|7|PRED 9|7|PUNCT
*S1:	now (.) the next thing we're going to look at is the actual c@l
	plus [/] plus code for it (.) and (.) hopefully everybody can keep
	in mind &-uh the process (.) behind this &-uh it might be worth (.)
	while you're studying for the final &-uh to work through this by
	hand and just (.) go through the algorithm yourself with a piece of
	paper .
%mor:	adv|now det:art|the adj|next n|thing pro:sub|we~aux|be&PRES
	part|go-PRESP inf|to v|look prep|at cop|be&3S det:art|the adj|actual
	n:let|c adv|plus n|code prep|for pro:per|it coord|and
	adv|hope&dadj-FULL-LY pro:indef|everybody mod|can v|keep prep|in
	n|mind det:art|the n|process adv|behind det:dem|this pro:per|it
	mod|might cop|be n|worth n|while pro:per|you~aux|be&PRES
	part|study-PRESP prep|for det:art|the n|final prep|to n|work
	adj|through det:dem|this prep|by n|hand coord|and adv|just v|go
	adj|through det:art|the n|algorithm pro:refl|yourself prep|with
	det:art|a n|piece prep|of n|paper .
%gra:	1|0|INCROOT 2|4|DET 3|4|MOD 4|1|PUNCT 5|7|SUBJ 6|7|AUX 7|4|ROOT 8|9|INF
	9|7|COMP 10|9|JCT 11|10|POBJ 12|14|DET 13|14|MOD 14|9|ROOT 15|16|JCT
	16|14|INCROOT 17|16|NJCT 18|17|POBJ 19|23|LINK 20|23|JCT 21|23|SUBJ
	22|23|AUX 23|16|ROOT 24|23|JCT 25|24|POBJ 26|27|DET 27|23|INCROOT 28|27|NJCT
	29|28|POBJ 30|32|SUBJ 31|32|AUX 32|29|ROOT 33|34|MOD 34|32|PRED
	35|37|SUBJ 36|37|AUX 37|34|ROOT 38|37|JCT 39|40|DET 40|38|POBJ 41|40|NJCT
	42|41|POBJ 43|37|JCT 44|43|INCROOT 45|44|JCT 46|45|POBJ 47|44|CONJ 48|49|JCT
	49|47|COORD 50|53|MOD 51|52|DET 52|53|SUBJ 53|49|OBJ 54|49|JCT 55|56|DET
	56|54|POBJ 57|56|NJCT 58|57|POBJ 59|44|PUNCT
*S1:	and then compare that with the actual c@l plus [/] plus code and
	make sure you can &-uh make the connection between the two .
%mor:	coord|and adv:tem|then v|compare pro:dem|that prep|with det:art|the
	adj|actual n:let|c n|plus n|code coord|and v|make adv|sure
	pro:per|you mod|can v|make det:art|the n|connection prep|between
	det:art|the det:num|two .
%gra:	1|3|LINK 2|3|JCT 3|0|ROOT 4|3|OBJ 5|3|JCT 6|10|DET 7|10|MOD 8|10|MOD
	9|10|MOD 10|5|POBJ 11|3|CONJ 12|11|COORD 13|16|JCT 14|16|SUBJ 15|16|AUX
	16|12|COMP 17|18|DET 18|16|OBJ 19|16|JCT 20|21|DET 21|19|POBJ 22|3|PUNCT
*S1:	now a couple things before we (.) actually look at it &-uh I kept
	mentioning the starting point (.) and we'll have one index called
	start (.) and that'll be the index to the first item that's in the
	unsorted part of the array .
%mor:	adv|now det:art|a qn|couple n|thing-PL conj|before pro:sub|we
	adv|actual&dadj-LY v|look prep|at pro:per|it pro:sub|I v|keep&PAST
	part|mention-PRESP det:art|the part|start-PRESP n|point coord|and
	pro:sub|we~mod|will aux|have det:num|one n|index v|call-PAST v|start
	coord|and pro:rel|that~mod|will cop|be det:art|the n|index prep|to
	det:art|the adj|first n|item pro:rel|that~aux|be&3S prep|in
	det:art|the un#part|sort-PASTP n|part prep|of det:art|the n|array .
%gra:	1|12|JCT 2|4|DET 3|4|QUANT 4|12|SUBJ 5|8|LINK 6|8|SUBJ 7|8|JCT
	8|12|CJCT 9|8|JCT 10|9|POBJ 11|12|SUBJ 12|0|ROOT 13|23|XJCT 14|16|DET 15|16|MOD
	16|13|OBJ 17|21|LINK 18|21|SUBJ 19|21|AUX 20|21|AUX 21|22|QUANT
	22|23|SUBJ 23|12|PUNCT 24|23|OBJ 25|23|CONJ 26|28|LINK 27|28|AUX 28|25|ROOT
	29|30|DET 30|28|PRED 31|30|NJCT 32|34|DET 33|34|MOD 34|31|POBJ 35|34|NJCT
	36|35|INCROOT 37|36|JCT 38|40|DET 39|40|MOD 40|37|POBJ 41|40|NJCT
	42|43|DET 43|41|POBJ 44|36|PUNCT
*S1:	so start hasta range from (.) zero up through (.) three .
%mor:	adv|so v|start mod|have&3S~inf|to v|range prep|from n|zero adv|up
	prep|through det:num|three .
%gra:	1|2|JCT 2|0|ROOT 3|5|AUX 4|5|INF 5|2|COMP 6|5|JCT 7|6|POBJ 8|5|JCT
	9|5|JCT 10|9|POBJ 11|2|PUNCT
*S1:	and of_course that's zero up through &-uh N minus two .
%mor:	coord|and co|of_course pro:dem|that~cop|be&3S n|zero adv|up
	prep|through n:prop|N prep|minus det:num|two .
%gra:	1|4|LINK 2|4|COM 3|4|SUBJ 4|0|ROOT 5|4|PRED 6|5|JCT 7|5|NJCT 8|7|POBJ
	9|5|NJCT 10|9|POBJ 11|4|PUNCT
*S1:	if we use N as a reference point .
%mor:	conj|if pro:sub|we v|use n:prop|N conj|as det:art|a n|reference
	n|point .
%gra:	1|3|LINK 2|3|SUBJ 3|0|ROOT 4|3|OBJ 5|8|COORD 6|8|DET 7|8|MOD 8|3|ENUM
	9|3|PUNCT
*S1:	now we also need a_couple_of other indexes &-uh one of them will be
	called current (.) and current will range from (.) the index that's
	right after the starting index (.) so start plus one (.) and that
	will sequentially go through the array (.) looking for the smallest
	item .
%mor:	adv|now pro:sub|we adv|also v|need qn|a_couple_of qn|other
	n|index-PL det:num|one prep|of pro:obj|them mod|will aux|be
	part|call-PASTP n|current coord|and adj|current mod|will v|range
	prep|from det:art|the n|index pro:rel|that~aux|be&3S adj|right
	prep|after det:art|the part|start-PRESP n|index co|so v|start
	adv|plus det:num|one coord|and adv|that mod|will
	adv|sequential&dadj-LY v|go adj|through det:art|the n|array
	part|look-PRESP prep|for det:art|the adj|small-SP n|item .
%gra:	1|4|JCT 2|4|SUBJ 3|4|JCT 4|0|ROOT 5|7|QUANT 6|7|QUANT 7|4|OBJ 8|13|SUBJ
	9|8|NJCT 10|9|POBJ 11|13|AUX 12|13|AUX 13|7|CMOD 14|13|OBJ 15|18|LINK
	16|18|SUBJ 17|18|AUX 18|4|CJCT 19|18|JCT 20|21|DET 21|19|POBJ 22|30|LINK
	23|30|AUX 24|30|JCT 25|24|JCT 26|28|DET 27|28|MOD 28|25|POBJ 29|30|COM
	30|21|CMOD 31|32|JCT 32|30|COMP 33|37|LINK 34|37|JCT 35|37|AUX 36|37|JCT
	37|32|CJCT 38|40|MOD 39|40|DET 40|37|OBJ 41|40|XMOD 42|41|JCT 43|45|DET
	44|45|MOD 45|42|POBJ 46|4|PUNCT
*S1:	and if you think way back when we talked about &-uh finding maximum
	and minimum &-uh we used a while@q loop for that &-uh early part of
	the semester .
%mor:	coord|and conj|if pro:per|you v|think adv|way adv|back conj|when
	pro:sub|we v|talk-PAST adv|about part|find-PRESP adj|maximum
	coord|and adj|minimum pro:sub|we v|use-PAST det:art|a meta|while
	n|loop prep|for pro:dem|that adv|early n|part prep|of det:art|the
	n|semester .
%gra:	1|4|LINK 2|4|LINK 3|4|SUBJ 4|0|ROOT 5|4|JCT 6|4|JCT 7|9|LINK 8|9|SUBJ
	9|4|CJCT 10|11|JCT 11|9|COMP 12|16|JCT 13|12|CONJ 14|13|COORD 15|16|SUBJ
	16|11|COMP 17|19|DET 18|19|MOD 19|16|OBJ 20|16|JCT 21|20|POBJ 22|16|JCT
	23|22|POBJ 24|23|NJCT 25|26|DET 26|24|POBJ 27|4|PUNCT
*S1:	essentially what we did was we (.) held the smallest value , the
	one we currently (.) thought was the smallest , in a (.) special
	place in a variable .
%mor:	adv|essential&dadj-LY pro:int|what pro:sub|we mod|do&PAST
	aux|be&PAST&13S pro:sub|we v|hold&PAST det:art|the adj|small-SP
	n|value cm|cm det:art|the pro:indef|one pro:sub|we
	adv|current&dadj-LY v|think&PAST cop|be&PAST&13S det:art|the
	adj|small-SP cm|cm prep|in det:art|a adj|special n|place prep|in
	det:art|a n|variable .
%gra:	1|7|JCT 2|7|LINK 3|7|SUBJ 4|7|AUX 5|7|AUX 6|7|SUBJ 7|0|ROOT 8|10|DET
	9|10|MOD 10|7|OBJ 11|7|LP 12|13|DET 13|17|SUBJ 14|16|SUBJ 15|16|JCT
	16|13|CMOD 17|7|CJCT 18|19|DET 19|17|PRED 20|19|LP 21|17|JCT 22|24|DET
	23|24|MOD 24|21|POBJ 25|24|NJCT 26|27|DET 27|25|POBJ 28|7|PUNCT
*S1:	and then as we looked at each_other element in the data set
	sequentially we compared it to see (.) if it was smaller than the
	(.) currently smallest item .
%mor:	coord|and adv:tem|then conj|as pro:sub|we v|look-PAST prep|at
	pro:refl|each_other n|element prep|in det:art|the n|data v|set&ZERO
	adv|sequential&dadj-LY pro:sub|we v|compare-PAST pro:per|it inf|to
	v|see conj|if pro:per|it cop|be&PAST&13S adj|small-CP prep|than
	det:art|the adv|current&dadj-LY adj|small-SP n|item .
%gra:	1|15|LINK 2|15|JCT 3|5|LINK 4|5|SUBJ 5|15|CJCT 6|5|JCT 7|12|LINK
	8|12|SUBJ 9|8|NJCT 10|11|DET 11|9|POBJ 12|6|POBJ 13|12|JCT 14|15|SUBJ
	15|0|ROOT 16|15|OBJ 17|18|INF 18|15|XJCT 19|21|LINK 20|21|SUBJ 21|18|COMP
	22|21|PRED 23|22|JCT 24|27|DET 25|26|JCT 26|27|MOD 27|23|POBJ 28|15|PUNCT
*S1:	and if it was smaller we replaced (.) what we thought was the
	smallest value .
%mor:	coord|and conj|if pro:per|it cop|be&PAST&13S adj|small-CP
	pro:sub|we re#part|place-PASTP pro:int|what pro:sub|we v|think&PAST
	cop|be&PAST&13S det:art|the adj|small-SP n|value .
%gra:	1|4|LINK 2|4|LINK 3|4|SUBJ 4|0|ROOT 5|4|PRED 6|4|PRED 7|6|PQ
	8|7|INCROOT 9|10|SUBJ 10|8|CMOD 11|10|COMP 12|14|DET 13|14|MOD 14|11|PRED
	15|8|PUNCT
*S1:	now the same algorithm is actually being used here (.) the
	difference is that we use array indexes (.) and what we do is store
	the index of the smallest item (.) and if we find a new smallest
	item we replace the index that we're saving .
%mor:	adv|now det:art|the adj|same n|algorithm aux|be&3S
	adv|actual&dadj-LY n|being part|use-PASTP adv|here det:art|the
	n|difference cop|be&3S comp|that pro:sub|we n|use n|array n|index-PL
	coord|and pro:int|what pro:sub|we v|do cop|be&3S v|store det:art|the
	n|index prep|of det:art|the adj|small-SP n|item coord|and conj|if
	pro:sub|we v|find det:art|a adj|new adj|small-SP n|item pro:sub|we
	re#n|place det:art|the n|index pro:rel|that pro:sub|we~aux|be&PRES
	part|save-PRESP .
%gra:	1|8|JCT 2|4|DET 3|4|MOD 4|8|SUBJ 5|8|AUX 6|5|NJCT 7|6|POBJ 8|0|ROOT
	9|12|JCT 10|11|DET 11|12|SUBJ 12|8|COMP 13|17|LINK 14|17|SUBJ 15|17|MOD
	16|17|MOD 17|23|SUBJ 18|17|CONJ 19|21|LINK 20|21|SUBJ 21|18|COORD 22|23|AUX
	23|12|CPRED 24|25|DET 25|23|OBJ 26|25|NJCT 27|29|DET 28|29|MOD
	29|26|POBJ 30|23|CONJ 31|33|LINK 32|33|SUBJ 33|30|COORD 34|37|DET 35|37|MOD
	36|37|MOD 37|33|OBJ 38|39|SUBJ 39|37|CMOD 40|41|DET 41|39|OBJ 42|45|LINK
	43|45|SUBJ 44|45|AUX 45|41|CMOD 46|8|PUNCT
*S1:	so instead of &sto saving the actual smallest value we save the
	index to it +...
%mor:	adv|so adv|instead prep|of n:gerund|save-PRESP det:art|the
	adj|actual adj|small-SP n|value pro:sub|we v|save det:art|the
	n|index prep|to pro:per|it +...
%gra:	1|2|JCT 2|10|JCT 3|2|JCT 4|3|POBJ 5|8|DET 6|8|MOD 7|8|MOD 8|4|OBJ
	9|10|SUBJ 10|0|ROOT 11|12|DET 12|10|OBJ 13|10|JCT 14|13|POBJ 15|10|PUNCT
*S1:	now actually before we (.) leave this &-uh that (.) actually points
	out the fact that we need a third index (.) for the smallest item .
%mor:	adv|now adv|actual&dadj-LY prep|before pro:sub|we v|leave
	det:dem|this adv|that adv|actual&dadj-LY v|point-3S prep|out
	det:art|the n|fact pro:rel|that pro:sub|we v|need det:art|a n|third
	n|index prep|for det:art|the adj|small-SP n|item .
%gra:	1|2|JCT 2|5|JCT 3|5|JCT 4|5|SUBJ 5|0|ROOT 6|9|DET 7|9|JCT 8|9|JCT
	9|5|COMP 10|9|JCT 11|12|DET 12|10|POBJ 13|15|LINK 14|15|SUBJ 15|12|CMOD
	16|18|DET 17|18|MOD 18|15|OBJ 19|15|JCT 20|22|DET 21|22|MOD 22|19|POBJ
	23|5|PUNCT
*S1:	so three indexes (.) and actually let's (.) jump into the code here
	+...
%mor:	adv|so det:num|three n|index-PL coord|and adv|actual&dadj-LY
	v|let~pro:obj|us v|jump prep|into det:art|the n|code adv|here +...
%gra:	1|2|JCT 2|3|QUANT 3|8|JCT 4|3|CONJ 5|6|JCT 6|4|COORD 7|8|SUBJ 8|0|ROOT
	9|8|JCT 10|11|DET 11|9|POBJ 12|8|JCT 13|8|PUNCT
*S1:	(o)kay so here's the function &-uh just like the search routines if
	you do write a sort (.) and program six does require a sort .
%mor:	co|okay co|so pro:exist|here~cop|be&3S det:art|the n|function
	adv|just prep|like det:art|the n|search n|routine-PL conj|if
	pro:per|you v|do v|write det:art|a n|sort coord|and v|program
	det:num|six mod|do&3S v|require det:art|a n|sort .
%gra:	1|4|COM 2|4|COM 3|4|SUBJ 4|0|ROOT 5|6|DET 6|4|PRED 7|8|JCT 8|6|NJCT
	9|11|DET 10|11|MOD 11|8|POBJ 12|14|LINK 13|14|SUBJ 14|4|CJCT 15|14|OBJ
	16|17|DET 17|15|OBJ 18|14|CONJ 19|18|COORD 20|22|SUBJ 21|22|AUX 22|19|COMP
	23|24|DET 24|22|OBJ 25|4|PUNCT
*S1:	it is best to put it off in its own (.) function .
%mor:	pro:per|it cop|be&3S adj|good&SP inf|to v|put&ZERO pro:per|it
	adv|off prep|in det:poss|its adj|own n|function .
%gra:	1|2|SUBJ 2|0|ROOT 3|2|JCT 4|5|INF 5|2|XJCT 6|5|OBJ 7|5|JCT 8|5|JCT
	9|11|DET 10|11|MOD 11|8|POBJ 12|2|PUNCT
*S1:	&-uh again a sort is really a task unto itself just like a search
	(.) and to make your program modular this really belongs (.) in a
	function all by itself .
%mor:	adv|again det:art|a n|sort cop|be&3S adv|real&dadj-LY det:art|a
	n|task prep|unto pro:refl|itself adv|just prep|like det:art|a
	n|search coord|and inf|to v|make det:poss|your n|program adj|modular
	det:dem|this adv|real&dadj-LY v|belong-3S adv|in det:art|a
	n|function adv|all adv|by pro:refl|itself .
%gra:	1|4|JCT 2|3|DET 3|4|SUBJ 4|0|ROOT 5|7|JCT 6|7|DET 7|4|PRED 8|7|NJCT
	9|8|POBJ 10|11|JCT 11|7|NJCT 12|13|DET 13|11|POBJ 14|7|CONJ 15|16|INF
	16|14|COORD 17|18|DET 18|16|OBJ 19|18|POSTMOD 20|22|DET 21|22|JCT 22|16|COMP
	23|28|JCT 24|25|DET 25|28|SUBJ 26|27|JCT 27|28|JCT 28|22|COMP 29|4|PUNCT
*S1:	so what we do up here is &-uh pass in (.) the size of the array (.)
	and N is the assumption here (.) N was five in our example that we
	just did (.) and then we're just calling this array A it's a generic
	name &-uh just an array of ints [: integers] .
%mor:	adv|so pro:int|what pro:sub|we v|do prep|up n|here cop|be&3S v|pass
	prep|in det:art|the n|size prep|of det:art|the n|array coord|and
	n:prop|N cop|be&3S det:art|the n|assumption adv|here n:prop|N
	cop|be&PAST&13S det:num|five prep|in det:poss|our ex#adj|ample
	comp|that pro:sub|we adv|just v|do&PAST coord|and adv:tem|then
	pro:sub|we~aux|be&PRES adv|just part|call-PRESP det:dem|this n|array
	n:prop|A pro:per|it~cop|be&3S det:art|a adj|generic n|name adv|just
	det:art|a n|array prep|of n|integer-PL .
%gra:	1|2|JCT 2|4|LINK 3|4|SUBJ 4|7|CSUBJ 5|4|JCT 6|5|POBJ 7|8|SUBJ 8|0|ROOT
	9|8|JCT 10|11|DET 11|9|POBJ 12|11|NJCT 13|14|DET 14|12|POBJ 15|17|LINK
	16|17|SUBJ 17|8|CJCT 18|19|DET 19|17|PRED 20|22|JCT 21|22|SUBJ 22|19|CMOD
	23|22|PRED 24|23|JCT 25|26|DET 26|24|POBJ 27|30|LINK 28|30|SUBJ
	29|30|JCT 30|23|CJCT 31|30|CONJ 32|36|JCT 33|36|SUBJ 34|36|AUX 35|36|JCT
	36|31|COORD 37|38|DET 38|36|OBJ 39|41|COM 40|41|SUBJ 41|36|COMP 42|44|DET
	43|44|MOD 44|41|PRED 45|47|JCT 46|47|DET 47|44|XMOD 48|47|NJCT 49|48|POBJ
	50|8|PUNCT
*S1:	now once we get into the local declarations that's where we start
	seeing (.) the items from the algorithm we just talked about (.)
	we've got start small and current .
%mor:	adv|now adv|once pro:sub|we v|get prep|into det:art|the n|local
	n|declare&dv-TION-PL pro:rel|that~cop|be&3S pro:int|where pro:sub|we
	v|start part|see-PRESP det:art|the n|item-PL prep|from det:art|the
	n|algorithm pro:sub|we adv|just part|talk-PASTP adv|about
	pro:sub|we~aux|have part|get&PASTP v|start adj|small coord|and
	adj|current .
%gra:	1|2|JCT 2|4|JCT 3|4|SUBJ 4|0|ROOT 5|4|JCT 6|8|DET 7|8|MOD 8|5|POBJ
	9|10|LINK 10|8|ROOT 11|13|LINK 12|13|SUBJ 13|10|ROOT 14|13|COMP 15|16|DET
	16|14|OBJ 17|14|JCT 18|19|DET 19|17|POBJ 20|14|INCROOT 21|22|JCT
	22|20|XMOD 23|26|JCT 24|26|SUBJ 25|26|AUX 26|22|COMP 27|26|OBJ 28|27|JCT
	29|28|CONJ 30|29|COORD 31|20|PUNCT
*S1:	and as I mentioned start is the index to the first element in the
	unsorted part (.) small is going to be the index to the smallest
	value in the unsorted part (.) and (.) what we do on a pass is
	exchange a@l sub start with a@l sub small .
%mor:	coord|and conj|as pro:sub|I v|mention-PAST v|start aux|be&3S
	det:art|the n|index prep|to det:art|the adj|first n|element prep|in
	det:art|the un#part|sort-PASTP adj|part adj|small aux|be&3S
	part|go-PRESP inf|to cop|be det:art|the n|index prep|to det:art|the
	adj|small-SP n|value prep|in det:art|the un#part|sort-PASTP n|part
	coord|and pro:int|what pro:sub|we v|do prep|on det:art|a n|pass
	cop|be&3S v|exchange n:let|a n|sub v|start prep|with n:let|a n|sub
	adj|small .
%gra:	1|4|LINK 2|4|LINK 3|4|SUBJ 4|0|ROOT 5|4|COMP 6|8|AUX 7|8|DET 8|5|OBJ
	9|8|NJCT 10|12|DET 11|12|MOD 12|9|POBJ 13|12|NJCT 14|15|DET 15|13|POBJ
	16|19|JCT 17|19|SUBJ 18|19|AUX 19|15|CMOD 20|21|INF 21|19|COMP 22|23|DET
	23|40|SUBJ 24|23|NJCT 25|27|DET 26|27|MOD 27|24|POBJ 28|27|NJCT 29|31|DET
	30|31|MOD 31|28|POBJ 32|23|CONJ 33|35|LINK 34|35|SUBJ 35|32|COORD
	36|35|JCT 37|38|DET 38|36|POBJ 39|40|AUX 40|21|CPRED 41|40|OBJ 42|43|SUBJ
	43|41|COMP 44|43|JCT 45|44|POBJ 46|47|MOD 47|45|POSTMOD 48|4|PUNCT
*S1:	so that's how we trade these we know the indexes where they're
	located .
%mor:	co|so pro:dem|that~cop|be&3S pro:int|how pro:sub|we v|trade
	det:dem|these pro:sub|we v|know det:art|the n|index-PL pro:rel|where
	pro:sub|they~aux|be&PRES part|locate-PASTP .
%gra:	1|3|COM 2|3|SUBJ 3|0|ROOT 4|6|LINK 5|6|SUBJ 6|3|CPRED 7|9|DET 8|9|SUBJ
	9|6|COMP 10|11|DET 11|9|OBJ 12|15|LINK 13|15|SUBJ 14|15|AUX 15|11|CMOD
	16|3|PUNCT
*S1:	this other one (.) current &-uh you can think of that as being (.)
	kind_of like a search index &-uh in a way this looking for the
	smallest is kind_of like a linear search .
%mor:	pro:dem|this qn|other pro:indef|one adj|current pro:per|you mod|can
	v|think prep|of pro:dem|that prep|as part|be-PRESP adv|kind_of
	co|like det:art|a n|search n|index prep|in det:art|a n|way
	det:dem|this part|look-PRESP prep|for det:art|the adj|small-SP
	cop|be&3S adv|kind_of co|like det:art|a adj|linear n|search .
%gra:	1|0|INCROOT 2|3|QUANT 3|1|OBJ 4|7|JCT 5|7|SUBJ 6|7|AUX 7|3|CMOD 8|7|JCT
	9|8|POBJ 10|7|JCT 11|10|POBJ 12|11|JCT 13|11|COM 14|16|DET 15|16|MOD
	16|11|OBJ 17|11|JCT 18|19|DET 19|17|POBJ 20|11|PRED 21|20|XMOD 22|25|JCT
	23|24|DET 24|25|SUBJ 25|21|CJCT 26|27|JCT 27|30|COM 28|30|DET 29|30|MOD
	30|25|PRED 31|1|PUNCT
*S1:	we're sequentially going through the array (.) we're looking at
	each item in turn (.) to see if it's a new small value .
%mor:	pro:sub|we~aux|be&PRES adv|sequential&dadj-LY part|go-PRESP
	prep|through det:art|the n|array pro:sub|we~aux|be&PRES
	part|look-PRESP prep|at qn|each n|item prep|in n|turn inf|to v|see
	conj|if pro:per|it~cop|be&3S det:art|a adj|new adj|small n|value .
%gra:	1|4|SUBJ 2|4|AUX 3|4|JCT 4|0|ROOT 5|4|JCT 6|7|DET 7|5|POBJ 8|10|SUBJ
	9|10|AUX 10|4|XJCT 11|10|JCT 12|13|QUANT 13|11|POBJ 14|13|NJCT 15|14|POBJ
	16|17|INF 17|10|XJCT 18|20|LINK 19|20|SUBJ 20|17|COMP 21|24|DET
	22|24|MOD 23|24|MOD 24|20|PRED 25|4|PUNCT
*S1:	and current is the index that takes care of that .
%mor:	coord|and adj|current cop|be&3S det:art|the n|index pro:rel|that
	v|take-3S n|care prep|of pro:dem|that .
%gra:	1|3|LINK 2|3|SUBJ 3|0|ROOT 4|5|DET 5|3|PRED 6|7|LINK 7|5|CMOD 8|7|OBJ
	9|8|NJCT 10|9|POBJ 11|3|PUNCT
*S1:	now these three are all (.) ints [: integers] (.) and the important
	point here is that they are ints [: integers] because that's the (.)
	index type of the array .
%mor:	adv|now pro:dem|these det:num|three aux|be&PRES adv|all
	n|integer-PL coord|and det:art|the adj|important n|point adv|here
	cop|be&3S comp|that pro:sub|they cop|be&PRES n|integer-PL
	conj|because pro:rel|that~cop|be&3S det:art|the n|index n|type
	prep|of det:art|the n|array .
%gra:	1|2|JCT 2|3|SUBJ 3|6|SUBJ 4|6|AUX 5|6|JCT 6|0|INCROOT 7|12|LINK
	8|10|DET 9|10|MOD 10|12|SUBJ 11|12|JCT 12|6|CJCT 13|15|LINK 14|15|SUBJ
	15|12|PRED 16|15|PRED 17|15|PRED 18|19|LINK 19|17|CMOD 20|22|DET 21|22|MOD
	22|19|PRED 23|22|NJCT 24|25|DET 25|23|POBJ 26|6|PUNCT
*S1:	so the type of the subscripts (.) is int [: integer] .
%mor:	co|so det:art|the n|type prep|of det:art|the sub#n|script-PL
	cop|be&3S n|integer .
%gra:	1|7|COM 2|3|DET 3|7|SUBJ 4|3|NJCT 5|6|DET 6|4|POBJ 7|0|ROOT 8|7|PRED
	9|7|PUNCT
*S1:	this fourth one here is an int [: integer] (.) but when you write
	another sort like you write the one for program six (.) this fourth
	variable probably won't be an int [: integer] .
%mor:	det:dem|this adj|fourth det:num|one pro:exist|here cop|be&3S
	det:art|a n|integer conj|but conj|when pro:per|you v|write
	qn|another n|sort prep|like pro:per|you v|write det:art|the
	pro:indef|one prep|for n|program det:num|six det:dem|this adj|fourth
	n|variable adv|probable&dadj-LY mod|will~neg|not cop|be det:art|a
	n|integer .
%gra:	1|3|DET 2|3|MOD 3|5|LINK 4|5|SUBJ 5|0|ROOT 6|7|DET 7|5|PRED 8|28|LINK
	9|11|LINK 10|11|SUBJ 11|28|CJCT 12|13|QUANT 13|11|OBJ 14|11|JCT
	15|16|SUBJ 16|14|POBJ 17|18|DET 18|28|SUBJ 19|18|NJCT 20|21|MOD 21|24|QUANT
	22|24|DET 23|24|MOD 24|19|POBJ 25|28|JCT 26|28|AUX 27|26|NEG 28|5|CJCT
	29|30|DET 30|28|PRED 31|5|PUNCT
*S1:	what this needs to be is the type (.) of the elements that are in
	the array .
%mor:	pro:int|what det:dem|this n|need-PL inf|to cop|be cop|be&3S
	det:art|the n|type prep|of det:art|the n|element-PL pro:rel|that
	cop|be&PRES prep|in det:art|the n|array .
%gra:	1|3|LINK 2|3|DET 3|5|SUBJ 4|5|INF 5|6|SUBJ 6|0|ROOT 7|8|DET 8|6|PRED
	9|8|NJCT 10|11|DET 11|9|POBJ 12|13|LINK 13|11|CMOD 14|13|JCT 15|16|DET
	16|14|POBJ 17|6|PUNCT
*S1:	so if you've got an array of [/] of say title strings (.) the type
	here would be a title string .
%mor:	co|so comp|if pro:per|you~aux|have part|get&PASTP det:art|a n|array
	prep|of co|say n|title v|string-3S det:art|the n|type adv|here
	mod|will&COND cop|be det:art|a n|title n|string .
%gra:	1|5|COM 2|5|LINK 3|5|SUBJ 4|5|AUX 5|0|ROOT 6|7|DET 7|5|OBJ 8|7|NJCT
	9|11|COM 10|11|SUBJ 11|8|POBJ 12|13|DET 13|11|OBJ 14|16|JCT 15|16|AUX
	16|11|COMP 17|19|DET 18|19|MOD 19|16|PRED 20|5|PUNCT
*S1:	or if you've got an array of floats (.) this would hafta be a float
	.
%mor:	coord|or conj|if pro:per|you~aux|have part|get&PASTP det:art|a
	n|array prep|of n|float-PL det:dem|this mod|will&COND
	mod|have~inf|to cop|be det:art|a n|float .
%gra:	1|14|LINK 2|5|LINK 3|5|SUBJ 4|5|AUX 5|14|CJCT 6|7|DET 7|5|OBJ 8|7|NJCT
	9|8|POBJ 10|14|SUBJ 11|14|AUX 12|14|AUX 13|14|INF 14|0|ROOT 15|16|DET
	16|14|PRED 17|14|PUNCT
*S1:	the indexes would still be ints [: integers] (.) because we know
	that array indexes actually hafta be ints [: integers] in c@l plus
	[/] plus .
%mor:	det:art|the n|index-PL mod|will&COND adv|still cop|be n|integer-PL
	conj|because pro:sub|we v|know det:dem|that n|array v|index-3S
	adv|actual&dadj-LY mod|have~inf|to cop|be n|integer-PL prep|in
	n:let|c adv|plus .
%gra:	1|2|DET 2|5|SUBJ 3|5|AUX 4|5|JCT 5|0|ROOT 6|5|PRED 7|9|LINK 8|9|SUBJ
	9|5|CJCT 10|11|DET 11|12|SUBJ 12|9|COMP 13|16|JCT 14|16|AUX 15|16|INF
	16|12|COMP 17|16|PRED 18|16|JCT 19|18|POBJ 20|19|JCT 21|5|PUNCT
*S1:	(o)kay so this last one is an int [: integer] because that's
	actually the base type of the array (.) and what we'll see is that
	we'll use this (.) when we make the exchange (be)cause we need &-uh
	actually an extra variable to make a swap .
%mor:	co|okay adv|so det:dem|this adj|last pro:indef|one cop|be&3S
	det:art|a n|integer conj|because pro:dem|that~cop|be&3S
	adv|actual&dadj-LY det:art|the adj|base n|type prep|of det:art|the
	n|array coord|and pro:int|what pro:sub|we~mod|will v|see cop|be&3S
	comp|that pro:sub|we~mod|will v|use det:dem|this conj|when
	pro:sub|we v|make det:art|the n|exchange conj|because pro:sub|we
	v|need adv|actual&dadj-LY det:art|a n|extra n|variable inf|to v|make
	det:art|a v|swap .
%gra:	1|5|COM 2|5|JCT 3|5|DET 4|5|MOD 5|6|SUBJ 6|0|ROOT 7|8|DET 8|6|PRED
	9|11|LINK 10|11|SUBJ 11|6|CJCT 12|11|JCT 13|15|DET 14|15|MOD 15|12|POBJ
	16|15|NJCT 17|18|DET 18|16|POBJ 19|15|CONJ 20|23|LINK 21|23|SUBJ 22|23|AUX
	23|19|COORD 24|23|COMP 25|28|LINK 26|28|SUBJ 27|28|AUX 28|24|CPRED
	29|32|DET 30|32|LINK 31|32|SUBJ 32|28|COMP 33|34|DET 34|32|OBJ 35|37|LINK
	36|37|SUBJ 37|11|CJCT 38|37|JCT 39|41|DET 40|41|MOD 41|38|POBJ 42|43|INF
	43|41|XMOD 44|45|DET 45|43|OBJ 46|6|PUNCT
*S1:	okay are there any questions so far about any [/] any of this ?
%mor:	co|okay aux|be&PRES adv|there qn|any n|question-PL adv|so adj|far
	prep|about qn|any prep|of pro:dem|this ?
%gra:	1|5|SUBJ 2|5|AUX 3|5|JCT 4|5|QUANT 5|0|INCROOT 6|7|JCT 7|5|PRED 8|7|JCT
	9|8|POBJ 10|9|NJCT 11|10|POBJ 12|5|PUNCT
*S1:	(0.4) yeah Meredith ?
%mor:	co|yeah n:prop|Meredith ?
%gra:	1|2|COM 2|0|INCROOT 3|2|PUNCT
*S2:	<you have> [/] you have at most N minus one &-um passes right ?
%mor:	pro:per|you v|have prep|at qn|most n:prop|N prep|minus det:num|one
	n|pass-PL co|right ?
%gra:	1|2|SUBJ 2|0|ROOT 3|2|JCT 4|5|QUANT 5|3|POBJ 6|2|JCT 7|8|QUANT 8|6|POBJ
	9|2|COM 10|2|PUNCT
*S1:	mhm +/.
%mor:	co|mhm=yes +/.
%gra:	1|0|INCROOT 2|1|PUNCT
*S2:	+, that's so that's just the maximum number you can have (.) less
	than that ?
%mor:	pro:dem|that~cop|be&3S conj|so pro:dem|that~cop|be&3S adv|just
	det:art|the n|maximum n|number pro:per|you mod|can v|have adj|less
	prep|than pro:dem|that ?
%gra:	1|2|SUBJ 2|0|ROOT 3|5|LINK 4|5|SUBJ 5|2|PRED 6|9|JCT 7|9|DET 8|9|MOD
	9|5|PRED 10|12|SUBJ 11|12|AUX 12|9|CMOD 13|12|JCT 14|13|JCT 15|14|POBJ
	16|2|PUNCT
*S1:	actually (.) that's a really good point the [/] the selection sort
	always does N minus one passes .
%mor:	adv|actual&dadj-LY pro:dem|that~cop|be&3S det:art|a
	adv|real&dadj-LY adj|good n|point det:art|the n|selection n|sort
	adv|always mod|do&3S n:prop|N prep|minus det:num|one n|pass-PL .
%gra:	1|3|JCT 2|3|SUBJ 3|0|ROOT 4|7|DET 5|6|JCT 6|7|MOD 7|3|PRED 8|10|DET
	9|10|MOD 10|7|OBJ 11|10|NJCT 12|13|AUX 13|11|POBJ 14|13|NJCT 15|16|QUANT
	16|14|POBJ 17|3|PUNCT
*S1:	even if doesn't need to .
%mor:	adv|even conj|if mod|do&3S~neg|not v|need inf|to .
%gra:	1|5|JCT 2|5|SUBJ 3|5|AUX 4|3|NEG 5|0|ROOT 6|5|OBJ 7|5|PUNCT
*S2:	even if (.) they're already in order ?
%mor:	adv|even conj|if pro:sub|they~cop|be&PRES adv|already prep|in
	n|order ?
%gra:	1|2|JCT 2|4|LINK 3|4|SUBJ 4|0|ROOT 5|4|JCT 6|4|JCT 7|6|POBJ 8|4|PUNCT
*S1:	yeah even if they're already in order .
%mor:	co|yeah v|even conj|if pro:sub|they~cop|be&PRES adv|already prep|in
	n|order .
%gra:	1|2|COM 2|0|ROOT 3|5|LINK 4|5|SUBJ 5|2|COMP 6|5|JCT 7|5|JCT 8|7|POBJ
	9|2|PUNCT
*S2:	it just doesn't &sw switch (th)em ?
%mor:	pro:per|it adv|just mod|do&3S~neg|not v|switch pro:obj|them ?
%gra:	1|5|SUBJ 2|5|JCT 3|5|AUX 4|3|NEG 5|0|ROOT 6|5|OBJ 7|5|PUNCT
*S1:	yeah it doesn't &-uh there's no way to exit this algorithm (.)
	because (.) the list is sorted .
%mor:	co|yeah pro:per|it mod|do&3S~neg|not pro:exist|there~cop|be&3S
	qn|no n|way inf|to v|exit det:dem|this n|algorithm conj|because
	det:art|the n|list aux|be&3S part|sort-PASTP .
%gra:	1|5|COM 2|5|SUBJ 3|5|AUX 4|3|NEG 5|6|SUBJ 6|0|ROOT 7|8|QUANT 8|6|PRED
	9|10|INF 10|8|XMOD 11|12|DET 12|10|OBJ 13|17|LINK 14|15|DET 15|17|SUBJ
	16|17|AUX 17|6|CJCT 18|6|PUNCT
*S1:	have you seen the bubble sort before ?
%mor:	aux|have pro:per|you part|see&PASTP det:art|the n|bubble n|sort
	adv|before ?
%gra:	1|3|AUX 2|3|SUBJ 3|0|ROOT 4|6|DET 5|6|MOD 6|3|OBJ 7|3|JCT 8|3|PUNCT
*S1:	perhaps (be)cause I'm wondering if maybe you're thinking (.) that
	one &-um that's a sort where (.) once the list is sorted actually
	you can exit (.) the algorithm .
%mor:	adv|perhaps conj|because pro:sub|I~aux|be&1S part|wonder-PRESP
	conj|if adv|maybe pro:per|you~aux|be&PRES part|think-PRESP comp|that
	det:num|one pro:dem|that~cop|be&3S det:art|a n|sort pro:rel|where
	adv|once det:art|the n|list aux|be&3S part|sort-PASTP
	adv|actual&dadj-LY pro:per|you mod|can v|exit det:art|the
	n|algorithm .
%gra:	1|5|JCT 2|5|LINK 3|5|SUBJ 4|5|AUX 5|0|ROOT 6|10|LINK 7|10|JCT 8|10|SUBJ
	9|10|AUX 10|5|CJCT 11|14|LINK 12|13|QUANT 13|14|SUBJ 14|10|COMP
	15|16|DET 16|26|SUBJ 17|22|LINK 18|22|JCT 19|20|DET 20|22|SUBJ 21|22|AUX
	22|26|XJCT 23|22|JCT 24|26|SUBJ 25|26|AUX 26|14|CPRED 27|28|DET 28|26|OBJ
	29|5|PUNCT
*S1:	&-uh oddly enough it's less efficient than this one which is why we
	cover this one in class .
%mor:	adv|odd&dadj-LY adv|enough pro:per|it~cop|be&3S adj|less
	adj|efficient prep|than det:dem|this pro:indef|one pro:rel|which
	cop|be&3S pro:int|why pro:sub|we v|cover det:dem|this pro:indef|one
	prep|in n|class .
%gra:	1|2|JCT 2|4|JCT 3|4|SUBJ 4|0|ROOT 5|6|MOD 6|4|PRED 7|4|JCT 8|9|DET
	9|7|POBJ 10|11|LINK 11|9|CMOD 12|14|LINK 13|14|SUBJ 14|11|CPRED 15|16|DET
	16|14|OBJ 17|16|NJCT 18|17|POBJ 19|4|PUNCT
*S1:	did anyone see that in high school or somewhere else (.) bubble
	sort ?
%mor:	v|do&PAST pro:indef|anyone co|see adv|that adv|in adj|high n|school
	coord|or adv|somewhere post|else n|bubble n|sort ?
%gra:	1|0|ROOT 2|1|OBJ 3|7|COM 4|5|JCT 5|6|JCT 6|7|MOD 7|1|JCT 8|7|CONJ
	9|10|JCT 10|12|MOD 11|12|MOD 12|8|COORD 13|1|PUNCT
*S1:	okay .
%mor:	co|okay .
%gra:	1|0|INCROOT 2|1|PUNCT
*S1:	oh Jim saw it very good .
%mor:	co|oh n:prop|Jim v|see&PAST pro:per|it adv|very adj|good .
%gra:	1|3|COM 2|3|SUBJ 3|0|ROOT 4|3|OBJ 5|6|JCT 6|3|JCT 7|3|PUNCT
*S1:	&=laughs &-uh I saw it .
%mor:	pro:sub|I v|see&PAST pro:per|it .
%gra:	1|2|SUBJ 2|0|ROOT 3|2|OBJ 4|2|PUNCT
*S1:	okay .
%mor:	co|okay .
%gra:	1|0|INCROOT 2|1|PUNCT
*S1:	well let's look at this algorithm (.) and +...
%mor:	co|well v|let~pro:obj|us v|look prep|at det:dem|this n|algorithm
	coord|and +...
%gra:	1|2|COM 2|0|ROOT 3|4|SUBJ 4|2|COMP 5|4|JCT 6|7|DET 7|5|POBJ 8|4|CONJ
	9|2|PUNCT
*S1:	related to your question (.) Meredith you can see that there's a
	for loop controlling this .
%mor:	v|relate-PAST prep|to det:poss|your n|question n:prop|Meredith
	pro:per|you mod|can v|see comp|that pro:exist|there~cop|be&3S
	det:art|a prep|for n|loop part|control-PRESP pro:dem|this .
%gra:	1|0|ROOT 2|1|JCT 3|4|DET 4|2|POBJ 5|8|SUBJ 6|8|SUBJ 7|8|AUX 8|1|CJCT
	9|11|LINK 10|11|SUBJ 11|8|COMP 12|15|DET 13|15|JCT 14|13|POBJ 15|11|PRED
	16|15|OBJ 17|1|PUNCT
*S1:	and what we know about for loops is that &-uh stylewise then should
	be used to just do straightforward counting &-uh this one counts
	from zero up through N minus two (.) and in our example case that
	would be zero through three (.) and then it stops .
%mor:	coord|and pro:int|what pro:sub|we v|know adv|about prep|for
	n|loop-PL cop|be&3S det:dem|that adj|style&dn-WISE adv:tem|then
	mod|should aux|be part|use-PASTP prep|to adj|just v|do
	adj|straightforward n:gerund|count-PRESP det:dem|this qn|one
	n|count-PL prep|from det:num|zero adv|up adj|through n:prop|N
	n|minus det:num|two coord|and prep|in det:poss|our ex#adj|ample
	n|case pro:rel|that mod|will&COND cop|be det:num|zero adj|through
	det:num|three coord|and adv:tem|then pro:per|it v|stop-3S .
%gra:	1|4|LINK 2|4|LINK 3|4|SUBJ 4|0|ROOT 5|4|JCT 6|4|JCT 7|6|POBJ 8|14|AUX
	9|14|DET 10|14|AUX 11|14|JCT 12|14|AUX 13|14|AUX 14|4|CJCT 15|14|JCT
	16|17|JCT 17|15|POBJ 18|19|MOD 19|17|COMP 20|22|DET 21|22|QUANT 22|19|OBJ
	23|22|NJCT 24|28|QUANT 25|24|JCT 26|28|MOD 27|28|MOD 28|23|POBJ
	29|30|QUANT 30|22|CONJ 31|30|COORD 32|33|DET 33|31|POBJ 34|33|OBJ 35|37|LINK
	36|37|AUX 37|34|CMOD 38|39|QUANT 39|37|PRED 40|43|QUANT 41|40|CONJ
	42|41|COORD 43|44|SUBJ 44|39|CMOD 45|4|PUNCT
*S1:	so the sort is totally controlled by a counter .
%mor:	co|so det:art|the n|sort aux|be&3S adv|total&dadj-LY
	part|control-PASTP prep|by det:art|a n|counter .
%gra:	1|6|COM 2|3|DET 3|6|SUBJ 4|6|AUX 5|6|JCT 6|0|ROOT 7|6|JCT 8|9|DET
	9|7|POBJ 10|6|PUNCT
*S1:	&-uh there are other sorts where &-uh you might have a flag that
	tells you (.) at some point that the list is actually sorted and now
	you can exit .
%mor:	pro:exist|there cop|be&PRES qn|other n|sort-PL pro:rel|where
	pro:per|you mod|might v|have det:art|a n|flag pro:rel|that v|tell-3S
	pro:per|you prep|at qn|some n|point pro:rel|that det:art|the n|list
	aux|be&3S adv|actual&dadj-LY part|sort-PASTP coord|and adv|now
	pro:per|you mod|can v|exit .
%gra:	1|2|SUBJ 2|0|ROOT 3|4|QUANT 4|2|PRED 5|8|LINK 6|8|SUBJ 7|8|AUX 8|4|CMOD
	9|10|DET 10|8|OBJ 11|12|LINK 12|10|CMOD 13|12|OBJ 14|12|JCT 15|16|QUANT
	16|14|POBJ 17|22|LINK 18|19|DET 19|22|SUBJ 20|22|AUX 21|22|JCT
	22|16|CMOD 23|22|CONJ 24|27|JCT 25|27|SUBJ 26|27|AUX 27|23|COORD 28|2|PUNCT
*S1:	but not with this one .
%mor:	conj|but neg|not prep|with det:dem|this pro:indef|one .
%gra:	1|0|INCROOT 2|1|NEG 3|1|JCT 4|5|DET 5|3|POBJ 6|1|PUNCT
*S1:	(o)kay so this is a very predictable methodical approach to sorting
	(.) values .
%mor:	co|okay co|so pro:dem|this cop|be&3S det:art|a adv|very
	adj|predict&dv-ABLE adj|methodical n|approach prep|to
	n:gerund|sort-PRESP n|value-PL .
%gra:	1|3|COM 2|3|COM 3|4|SUBJ 4|0|ROOT 5|9|DET 6|7|JCT 7|9|MOD 8|9|MOD
	9|4|PRED 10|9|NJCT 11|10|POBJ 12|11|OBJ 13|4|PUNCT
*S1:	alright now I should say rather than to totally denigrate this
	thing (.) I +//.
%mor:	co|alright adv|now pro:sub|I mod|should v|say adv|rather prep|than
	inf|to adv|total&dadj-LY v|denigrate det:dem|this n|thing pro:sub|I
	+//.
%gra:	1|2|COM 2|5|JCT 3|5|SUBJ 4|5|AUX 5|0|ROOT 6|5|JCT 7|5|JCT 8|10|INF
	9|10|JCT 10|7|CPOBJ 11|12|DET 12|10|OBJ 13|12|OM 14|5|PUNCT
*S1:	for small (.) lists this is perfectly fine (.) and when you run
	this (.) say for program six (.) it's a [/] a very reasonable sort .
%mor:	prep|for adj|small n|list-PL pro:dem|this cop|be&3S
	adv|perfect&dadj-LY adv|fine coord|and conj|when pro:per|you v|run
	pro:dem|this v|say prep|for n|program det:num|six
	pro:per|it~cop|be&3S det:art|a adv|very adj|reason&dv-ABLE n|sort .
%gra:	1|5|JCT 2|3|MOD 3|1|POBJ 4|5|SUBJ 5|0|ROOT 6|7|JCT 7|5|PRED 8|13|LINK
	9|11|LINK 10|11|SUBJ 11|13|CJCT 12|13|SUBJ 13|7|CJCT 14|13|JCT 15|14|POBJ
	16|17|QUANT 17|18|SUBJ 18|15|CMOD 19|22|DET 20|21|JCT 21|22|MOD
	22|18|PRED 23|5|PUNCT
*S1:	it's not &-uh such a terrible inefficient routine that we'd never
	use it .
%mor:	pro:per|it~cop|be&3S neg|not qn|such det:art|a adj|terrible
	in#adj|efficient adj|routine comp|that pro:sub|we~mod|genmod
	adv|never v|use pro:per|it .
%gra:	1|2|SUBJ 2|0|ROOT 3|2|NEG 4|7|QUANT 5|7|DET 6|7|MOD 7|2|PRED 8|7|PRED
	9|13|LINK 10|13|SUBJ 11|13|AUX 12|13|JCT 13|8|CMOD 14|13|OBJ 15|2|PUNCT
*S1:	for small N just like the linear search it's really pretty decent .
%mor:	prep|for adj|small n:prop|N adv|just prep|like det:art|the
	adj|linear n|search pro:per|it~cop|be&3S adv|real&dadj-LY adv|pretty
	adj|decent .
%gra:	1|10|JCT 2|3|MOD 3|1|POBJ 4|5|JCT 5|10|JCT 6|8|DET 7|8|MOD 8|5|POBJ
	9|10|SUBJ 10|0|ROOT 11|12|JCT 12|13|JCT 13|10|PRED 14|10|PUNCT
*S1:	(o)kay well with that in mind let's take a look at the code &-uh
	the for loop that controls (.) one pass basically one execution of
	the for loop is one pass .
%mor:	co|okay co|well prep|with pro:dem|that prep|in n|mind
	v|let~pro:obj|us v|take det:art|a v|look prep|at det:art|the n|code
	det:art|the prep|for n|loop pro:rel|that v|control-3S det:num|one
	n|pass adv|basic&dadj-AL-LY det:num|one n|execute&dv-TION prep|of
	det:art|the prep|for n|loop cop|be&3S det:num|one n|pass .
%gra:	1|7|COM 2|7|COM 3|7|LINK 4|7|SUBJ 5|7|JCT 6|5|POBJ 7|0|ROOT 8|7|OBJ
	9|7|COMP 10|11|DET 11|9|OBJ 12|11|JCT 13|14|DET 14|12|POBJ 15|16|DET
	16|12|POBJ 17|16|POBJ 18|19|LINK 19|17|CMOD 20|21|QUANT 21|19|OBJ 22|23|JCT
	23|24|QUANT 24|21|OBJ 25|24|NJCT 26|29|DET 27|29|JCT 28|27|POBJ 29|25|POBJ
	30|31|QUANT 31|29|PRED 32|7|PUNCT
*S1:	and we know we've got four passes for that little array we just
	looked at (.) we start off with start equals zero (.) that's the
	first (.) array element (.) and then (.) what we do with small is
	just like what we did before with maximum and [/] and minimum (.) we
	set small to the first value .
%mor:	coord|and pro:sub|we v|know pro:sub|we~aux|have part|get&PASTP
	det:num|four n|pass-PL prep|for det:dem|that adj|little n|array
	pro:sub|we adv|just v|look-PAST prep|at pro:sub|we v|start adv|off
	prep|with v|start n|equal-PL v|zero pro:dem|that~cop|be&3S
	det:art|the adj|first n|array n|element coord|and adv:tem|then
	pro:int|what pro:sub|we v|do prep|with adj|small aux|be&3S adv|just
	prep|like pro:int|what pro:sub|we v|do&PAST adv|before prep|with
	n|maximum coord|and adj|minimum pro:sub|we v|set&ZERO adj|small
	prep|to det:art|the adj|first n|value .
%gra:	1|3|LINK 2|3|SUBJ 3|0|ROOT 4|6|SUBJ 5|6|AUX 6|3|COMP 7|8|QUANT 8|6|OBJ
	9|8|NJCT 10|12|DET 11|12|MOD 12|9|POBJ 13|15|SUBJ 14|15|JCT 15|3|COMP
	16|18|JCT 17|18|SUBJ 18|15|CJCT 19|18|JCT 20|18|JCT 21|20|POBJ 22|23|SUBJ
	23|21|COMP 24|25|SUBJ 25|23|COMP 26|29|DET 27|28|MOD 28|29|MOD
	29|25|PRED 30|29|CONJ 31|30|COORD 32|34|LINK 33|34|SUBJ 34|31|COBJ 35|49|JCT
	36|49|SUBJ 37|49|AUX 38|39|JCT 39|37|JCT 40|42|LINK 41|42|SUBJ 42|39|CPOBJ
	43|42|JCT 44|42|JCT 45|44|POBJ 46|45|CONJ 47|46|COORD 48|49|SUBJ
	49|34|CJCT 50|49|PRED 51|50|JCT 52|54|DET 53|54|MOD 54|51|POBJ 55|3|PUNCT
*S1:	Jim did you have some .
%mor:	n:prop|Jim mod|do&PAST pro:per|you v|have qn|some .
%gra:	1|4|SUBJ 2|4|AUX 3|4|SUBJ 4|0|ROOT 5|4|OBJ 6|4|PUNCT
*S3:	should that be N minus two in the (.) header ?
%mor:	mod|should pro:dem|that cop|be n:prop|N prep|minus det:num|two
	prep|in det:art|the n|header ?
%gra:	1|3|AUX 2|3|SUBJ 3|0|ROOT 4|3|PRED 5|4|NJCT 6|5|POBJ 7|6|JCT 8|9|DET
	9|7|POBJ 10|3|PUNCT
*S1:	no because it's less than .
%mor:	co|no conj|because pro:per|it~cop|be&3S adj|less prep|than .
%gra:	1|4|COM 2|4|LINK 3|4|SUBJ 4|0|ROOT 5|4|PRED 6|4|JCT 7|4|PUNCT
*S1:	good question Jim (.) you're totally &wr &=laughs you're totally
	wrong but that's a good question .
%mor:	adj|good n|question n:prop|Jim pro:per|you~cop|be&PRES
	adv|total&dadj-LY pro:per|you~cop|be&PRES adv|total&dadj-LY n|wrong
	conj|but pro:rel|that~cop|be&3S det:art|a adj|good n|question .
%gra:	1|2|MOD 2|0|INCROOT 3|5|COM 4|5|SUBJ 5|2|CMOD 6|8|JCT 7|8|SUBJ 8|5|PRED
	9|8|JCT 10|9|POBJ 11|10|CONJ 12|13|LINK 13|11|COORD 14|16|DET 15|16|MOD
	16|13|PRED 17|2|PUNCT
*S1:	&=laughs:multiple &-uh Jim asked should this be N minus two and the
	answer in no because &-uh if we had less than or equal to we could
	use N minus two (.) but (.) I tried to make this consistent with our
	other array (.) accessing and put less than .
%mor:	n:prop|Jim v|ask-PAST mod|should pro:dem|this cop|be n:prop|N
	prep|minus det:num|two coord|and det:art|the n|answer prep|in co|no
	conj|because conj|if pro:sub|we v|have&PAST adj|less prep|than
	coord|or n|equal inf|to pro:sub|we mod|could v|use n:prop|N
	prep|minus det:num|two conj|but pro:sub|I v|try-PAST inf|to v|make
	det:dem|this adj|consistent prep|with det:poss|our qn|other n|array
	part|access-PRESP coord|and v|put&ZERO adj|less prep|than .
%gra:	1|2|SUBJ 2|0|ROOT 3|5|AUX 4|5|SUBJ 5|2|COMP 6|5|PRED 7|6|NJCT 8|7|POBJ
	9|8|CONJ 10|11|DET 11|9|COORD 12|11|NJCT 13|12|POBJ 14|5|JCT 15|17|LINK
	16|17|SUBJ 17|14|CPOBJ 18|17|PRED 19|18|JCT 20|19|CONJ 21|20|COORD
	22|25|INF 23|25|SUBJ 24|25|AUX 25|21|XMOD 26|25|OBJ 27|25|JCT 28|27|POBJ
	29|31|LINK 30|31|SUBJ 31|19|CJCT 32|33|INF 33|31|COMP 34|40|AUX 35|40|MOD
	36|35|JCT 37|39|DET 38|39|QUANT 39|36|POBJ 40|33|CJCT 41|33|CONJ
	42|41|COORD 43|42|PRED 44|43|JCT 45|2|PUNCT
*S1:	and that means that we'd use N minus one (.) and then the loop will
	range from zero to (.) N minus two .
%mor:	coord|and pro:dem|that v|mean-3S comp|that pro:sub|we~mod|genmod
	v|use n:prop|N prep|minus det:num|one coord|and adv:tem|then
	det:art|the n|loop mod|will v|range prep|from det:num|zero prep|to
	n:prop|N prep|minus det:num|two .
%gra:	1|3|LINK 2|3|SUBJ 3|0|ROOT 4|7|LINK 5|7|SUBJ 6|7|AUX 7|3|COMP 8|7|OBJ
	9|7|JCT 10|9|POBJ 11|16|LINK 12|16|JCT 13|14|DET 14|16|SUBJ 15|16|AUX
	16|10|CJCT 17|16|JCT 18|17|POBJ 19|18|NJCT 20|19|POBJ 21|18|NJCT 22|21|POBJ
	23|3|PUNCT
*S1:	so good point actually that's a good review of &-uh array indexing
	(.) for us .
%mor:	adv|so adj|good n|point adv|actual&dadj-LY pro:dem|that~cop|be&3S
	det:art|a adj|good n|review prep|of n|array part|index-PRESP
	prep|for pro:obj|us .
%gra:	1|2|JCT 2|3|MOD 3|6|SUBJ 4|6|JCT 5|6|SUBJ 6|0|ROOT 7|9|DET 8|9|MOD
	9|6|PRED 10|9|NJCT 11|10|POBJ 12|9|XMOD 13|12|JCT 14|13|POBJ 15|6|PUNCT
*S1:	so +//.
%mor:	co|so +//.
%gra:	1|0|INCROOT 2|1|PUNCT
*S1:	and again the reason I did that was to make it consistent with all
	of our (.) other loops where we went from zero up to something and
	we always said less than (.) and then (.) say the size of the array
	.
%mor:	coord|and adv|again det:art|the n|reason pro:sub|I v|do&PAST
	pro:dem|that cop|be&PAST&13S inf|to v|make pro:per|it adj|consistent
	prep|with pro:indef|all prep|of det:poss|our qn|other n|loop-PL
	pro:rel|where pro:sub|we v|go&PAST prep|from det:num|zero adv|up
	prep|to pro:indef|something coord|and pro:sub|we adv|always
	v|say&PAST adj|less prep|than coord|and adv:tem|then v|say
	det:art|the n|size prep|of det:art|the n|array .
%gra:	1|6|LINK 2|1|JCT 3|4|DET 4|2|POBJ 5|6|SUBJ 6|0|ROOT 7|8|SUBJ 8|6|COMP
	9|10|INF 10|8|COMP 11|10|OBJ 12|10|JCT 13|12|JCT 14|13|POBJ 15|14|NJCT
	16|18|DET 17|18|QUANT 18|15|POBJ 19|21|LINK 20|21|SUBJ 21|18|CMOD
	22|21|JCT 23|22|POBJ 24|23|JCT 25|23|JCT 26|25|POBJ 27|30|LINK 28|30|SUBJ
	29|30|JCT 30|23|CJCT 31|30|PRED 32|31|JCT 33|35|LINK 34|35|JCT 35|32|CPOBJ
	36|37|DET 37|35|OBJ 38|37|NJCT 39|40|DET 40|38|POBJ 41|6|PUNCT
*S1:	okay .
%mor:	co|okay .
%gra:	1|0|INCROOT 2|1|PUNCT
*S1:	well we initialize small to the (.) starting value (.) and (.)
	again we're storing the index of the starting value we're not really
	(.) storing the value itself .
%mor:	co|well pro:sub|we v|initial&dadj-IZE adj|small prep|to det:art|the
	part|start-PRESP n|value coord|and adv|again pro:sub|we~aux|be&PRES
	part|store-PRESP det:art|the n|index prep|of det:art|the
	part|start-PRESP n|value pro:sub|we~aux|be&PRES neg|not
	adv|real&dadj-LY part|store-PRESP det:art|the n|value
	pro:refl|itself .
%gra:	1|3|COM 2|3|SUBJ 3|0|ROOT 4|13|JCT 5|4|JCT 6|8|DET 7|8|MOD 8|5|POBJ
	9|4|CONJ 10|9|COORD 11|13|SUBJ 12|13|AUX 13|3|COMP 14|15|DET 15|13|OBJ
	16|15|NJCT 17|19|DET 18|19|MOD 19|16|POBJ 20|24|SUBJ 21|24|AUX 22|21|NEG
	23|24|JCT 24|3|COMP 25|26|DET 26|24|OBJ 27|26|POSTMOD 28|3|PUNCT
*S1:	the value's in the array so we have that (.) but we're using the
	index to keep track (.) of where the smallest item is .
%mor:	det:art|the n|value~cop|be&3S prep|in det:art|the n|array adv|so
	pro:sub|we v|have adv|that conj|but pro:sub|we~aux|be&PRES
	part|use-PRESP det:art|the n|index inf|to v|keep n|track prep|of
	pro:int|where det:art|the adj|small-SP n|item cop|be&3S .
%gra:	1|2|DET 2|3|SUBJ 3|0|ROOT 4|3|JCT 5|6|DET 6|4|POBJ 7|9|JCT 8|9|SUBJ
	9|3|CJCT 10|9|JCT 11|14|LINK 12|14|SUBJ 13|14|AUX 14|9|CJCT 15|16|DET
	16|14|OBJ 17|18|INF 18|14|XJCT 19|18|OBJ 20|19|JCT 21|25|LINK 22|24|DET
	23|24|MOD 24|25|SUBJ 25|20|CPOBJ 26|3|PUNCT
*S1:	now this next loop very short for loop &-uh that's where the (.)
	search for the smallest item takes place .
%mor:	adv|now pro:dem|this adj|next n|loop adv|very adj|short prep|for
	n|loop pro:rel|that~cop|be&3S pro:int|where det:art|the n|search
	prep|for det:art|the adj|small-SP n|item v|take-3S n|place .
%gra:	1|2|JCT 2|0|INCROOT 3|4|MOD 4|2|PRED 5|6|JCT 6|4|POSTMOD 7|6|JCT
	8|7|POBJ 9|10|LINK 10|8|CMOD 11|10|PRED 12|13|DET 13|11|OBJ 14|18|LINK
	15|17|DET 16|17|MOD 17|18|SUBJ 18|13|CMOD 19|18|OBJ 20|2|PUNCT
*S1:	and we don't need much code to do this (.) okay in this one current
	is the index (.) and (.) remember current goes from start plus one
	(.) so the element after (.) the starting element (.) for this
	particular pass (.) and then it ranges up through (.) N minus one
	(.) and we know N minus one is the very last (.) array element .
%mor:	coord|and pro:sub|we mod|do~neg|not v|need adv|much n|code inf|to
	v|do pro:dem|this adj|okay prep|in det:dem|this pro:indef|one
	adj|current cop|be&3S det:art|the n|index coord|and v|remember
	adj|current v|go-3S prep|from v|start adv|plus det:num|one co|so
	det:art|the n|element prep|after det:art|the part|start-PRESP
	n|element prep|for det:dem|this adj|particular n|pass coord|and
	adv:tem|then pro:per|it v|range-3S adv|up adj|through n:prop|N
	n|minus det:num|one coord|and pro:sub|we v|know n:prop|N n|minus
	pro:indef|one cop|be&3S det:art|the adv|very adj|last n|array
	n|element .
%gra:	1|5|LINK 2|5|SUBJ 3|5|AUX 4|3|NEG 5|0|ROOT 6|7|JCT 7|5|OBJ 8|9|INF
	9|7|XMOD 10|11|SUBJ 11|16|JCT 12|11|JCT 13|14|DET 14|12|POBJ 15|16|SUBJ
	16|9|COMP 17|18|DET 18|16|PRED 19|18|CONJ 20|19|COORD 21|22|MOD 22|18|CMOD
	23|24|JCT 24|22|COMP 25|26|JCT 26|29|QUANT 27|29|COM 28|29|DET 29|24|OBJ
	30|29|NJCT 31|33|DET 32|33|MOD 33|30|POBJ 34|29|NJCT 35|37|DET 36|37|MOD
	37|34|POBJ 38|24|CONJ 39|41|JCT 40|41|SUBJ 41|38|COORD 42|41|JCT
	43|45|MOD 44|45|MOD 45|41|OBJ 46|53|SUBJ 47|49|LINK 48|49|SUBJ 49|53|JCT
	50|51|MOD 51|49|OBJ 52|53|SUBJ 53|45|CMOD 54|58|DET 55|56|JCT 56|58|MOD
	57|58|MOD 58|53|PRED 59|5|PUNCT
*S1:	so for this one we're gonna start at the element right after the
	[/] the starting point element and go all the way to the end of the
	array (.) and we'll look at each one (.) at each point we'd say okay
	is (.) a@l sub current (.) the one I'm currently looking at (.) is
	that less than a@l sub small ?
%mor:	co|so prep|for det:dem|this pro:indef|one pro:sub|we~aux|be&PRES
	part|go-PRESP~inf|to v|start prep|at det:art|the n|element adj|right
	prep|after det:art|the part|start-PRESP n|point n|element coord|and
	v|go adv|all det:art|the n|way prep|to det:art|the n|end prep|of
	det:art|the n|array coord|and pro:sub|we~mod|will v|look prep|at
	qn|each det:num|one prep|at qn|each n|point pro:sub|we~mod|genmod
	v|say adj|okay aux|be&3S n:let|a v|sub adj|current det:art|the
	pro:indef|one pro:sub|I~aux|be&1S adv|current&dadj-LY
	part|look-PRESP prep|at cop|be&3S det:dem|that adj|less prep|than
	n:let|a n|sub adj|small ?
%gra:	1|7|COM 2|1|JCT 3|4|DET 4|2|POBJ 5|7|SUBJ 6|7|AUX 7|0|ROOT 8|9|INF
	9|7|COMP 10|33|JCT 11|12|DET 12|10|POBJ 13|33|JCT 14|13|JCT 15|18|DET
	16|17|XMOD 17|18|MOD 18|14|POBJ 19|13|CONJ 20|19|COORD 21|23|JCT 22|23|DET
	23|20|OBJ 24|23|NJCT 25|26|DET 26|24|POBJ 27|26|NJCT 28|29|DET 29|27|POBJ
	30|33|LINK 31|33|SUBJ 32|33|AUX 33|42|CJCT 34|33|JCT 35|36|QUANT
	36|34|POBJ 37|36|NJCT 38|39|QUANT 39|37|POBJ 40|42|SUBJ 41|42|AUX 42|9|COMP
	43|46|SUBJ 44|46|AUX 45|46|SUBJ 46|42|COMP 47|46|PRED 48|49|DET 49|47|CMOD
	50|53|SUBJ 51|53|AUX 52|53|JCT 53|49|CMOD 54|53|JCT 55|54|POBJ 56|57|DET
	57|53|JCT 58|53|JCT 59|60|DET 60|58|POBJ 61|60|POSTMOD 62|7|PUNCT
*S1:	where small is where we save the index of the currently (.)
	smallest item the one we think is the [/] the smallest .
%mor:	pro:int|where adj|small aux|be&3S pro:int|where pro:sub|we v|save
	det:art|the n|index prep|of det:art|the adv|current&dadj-LY
	adj|small-SP n|item det:art|the pro:indef|one pro:sub|we v|think
	aux|be&3S det:art|the adj|small-SP .
%gra:	1|6|LINK 2|6|SUBJ 3|6|AUX 4|6|LINK 5|6|SUBJ 6|0|ROOT 7|8|DET 8|6|OBJ
	9|8|NJCT 10|13|DET 11|12|JCT 12|13|MOD 13|9|POBJ 14|15|DET 15|18|SUBJ
	16|17|SUBJ 17|15|CMOD 18|6|CJCT 19|20|DET 20|18|PRED 21|6|PUNCT
*S1:	now if it is we replace (.) small (.) with current .
%mor:	adv|now conj|if pro:per|it cop|be&3S pro:sub|we re#n|place
	adj|small prep|with n|current .
%gra:	1|0|INCROOT 2|4|LINK 3|4|SUBJ 4|1|CPOBJ 5|4|PRED 6|5|PQ 7|6|POSTMOD
	8|7|JCT 9|8|POBJ 10|1|PUNCT
*S1:	so (.) going back to when we found a minimum in a data set &-uh
	we'd basically say something if this is a new low (.) then replace
	(.) low with (.) whatever the current value is .
%mor:	adv|so part|go-PRESP adv|back prep|to pro:int|when pro:sub|we
	v|find&PAST det:art|a n|minimum prep|in det:art|a n|data v|set&ZERO
	pro:sub|we~mod|genmod adv|basic&dadj-AL-LY v|say pro:indef|something
	conj|if pro:dem|this cop|be&3S det:art|a adj|new adj|low
	adv:tem|then re#n|place n|low prep|with pro:int|whatever det:art|the
	n|current n|value cop|be&3S .
%gra:	1|2|JCT 2|0|ROOT 3|2|JCT 4|2|JCT 5|7|LINK 6|7|SUBJ 7|4|CPOBJ 8|9|DET
	9|7|OBJ 10|9|NJCT 11|12|DET 12|10|POBJ 13|10|ENUM 14|17|SUBJ 15|17|AUX
	16|17|JCT 17|13|COMP 18|17|OBJ 19|21|LINK 20|21|SUBJ 21|10|POBJ 22|24|DET
	23|24|MOD 24|21|PRED 25|24|CONJ 26|25|COORD 27|26|OBJ 28|27|JCT
	29|33|LINK 30|32|DET 31|32|MOD 32|33|SUBJ 33|28|CPOBJ 34|2|PUNCT
*S1:	and the same thing's happening here except this is an array index
	and so is this one .
%mor:	coord|and det:art|the adj|same n|thing~aux|be&3S part|happen-PRESP
	adv|here prep|except pro:dem|this cop|be&3S det:art|a n|array
	n|index coord|and adv|so cop|be&3S det:dem|this pro:indef|one .
%gra:	1|6|LINK 2|4|DET 3|4|MOD 4|6|SUBJ 5|6|AUX 6|0|ROOT 7|6|JCT 8|10|JCT
	9|10|SUBJ 10|6|CJCT 11|13|DET 12|13|MOD 13|10|PRED 14|16|LINK 15|16|JCT
	16|13|CMOD 17|18|DET 18|16|PRED 19|6|PUNCT
*S1:	but they represent the values that we're looking at in the array .
%mor:	conj|but pro:sub|they v|represent det:art|the n|value-PL comp|that
	pro:sub|we~aux|be&PRES part|look-PRESP prep|at prep|in det:art|the
	n|array .
%gra:	1|3|LINK 2|3|SUBJ 3|0|ROOT 4|5|DET 5|3|OBJ 6|9|LINK 7|9|SUBJ 8|9|AUX
	9|5|CMOD 10|9|JCT 11|10|JCT 12|13|DET 13|11|POBJ 14|3|PUNCT
*S1:	now when we exit this loop (.) small would have the index (.) to
	the smallest item that is in the unsorted part .
%mor:	adv|now conj|when pro:sub|we v|exit det:dem|this n|loop adj|small
	mod|will&COND v|have det:art|the n|index prep|to det:art|the
	adj|small-SP n|item pro:rel|that aux|be&3S prep|in det:art|the
	un#part|sort-PASTP n|part .
%gra:	1|9|JCT 2|4|LINK 3|4|SUBJ 4|9|CJCT 5|6|DET 6|4|OBJ 7|9|SUBJ 8|9|AUX
	9|0|ROOT 10|11|DET 11|9|OBJ 12|9|JCT 13|15|DET 14|15|MOD 15|12|POBJ
	16|15|NJCT 17|16|INCROOT 18|17|JCT 19|21|DET 20|21|MOD 21|18|POBJ 22|17|PUNCT
*S1:	and that means we're all set to do the last phase here +...
%mor:	coord|and pro:dem|that v|mean-3S pro:sub|we~cop|be&PRES post|all
	n|set inf|to v|do det:art|the adj|last n|phase adv|here +...
%gra:	1|3|LINK 2|3|SUBJ 3|0|ROOT 4|5|SUBJ 5|3|COMP 6|5|PRED 7|6|OM 8|9|INF
	9|7|XMOD 10|12|DET 11|12|MOD 12|9|OBJ 13|9|JCT 14|3|PUNCT
*S1:	(o)kay so the last part of the pass (.) and that is to actually
	make the &-uh exchange itself .
%mor:	co|okay conj|so det:art|the n|last n|part prep|of det:art|the
	n|pass coord|and pro:dem|that cop|be&3S inf|to adv|actual&dadj-LY
	v|make det:art|the n|exchange pro:refl|itself .
%gra:	1|11|COM 2|11|LINK 3|5|DET 4|5|MOD 5|11|SUBJ 6|5|NJCT 7|8|DET 8|6|POBJ
	9|5|CONJ 10|9|COORD 11|0|ROOT 12|14|INF 13|14|JCT 14|11|COMP 15|16|DET
	16|14|OBJ 17|16|POSTMOD 18|11|PUNCT
*S1:	now (.) two words are used for this one is exchange and the other
	is swap and you hear both of those &-uh quite frequently (.) the
	idea with this one is that first of all we check to see (.) if the
	starting point element is the smallest .
%mor:	adv|now det:num|two n|word-PL aux|be&PRES part|use-PASTP prep|for
	det:dem|this pro:indef|one cop|be&3S v|exchange coord|and
	det:art|the qn|other aux|be&3S v|swap coord|and pro:per|you v|hear
	qn|both prep|of pro:dem|those adv|quite adv|frequent&dadj-LY
	det:art|the n|idea prep|with det:dem|this pro:indef|one cop|be&3S
	pro:dem|that adv|first prep|of pro:indef|all pro:sub|we v|check
	inf|to v|see comp|if det:art|the part|start-PRESP n|point n|element
	cop|be&3S det:art|the adj|small-SP .
%gra:	1|5|JCT 2|3|QUANT 3|5|SUBJ 4|5|AUX 5|10|SUBJ 6|5|JCT 7|8|DET 8|6|POBJ
	9|10|AUX 10|0|ROOT 11|15|LINK 12|13|DET 13|15|SUBJ 14|15|AUX 15|10|CJCT
	16|18|LINK 17|18|SUBJ 18|15|CJCT 19|35|QUANT 20|29|JCT 21|20|POBJ
	22|23|JCT 23|29|JCT 24|25|DET 25|29|SUBJ 26|25|NJCT 27|28|DET 28|26|POBJ
	29|35|CJCT 30|35|SUBJ 31|35|JCT 32|31|JCT 33|32|POBJ 34|35|SUBJ 35|18|COMP
	36|37|INF 37|35|COMP 38|43|LINK 39|42|DET 40|41|XMOD 41|42|MOD 42|43|SUBJ
	43|37|COMP 44|45|DET 45|43|PRED 46|10|PUNCT
*S1:	because (.) if that is the smallest we don't need to make an
	exchange and we really oughta skip this (.) three line sequence here
	that does the actual swap .
%mor:	conj|because conj|if pro:dem|that cop|be&3S det:art|the
	adj|small-SP pro:sub|we mod|do~neg|not v|need inf|to v|make
	det:art|a n|exchange coord|and pro:sub|we adv|real&dadj-LY
	mod|ought~inf|to v|skip det:dem|this det:num|three n|line n|sequence
	adv|here pro:rel|that v|do&3S det:art|the adj|actual v|swap .
%gra:	1|4|LINK 2|4|LINK 3|4|SUBJ 4|10|CJCT 5|6|DET 6|4|PRED 7|10|SUBJ
	8|10|AUX 9|8|NEG 10|0|ROOT 11|12|INF 12|10|COMP 13|14|DET 14|12|OBJ 15|20|LINK
	16|20|SUBJ 17|20|JCT 18|20|AUX 19|20|INF 20|10|CJCT 21|24|DET
	22|23|QUANT 23|24|MOD 24|20|OBJ 25|20|JCT 26|27|LINK 27|25|CMOD 28|30|DET
	29|30|MOD 30|27|OBJ 31|10|PUNCT
*S1:	so (.) first of all we'll check if small@q is not equal to start@q
	.
%mor:	adv|so adj|first prep|of qn|all pro:sub|we~mod|will n|check comp|if
	meta|small aux|be&3S neg|not n|equal inf|to meta|start .
%gra:	1|2|JCT 2|0|INCROOT 3|2|JCT 4|7|QUANT 5|7|SUBJ 6|7|AUX 7|3|POBJ
	8|12|LINK 9|12|SUBJ 10|12|AUX 11|10|NEG 12|7|CMOD 13|14|INF 14|12|XMOD
	15|2|PUNCT
*S1:	and again the reason for that is that &-uh the item that I'm trying
	to sort might actually already be in the right spot .
%mor:	coord|and adv|again det:art|the n|reason prep|for pro:dem|that
	cop|be&3S comp|that det:art|the n|item pro:rel|that
	pro:sub|I~aux|be&1S part|try-PRESP prep|to n|sort n|might
	adv|actual&dadj-LY adv|already cop|be prep|in det:art|the adj|right
	n|spot .
%gra:	1|4|LINK 2|4|JCT 3|4|DET 4|7|SUBJ 5|4|NJCT 6|5|POBJ 7|0|ROOT 8|7|PRED
	9|10|DET 10|8|OBJ 11|14|LINK 12|14|SUBJ 13|14|AUX 14|10|CMOD 15|14|JCT
	16|17|MOD 17|15|POBJ 18|20|JCT 19|20|JCT 20|14|COMP 21|20|JCT 22|24|DET
	23|24|MOD 24|21|POBJ 25|7|PUNCT
*S1:	mkay let's say it isn't though (.) and small is different from
	start &-uh that would've occurred (.) with (.) every single instance
	of small in our example that we did with the five (.) array elements
	(.) that means we do need to do an exchange (.) and a swap or an
	exchange always takes three lines .
%mor:	co|mkay v|let~pro:obj|us v|say pro:per|it cop|be&3S~neg|not
	adv|though coord|and adj|small aux|be&3S adj|different prep|from
	v|start comp|that mod|will&COND~aux|have v|occur-PAST prep|with
	qn|every adj|single n|instance prep|of adj|small prep|in
	det:poss|our ex#adj|ample comp|that pro:sub|we mod|do&PAST prep|with
	det:art|the det:num|five n|array n|element-PL pro:rel|that v|mean-3S
	pro:sub|we v|do v|need inf|to v|do det:art|a n|exchange coord|and
	det:art|a v|swap coord|or det:art|a n|exchange adv|always v|take-3S
	det:num|three n|line-PL .
%gra:	1|2|COM 2|0|ROOT 3|2|OBJ 4|2|COMP 5|6|SUBJ 6|2|ROOT 7|6|NEG 8|6|JCT
	9|12|LINK 10|12|SUBJ 11|12|AUX 12|8|ROOT 13|14|JCT 14|12|ROOT 15|18|LINK
	16|18|AUX 17|18|AUX 18|14|COMP 19|18|JCT 20|22|QUANT 21|22|MOD 22|19|POBJ
	23|22|NJCT 24|23|POBJ 25|24|JCT 26|27|DET 27|25|POBJ 28|24|INCROOT
	29|28|ROOT 30|29|INCROOT 31|30|JCT 32|35|DET 33|34|QUANT 34|35|MOD 35|31|POBJ
	36|37|LINK 37|35|CMOD 38|39|SUBJ 39|37|COMP 40|39|OBJ 41|42|INF
	42|40|COMP 43|44|DET 44|42|OBJ 45|40|CONJ 46|47|DET 47|45|COORD 48|52|LINK
	49|50|DET 50|52|SUBJ 51|52|JCT 52|47|COMP 53|54|QUANT 54|52|OBJ 55|30|PUNCT
*S1:	this is a very &-uh predictable process &-uh three lines always the
	same that you can plug into any program whenever you need to do (.)
	a swap like this .
%mor:	pro:dem|this cop|be&3S det:art|a adv|very adj|predict&dv-ABLE
	n|process det:num|three n|line-PL adv|always det:art|the adj|same
	comp|that pro:per|you mod|can v|plug prep|into qn|any n|program
	conj|whenever pro:per|you v|need inf|to v|do det:art|a v|swap
	prep|like pro:dem|this .
%gra:	1|2|SUBJ 2|0|ROOT 3|6|DET 4|5|JCT 5|6|MOD 6|8|MOD 7|8|QUANT 8|2|PRED
	9|8|NJCT 10|11|DET 11|9|POBJ 12|15|LINK 13|15|SUBJ 14|15|AUX 15|11|CMOD
	16|15|JCT 17|18|QUANT 18|16|POBJ 19|21|LINK 20|21|SUBJ 21|2|CJCT 22|23|INF
	23|21|COMP 24|25|DET 25|23|COMP 26|25|JCT 27|26|POBJ 28|2|PUNCT
*S1:	so first of all we'll take (.) the starting point element and store
	that in temp .
%mor:	adv|so adj|first prep|of qn|all pro:sub|we~mod|will v|take
	det:art|the part|start-PRESP n|point n|element coord|and v|store
	pro:dem|that prep|in n|temp .
%gra:	1|2|JCT 2|0|INCROOT 3|2|JCT 4|7|QUANT 5|7|SUBJ 6|7|AUX 7|3|CPOBJ
	8|11|DET 9|10|XMOD 10|11|MOD 11|7|OBJ 12|2|CONJ 13|12|COORD 14|2|ENUM
	15|14|JCT 16|15|POBJ 17|2|PUNCT
*S1:	and remember temp we need (.) to (.) essentially hold one of the
	values so that we can do the exchange .
%mor:	coord|and v|remember n|temp pro:sub|we v|need inf|to
	adj|essential&dn-LY n|hold pro:indef|one prep|of det:art|the
	n|value-PL conj|so comp|that pro:sub|we mod|can v|do det:art|the
	n|exchange .
%gra:	1|2|LINK 2|0|ROOT 3|2|OBJ 4|5|SUBJ 5|3|CMOD 6|7|INF 7|9|MOD 8|9|MOD
	9|5|OBJ 10|9|NJCT 11|12|DET 12|10|POBJ 13|2|PUNCT 14|17|LINK 15|17|SUBJ
	16|17|AUX 17|13|COMP 18|19|DET 19|17|OBJ 20|13|PUNCT
*S1:	that's all it's functioning as here .
%mor:	pro:dem|that~cop|be&3S pro:indef|all pro:per|it~aux|be&3S
	part|function-PRESP adv|as adv|here .
%gra:	1|2|SUBJ 2|0|ROOT 3|2|PRED 4|6|SUBJ 5|6|AUX 6|3|CMOD 7|8|JCT 8|6|JCT
	9|2|PUNCT
*S1:	and once we've got a@l sub start stored away in temp (.) then we
	can replace it with the small value .
%mor:	coord|and adv|once pro:sub|we~aux|have part|get&PASTP n:let|a n|sub
	v|start part|store-PASTP adv|away prep|in n|temp adv:tem|then
	pro:sub|we mod|can re#n|place pro:per|it prep|with det:art|the
	adj|small n|value .
%gra:	1|5|LINK 2|5|LINK 3|5|SUBJ 4|5|AUX 5|0|ROOT 6|9|COM 7|9|SUBJ
	8|7|POSTMOD 9|5|COMP 10|9|JCT 11|9|JCT 12|11|POBJ 13|16|JCT 14|16|SUBJ 15|16|AUX
	16|9|XJCT 17|16|OBJ 18|17|JCT 19|21|DET 20|21|MOD 21|18|POBJ 22|5|PUNCT
*S1:	so that moves the smallest value to the right spot in the array .
%mor:	adv|so pro:rel|that v|move-3S det:art|the adj|small-SP n|value
	prep|to det:art|the adj|right n|spot prep|in det:art|the n|array .
%gra:	1|3|JCT 2|3|LINK 3|0|ROOT 4|6|DET 5|6|MOD 6|3|OBJ 7|3|JCT 8|10|DET
	9|10|MOD 10|7|POBJ 11|10|NJCT 12|13|DET 13|11|POBJ 14|3|PUNCT
*S1:	and then (.) the other thing we do here is &-uh reset a@l sub small
	.
%mor:	coord|and adv:tem|then det:art|the qn|other n|thing pro:sub|we v|do
	adv|here cop|be&3S re#n|set n:let|a n|sub adj|small .
%gra:	1|7|LINK 2|7|JCT 3|5|DET 4|5|QUANT 5|7|JCT 6|7|SUBJ 7|0|ROOT 8|9|JCT
	9|7|COMP 10|9|PRED 11|10|POSTMOD 12|13|MOD 13|11|POSTMOD 14|7|PUNCT
*S1:	this is getting a@l sub start (.) for this last line .
%mor:	pro:dem|this aux|be&3S part|get-PRESP n:let|a n|sub v|start
	prep|for det:dem|this adj|last n|line .
%gra:	1|3|SUBJ 2|3|AUX 3|0|ROOT 4|6|JCT 5|6|SUBJ 6|3|COMP 7|6|JCT 8|10|DET
	9|10|MOD 10|7|POBJ 11|3|PUNCT
*S1:	(o)kay so in effect this is like saying a@l sub small equals (.)
	a@l sub start .
%mor:	co|okay adv|so adv|in n|effect pro:dem|this cop|be&3S co|like
	n:gerund|say-PRESP n:let|a n|sub adj|small n|equal-PL n:let|a n|sub
	v|start .
%gra:	1|5|COM 2|3|JCT 3|5|JCT 4|5|MOD 5|6|SUBJ 6|0|ROOT 7|6|COM 8|6|PRED
	9|12|DET 10|12|MOD 11|12|MOD 12|8|OBJ 13|15|COM 14|15|SUBJ 15|12|CMOD
	16|6|PUNCT
*S1:	now once we've done that we've done the swap (.) and actually let's
	use the (.) board here for a minute .
%mor:	adv|now adv|once pro:sub|we~aux|have part|do&PASTP pro:dem|that
	pro:sub|we~aux|have part|do&PASTP det:art|the v|swap coord|and
	adv|actual&dadj-LY v|let~pro:obj|us v|use det:art|the n|board
	adv|here prep|for det:art|a n|minute .
%gra:	1|2|JCT 2|5|LINK 3|5|SUBJ 4|5|AUX 5|0|ROOT 6|9|LINK 7|9|SUBJ 8|9|AUX
	9|5|COMP 10|11|DET 11|9|OBJ 12|11|CONJ 13|14|JCT 14|12|COORD 15|14|OBJ
	16|14|COMP 17|18|DET 18|16|OBJ 19|16|JCT 20|16|JCT 21|22|DET 22|20|POBJ
	23|5|PUNCT
*S1:	&=writing:board (o)kay it's pretty clear we're doing (.) something
	like this (.) to trade the two elements (.) and I've got one
	question for you which is why can't I do this ?
%mor:	co|okay pro:per|it~cop|be&3S adj|pretty adj|clear
	pro:sub|we~aux|be&PRES part|do-PRESP pro:indef|something prep|like
	pro:dem|this inf|to v|trade det:art|the det:num|two n|element-PL
	coord|and pro:sub|I~aux|have part|get&PASTP det:num|one n|question
	prep|for pro:per|you pro:rel|which cop|be&3S pro:int|why
	mod|can~neg|not pro:sub|I v|do pro:dem|this ?
%gra:	1|3|COM 2|3|SUBJ 3|8|CJCT 4|5|JCT 5|3|PRED 6|8|SUBJ 7|8|AUX 8|0|ROOT
	9|8|OBJ 10|8|JCT 11|10|POBJ 12|13|INF 13|8|XJCT 14|16|DET 15|16|QUANT
	16|13|OBJ 17|20|LINK 18|20|SUBJ 19|20|AUX 20|13|CJCT 21|22|QUANT 22|20|OBJ
	23|22|JCT 24|26|SUBJ 25|26|LINK 26|23|CPOBJ 27|31|JCT 28|31|AUX 29|28|NEG
	30|31|SUBJ 31|26|CPRED 32|31|OBJ 33|8|PUNCT
*S1:	&=writing:board (o)kay why can't I just do that in two (.)
	statements it looks shorter I don't hafta declare an extra variable
	+...
%mor:	co|okay pro:int|why mod|can~neg|not pro:sub|I adv|just v|do
	pro:dem|that prep|in det:num|two n|state&dv-MENT-PL pro:per|it
	v|look-3S adj|short-CP pro:sub|I mod|do~neg|not mod|have~inf|to
	v|declare det:art|a n|extra n|variable +...
%gra:	1|7|COM 2|7|JCT 3|7|AUX 4|3|NEG 5|7|SUBJ 6|7|JCT 7|0|ROOT 8|7|OBJ
	9|7|JCT 10|11|QUANT 11|9|POBJ 12|13|SUBJ 13|7|CJCT 14|13|PRED 15|20|SUBJ
	16|20|AUX 17|16|NEG 18|20|AUX 19|20|INF 20|14|CMOD 21|23|DET 22|23|MOD
	23|20|OBJ 24|7|PUNCT
*S1:	yeah David ?
%mor:	co|yeah n:prop|David ?
%gra:	1|2|COM 2|0|INCROOT 3|2|PUNCT
*S4:	&yo you'd lose the value in start .
%mor:	pro:per|you~mod|genmod v|lose det:art|the n|value prep|in v|start .
%gra:	1|3|SUBJ 2|3|AUX 3|0|ROOT 4|5|DET 5|3|OBJ 6|3|JCT 7|6|POBJ 8|3|PUNCT
*S1:	yeah exactly .
%mor:	co|yeah adv|exact&dadj-LY .
%gra:	1|2|COM 2|0|INCROOT 3|2|PUNCT
*S1:	&-uh you can't do a swap in two statements because you lose one of
	the values .
%mor:	pro:per|you mod|can~neg|not v|do det:art|a v|swap prep|in
	det:num|two n|state&dv-MENT-PL conj|because pro:per|you v|lose
	det:num|one prep|of det:art|the n|value-PL .
%gra:	1|4|SUBJ 2|4|AUX 3|2|NEG 4|0|ROOT 5|6|DET 6|4|OBJ 7|6|JCT 8|9|QUANT
	9|7|POBJ 10|12|LINK 11|12|SUBJ 12|4|CJCT 13|12|OBJ 14|13|JCT 15|16|DET
	16|14|POBJ 17|4|PUNCT
*S1:	alright you can try (.) if you're not convinced &-um tracing
	through it and (.) you'll see that one of the values gets lost
	they're both equal to the same thing .
%mor:	adj|alright pro:per|you mod|can v|try comp|if
	pro:per|you~aux|be&PRES neg|not part|convince-PASTP part|trace-PRESP
	prep|through pro:per|it coord|and pro:per|you~mod|will v|see
	comp|that pro:indef|one prep|of det:art|the n|value-PL v|get-3S
	v|lose&PAST pro:sub|they~cop|be&PRES qn|both adj|equal prep|to
	det:art|the adj|same n|thing .
%gra:	1|4|LINK 2|4|SUBJ 3|4|AUX 4|0|ROOT 5|9|LINK 6|9|SUBJ 7|9|AUX 8|7|NEG
	9|4|COMP 10|9|OBJ 11|9|JCT 12|11|POBJ 13|16|LINK 14|16|SUBJ 15|16|AUX
	16|9|CJCT 17|22|LINK 18|22|SUBJ 19|18|NJCT 20|21|DET 21|19|POBJ 22|16|COMP
	23|22|COMP 24|25|SUBJ 25|16|CJCT 26|27|QUANT 27|25|PRED 28|27|JCT
	29|31|DET 30|31|MOD 31|28|POBJ 32|4|PUNCT
*S1:	&-uh let's say that (.) this is (.) three and five .
%mor:	v|let~pro:obj|us v|say comp|that pro:dem|this cop|be&3S
	det:num|three coord|and det:num|five .
%gra:	1|0|ROOT 2|1|OBJ 3|1|COMP 4|6|LINK 5|6|SUBJ 6|3|COMP 7|6|PRED 8|7|CONJ
	9|8|COORD 10|1|PUNCT
*S1:	what would happen is that a@l sub start would get set to five (.)
	and then (.) a@l sub small is already five (.) but you're copying a
	five into it .
%mor:	pro:int|what mod|will&COND v|happen aux|be&3S adv|that n:let|a
	n|sub v|start mod|will&COND aux|get part|set&PASTP prep|to
	det:num|five coord|and adv:tem|then n:let|a n|sub adj|small
	aux|be&3S adv|already det:num|five conj|but pro:per|you~aux|be&PRES
	part|copy-PRESP det:art|a det:num|five prep|into pro:per|it .
%gra:	1|3|SUBJ 2|3|AUX 3|0|ROOT 4|6|AUX 5|6|JCT 6|3|COMP 7|8|SUBJ 8|6|COMP
	9|11|AUX 10|11|AUX 11|8|COMP 12|11|JCT 13|12|POBJ 14|13|CONJ 15|21|JCT
	16|21|DET 17|21|MOD 18|21|MOD 19|21|AUX 20|21|JCT 21|14|COORD 22|25|LINK
	23|25|SUBJ 24|25|AUX 25|11|CJCT 26|27|DET 27|25|OBJ 28|25|JCT 29|28|POBJ
	30|3|PUNCT
*S1:	(o)kay it's (.) pretty much a useless (.) sequence of code and you
	just wiped out one of the values .
%mor:	co|okay pro:per|it~cop|be&3S adj|pretty adv|much det:art|a
	adj|use&dn-LESS n|sequence prep|of n|code coord|and pro:per|you
	adv|just part|wipe-PASTP adv|out det:num|one prep|of det:art|the
	n|value-PL .
%gra:	1|3|COM 2|3|SUBJ 3|0|ROOT 4|3|PRED 5|3|JCT 6|8|DET 7|8|MOD 8|5|POBJ
	9|8|NJCT 10|9|POBJ 11|8|CONJ 12|14|SUBJ 13|14|JCT 14|11|COORD 15|14|JCT
	16|15|POBJ 17|16|NJCT 18|19|DET 19|17|POBJ 20|3|PUNCT
*S1:	so that's why we need a third variable to actually do this process
	&-uh any time we wanna do an exchange like that .
%mor:	co|so pro:dem|that~cop|be&3S pro:int|why pro:sub|we v|need
	det:art|a n|third n|variable inf|to adv|actual&dadj-LY v|do
	det:dem|this n|process qn|any n|time pro:sub|we v|want~inf|to v|do
	det:art|a n|exchange prep|like pro:dem|that .
%gra:	1|3|COM 2|3|SUBJ 3|0|ROOT 4|6|LINK 5|6|SUBJ 6|3|CPRED 7|9|DET 8|9|MOD
	9|6|OBJ 10|12|INF 11|12|JCT 12|9|XMOD 13|14|DET 14|12|OBJ 15|16|QUANT
	16|14|OBJ 17|18|SUBJ 18|16|CMOD 19|20|INF 20|18|COMP 21|22|DET 22|20|OBJ
	23|20|JCT 24|23|POBJ 25|3|PUNCT
*S1:	(o)kay well that's the end of the (.) loop that does (.) a pass (.)
	and you can see there are basically two processes going on here (.)
	the first (.) small for loop +...
%mor:	co|okay co|well pro:dem|that~cop|be&3S det:art|the n|end prep|of
	det:art|the n|loop pro:rel|that v|do&3S det:art|a n|pass coord|and
	pro:per|you mod|can v|see adv|there cop|be&PRES adv|basic&dadj-AL-LY
	det:num|two n|process-PL part|go-PRESP prep|on n|here det:art|the
	adj|first adj|small prep|for n|loop +...
%gra:	1|3|COM 2|3|COM 3|4|SUBJ 4|0|ROOT 5|6|DET 6|4|PRED 7|6|NJCT 8|9|DET
	9|7|POBJ 10|11|LINK 11|6|CMOD 12|13|DET 13|11|OBJ 14|17|LINK 15|17|SUBJ
	16|17|AUX 17|11|CJCT 18|17|JCT 19|17|COMP 20|19|JCT 21|22|QUANT 22|20|POBJ
	23|22|XMOD 24|23|JCT 25|24|POBJ 26|28|DET 27|28|MOD 28|23|JCT 29|28|JCT
	30|29|POBJ 31|4|PUNCT
*S1:	(o)kay this one (.) where we look for the smallest item (.) and
	then the second part here is (.) this part where we do the exchange
	.
%mor:	co|okay pro:dem|this pro:indef|one pro:rel|where pro:sub|we v|look
	prep|for det:art|the adj|small-SP n|item coord|and adv:tem|then
	det:art|the adj|second n|part adv|here cop|be&3S det:dem|this n|part
	pro:rel|where pro:sub|we v|do det:art|the n|exchange .
%gra:	1|2|COM 2|0|ROOT 3|2|PRED 4|6|LINK 5|6|SUBJ 6|3|CMOD 7|6|JCT 8|10|DET
	9|10|MOD 10|7|POBJ 11|17|LINK 12|17|JCT 13|15|DET 14|15|MOD 15|17|SUBJ
	16|17|JCT 17|6|CJCT 18|19|DET 19|17|PRED 20|22|LINK 21|22|SUBJ 22|19|CMOD
	23|24|DET 24|22|OBJ 25|2|PUNCT
*S1:	so we do that four times (.) and then &-uh as we saw with that
	small array at the end of that we're all sorted .
%mor:	co|so pro:sub|we v|do det:dem|that det:num|four n|time-PL coord|and
	adv:tem|then conj|as pro:sub|we n|saw prep|with det:dem|that
	adj|small n|array prep|at det:art|the n|end prep|of adv|that
	pro:sub|we~aux|be&PRES post|all part|sort-PASTP .
%gra:	1|3|COM 2|3|SUBJ 3|0|ROOT 4|6|DET 5|6|QUANT 6|3|JCT 7|3|CONJ 8|7|COORD
	9|11|LINK 10|11|SUBJ 11|3|CJCT 12|11|NJCT 13|15|DET 14|15|MOD 15|12|POBJ
	16|11|NJCT 17|18|DET 18|16|POBJ 19|18|NJCT 20|24|JCT 21|24|SUBJ
	22|24|AUX 23|24|JCT 24|19|POBJ 25|3|PUNCT
*S1:	now one thing to notice is that &-uh if you trace through this code
	with &-uh as Meredith said an array that's already all in order (.)
	basically you go through the whole thing anyway .
%mor:	adv|now det:num|one n|thing inf|to v|notice aux|be&3S comp|that
	conj|if pro:per|you v|trace prep|through det:dem|this n|code
	prep|with conj|as n:prop|Meredith v|say&PAST det:art|a n|array
	pro:rel|that~cop|be&3S adv|already adv|all prep|in n|order
	adv|basic&dadj-AL-LY pro:per|you v|go adj|through det:art|the
	adj|whole n|thing adv|anyway .
%gra:	1|2|JCT 2|3|QUANT 3|5|SUBJ 4|5|INF 5|0|ROOT 6|5|OBJ 7|6|PRED 8|10|LINK
	9|10|SUBJ 10|7|CJCT 11|10|JCT 12|13|DET 13|11|POBJ 14|10|JCT 15|17|LINK
	16|17|SUBJ 17|14|POBJ 18|19|DET 19|17|OBJ 20|21|LINK 21|19|CMOD
	22|21|JCT 23|24|JCT 24|21|JCT 25|24|POBJ 26|28|JCT 27|28|SUBJ 28|21|CPRED
	29|32|MOD 30|32|DET 31|32|MOD 32|28|OBJ 33|32|NJCT 34|5|PUNCT
*S1:	so efficiency is not our (.) crowning glory here with this sort
	&-uh but as I mentioned it is pretty decent for small N .
%mor:	co|so n|efficiency cop|be&3S neg|not det:poss|our part|crown-PRESP
	n|glory adv|here prep|with det:dem|this n|sort conj|but prep|as
	pro:sub|I v|mention-PAST pro:per|it cop|be&3S adv|pretty adj|decent
	prep|for adj|small n:prop|N .
%gra:	1|3|COM 2|3|SUBJ 3|0|ROOT 4|3|NEG 5|7|DET 6|7|XMOD 7|3|PRED 8|7|NJCT
	9|7|NJCT 10|11|DET 11|9|POBJ 12|15|LINK 13|15|JCT 14|15|SUBJ 15|3|CJCT
	16|15|OBJ 17|15|OBJ 18|19|JCT 19|17|PRED 20|19|JCT 21|22|MOD 22|20|POBJ
	23|3|PUNCT
*S1:	alright did you have a question ?
%mor:	co|alright mod|do&PAST pro:per|you v|have det:art|a n|question ?
%gra:	1|4|COM 2|4|AUX 3|4|SUBJ 4|0|ROOT 5|6|DET 6|4|OBJ 7|4|PUNCT
*S5:	yes (.) <if you> [/] if you have an error in your &-um code and you
	compile it &-um if +//.
%mor:	co|yes conj|if pro:per|you v|have det:art|a n|error prep|in
	det:poss|your n|code coord|and pro:per|you v|compile pro:per|it
	conj|if +//.
%gra:	1|4|COM 2|4|LINK 3|4|SUBJ 4|0|ROOT 5|6|DET 6|4|OBJ 7|4|JCT 8|9|DET
	9|7|POBJ 10|12|LINK 11|12|SUBJ 12|4|CJCT 13|12|OBJ 14|12|JCT 15|4|PUNCT
*S5:	say [?] you have something like this is +//.
%mor:	v|say pro:per|you v|have pro:indef|something prep|like pro:dem|this
	cop|be&3S +//.
%gra:	1|0|ROOT 2|3|SUBJ 3|1|COMP 4|7|SUBJ 5|4|NJCT 6|5|POBJ 7|3|COMP
	8|1|PUNCT
*S5:	do you like ruin your file for good (.) or (.) do you have to start
	over with a +/.
%mor:	mod|do pro:per|you v|like n|ruin det:poss|your n|file prep|for
	adj|good coord|or v|do pro:per|you v|have inf|to v|start adv|over
	prep|with det:art|a +/.
%gra:	1|3|AUX 2|3|SUBJ 3|0|ROOT 4|3|OBJ 5|6|DET 6|4|OBJ 7|6|NJCT 8|7|POBJ
	9|3|CONJ 10|9|COORD 11|12|SUBJ 12|10|COMP 13|14|INF 14|12|COMP 15|14|JCT
	16|14|JCT 17|18|DET 18|16|POBJ
*S5:	+, <⌊ xxx ⌋> [?] <version of the file> [?] file I was just
	wondering (.) does it make (.) permanent changes (.) every time you
	compile it ?
%mor:	n|version prep|of det:art|the n|file n|file pro:sub|I
	aux|be&PAST&13S adv|just part|wonder-PRESP mod|do&3S pro:per|it
	v|make n|permanent v|change-3S qn|every n|time pro:per|you v|compile
	pro:per|it ?
%gra:	1|0|INCROOT 2|1|NJCT 3|5|DET 4|5|MOD 5|2|POBJ 6|9|SUBJ 7|9|AUX 8|9|JCT
	9|1|XMOD 10|12|AUX 11|12|SUBJ 12|9|COMP 13|14|SUBJ 14|12|COMP
	15|16|QUANT 16|14|OBJ 17|18|SUBJ 18|16|CMOD 19|18|OBJ 20|1|PUNCT
*S1:	I'm not sure what you mean are you [/] you talking about destroying
	the original data ?
%mor:	pro:sub|I~cop|be&1S neg|not adv|sure pro:int|what pro:per|you
	v|mean aux|be&PRES pro:per|you part|talk-PRESP adv|about
	part|destroy-PRESP det:art|the adj|origin&dn-AL n|data ?
%gra:	1|2|SUBJ 2|0|ROOT 3|2|NEG 4|2|JCT 5|7|LINK 6|7|SUBJ 7|4|CPOBJ 8|7|OBJ
	9|8|PRED 10|9|XMOD 11|12|JCT 12|10|COMP 13|15|DET 14|15|MOD 15|12|OBJ
	16|2|PUNCT
*S5:	yeah +/.
%mor:	co|yeah +/.
%gra:	1|0|INCROOT 2|1|PUNCT
*S1:	⌈ that you ⌉ have +/.
%mor:	comp|that pro:per|you v|have +/.
%gra:	1|3|LINK 2|3|SUBJ 3|0|ROOT 4|3|PUNCT
*S5:	+, ⌊ if you were ⌋ like reading from an in file or something like
	that .
%mor:	conj|if pro:per|you cop|be&PAST co|like part|read-PRESP prep|from
	det:art|a prep|in n|file coord|or pro:indef|something prep|like
	pro:dem|that .
%gra:	1|3|LINK 2|3|SUBJ 3|0|ROOT 4|3|COM 5|3|XJCT 6|5|JCT 7|8|DET 8|6|POBJ
	9|8|POBJ 10|8|CONJ 11|10|COORD 12|11|NJCT 13|12|POBJ 14|3|PUNCT
*S1:	if [/] &-uh if you read a bunch of data in from a file (.) and then
	did this (.) in the program (.) you'd be altering the array in
	memory (.) only (.) but then if you were really using a file what
	you'd probably do is write out the array to the file at the end (.)
	and then yeah you would (.) ruin the file basically .
%mor:	conj|if pro:per|you v|read&ZERO det:art|a n|bunch prep|of n|data
	adv|in prep|from det:art|a n|file coord|and adv:tem|then v|do&PAST
	det:dem|this prep|in det:art|the n|program pro:per|you~mod|genmod
	aux|be part|alter-PRESP det:art|the n|array prep|in n|memory
	adv|only conj|but adv:tem|then conj|if pro:per|you aux|be&PAST
	adv|real&dadj-LY part|use-PRESP det:art|a n|file pro:int|what
	pro:per|you~mod|genmod adv|probable&dadj-LY v|do cop|be&3S v|write
	prep|out det:art|the n|array prep|to det:art|the n|file prep|at
	det:art|the n|end coord|and adv:tem|then co|yeah pro:per|you
	mod|will&COND v|ruin det:art|the n|file adv|basic&dadj-AL-LY .
%gra:	1|3|LINK 2|3|SUBJ 3|0|ROOT 4|5|DET 5|3|OBJ 6|5|NJCT 7|6|POBJ 8|3|JCT
	9|3|JCT 10|11|DET 11|9|POBJ 12|3|CONJ 13|14|JCT 14|12|COORD 15|14|OBJ
	16|22|JCT 17|18|DET 18|16|POBJ 19|22|SUBJ 20|22|AUX 21|22|AUX 22|15|CJCT
	23|24|DET 24|22|OBJ 25|22|JCT 26|25|POBJ 27|22|JCT 28|43|LINK 29|43|JCT
	30|34|LINK 31|34|SUBJ 32|34|AUX 33|34|JCT 34|43|CJCT 35|36|DET 36|34|OBJ
	37|41|OBJ 38|41|SUBJ 39|41|AUX 40|41|JCT 41|43|PRED 42|43|SUBJ 43|22|CJCT
	44|43|JCT 45|46|DET 46|44|POBJ 47|43|JCT 48|49|DET 49|47|POBJ 50|43|JCT
	51|52|DET 52|50|POBJ 53|58|LINK 54|58|JCT 55|58|COM 56|58|SUBJ 57|58|AUX
	58|43|CJCT 59|60|DET 60|58|OBJ 61|58|JCT 62|3|PUNCT
*S1:	(o)kay so it's definitely possible to &-uh lose a_lot_of
	information with just a tiny little (.) bug like this .
%mor:	adj|okay adv|so pro:per|it~cop|be&3S adv|definite&dadj-LY
	adj|possible inf|to v|lose qn|a_lot_of n|inform&dv-TION prep|with
	adj|just det:art|a adj|tiny adj|little n|bug prep|like pro:dem|this
	.
%gra:	1|4|SUBJ 2|4|JCT 3|4|SUBJ 4|0|ROOT 5|6|JCT 6|4|PRED 7|8|INF 8|6|XMOD
	9|10|QUANT 10|8|OBJ 11|10|NJCT 12|16|MOD 13|16|DET 14|16|MOD 15|16|MOD
	16|11|POBJ 17|16|NJCT 18|17|POBJ 19|4|PUNCT
*S1:	(o)kay any other questions about the (.) sort here ?
%mor:	co|okay qn|any qn|other n|question-PL prep|about det:art|the n|sort
	adv|here ?
%gra:	1|2|COM 2|4|QUANT 3|4|QUANT 4|0|INCROOT 5|4|NJCT 6|7|DET 7|5|POBJ
	8|4|JCT 9|4|PUNCT
*S1:	(o)kay well (.) I think it's kind_of amazing the first time I saw
	it which was I think nineteen seventy four &-uh I thought my
	goodness (.) &=laughs this works ?
%mor:	co|okay n|well pro:sub|I v|think pro:per|it~aux|be&3S adv|kind_of
	part|amaze-PRESP det:art|the adj|first n|time pro:sub|I v|see&PAST
	pro:per|it pro:int|which cop|be&PAST&13S pro:sub|I v|think
	det:num|nineteen det:num|seventy det:num|four pro:sub|I v|think&PAST
	det:poss|my co|goodness det:dem|this n|work-PL ?
%gra:	1|2|COM 2|4|LINK 3|4|SUBJ 4|0|ROOT 5|8|SUBJ 6|8|AUX 7|8|JCT 8|4|COMP
	9|11|DET 10|11|MOD 11|8|OBJ 12|13|SUBJ 13|4|CJCT 14|16|SUBJ 15|16|LINK
	16|13|COMP 17|18|SUBJ 18|16|CPRED 19|21|DATE 20|21|DATE 21|18|OBJ
	22|23|SUBJ 23|21|CMOD 24|25|DET 25|27|COM 26|27|DET 27|23|OBJ 28|4|PUNCT
*S1:	&=laughs and I wanna also mention (.) if we wanted to sort the
	array into descending order (.) all we have to do is change this to
	a greater than .
%mor:	coord|and pro:sub|I v|want~inf|to adv|also n|mention conj|if
	pro:sub|we v|want-PAST inf|to v|sort det:art|the n|array prep|into
	n:gerund|descend-PRESP n|order adv|all pro:sub|we v|have inf|to v|do
	cop|be&3S v|change det:dem|this prep|to det:art|a adj|great-CP
	prep|than .
%gra:	1|3|LINK 2|3|SUBJ 3|0|ROOT 4|5|INF 5|3|JCT 6|5|POBJ 7|9|LINK 8|9|SUBJ
	9|3|CJCT 10|11|INF 11|9|COMP 12|13|DET 13|11|OBJ 14|11|JCT 15|14|POBJ
	16|15|OBJ 17|19|JCT 18|19|SUBJ 19|11|CJCT 20|21|INF 21|23|SUBJ 22|23|AUX
	23|19|COMP 24|23|OBJ 25|24|JCT 26|28|DET 27|28|MOD 28|25|POBJ 29|3|PUNCT
*S1:	now that's also kind of amazing .
%mor:	adv|now pro:rel|that~cop|be&3S adv|also n|kind prep|of
	n:gerund|amaze-PRESP .
%gra:	1|0|INCROOT 2|3|LINK 3|1|CMOD 4|5|JCT 5|3|PRED 6|5|NJCT 7|6|POBJ
	8|1|PUNCT
*S1:	&-uh everything would work if we just flip the sign from less than
	to greater than .
%mor:	pro:indef|everything mod|will&COND v|work conj|if pro:sub|we
	adv|just v|flip det:art|the n|sign prep|from adj|less prep|than
	inf|to adj|great-CP prep|than .
%gra:	1|3|SUBJ 2|3|AUX 3|0|ROOT 4|7|LINK 5|7|SUBJ 6|7|JCT 7|3|CJCT 8|9|DET
	9|7|OBJ 10|7|JCT 11|10|POBJ 12|11|JCT 13|14|INF 14|12|POBJ 15|14|JCT
	16|3|PUNCT
*S1:	now (.) the other thing we would probably do if we (.) did want to
	sort in descending order (.) is change the name of small because (.)
	if we are sorting (.) descending order the meaning of that index is
	that it (.) indexes the largest item (.) in the unsorted part of the
	array .
%mor:	adv|now det:art|the qn|other n|thing pro:sub|we mod|will&COND
	adv|probable&dadj-LY v|do conj|if pro:sub|we mod|do&PAST v|want
	prep|to n|sort prep|in n:gerund|descend-PRESP n|order cop|be&3S
	v|change det:art|the n|name prep|of adj|small conj|because conj|if
	pro:sub|we aux|be&PRES part|sort-PRESP part|descend-PRESP n|order
	det:art|the n|meaning prep|of det:dem|that n|index cop|be&3S
	comp|that pro:per|it v|index-3S det:art|the adj|large-SP n|item
	prep|in det:art|the un#v|sort-PAST n|part prep|of det:art|the
	n|array .
%gra:	1|8|JCT 2|4|DET 3|4|QUANT 4|8|SUBJ 5|8|SUBJ 6|8|AUX 7|8|JCT 8|0|ROOT
	9|12|LINK 10|12|SUBJ 11|12|AUX 12|19|CJCT 13|14|INF 14|19|SUBJ 15|14|NJCT
	16|17|MOD 17|15|POBJ 18|19|AUX 19|8|COMP 20|21|DET 21|19|OBJ 22|21|NJCT
	23|22|POBJ 24|8|JCT 25|28|LINK 26|28|SUBJ 27|28|AUX 28|24|CPOBJ
	29|28|XJCT 30|36|JCT 31|32|DET 32|36|SUBJ 33|32|NJCT 34|35|DET 35|33|POBJ
	36|29|COMP 37|39|LINK 38|39|SUBJ 39|36|CPRED 40|42|DET 41|42|MOD 42|39|OBJ
	43|39|JCT 44|46|DET 45|46|MOD 46|43|POBJ 47|46|NJCT 48|49|DET 49|47|POBJ
	50|8|PUNCT
*S1:	so on program six actually you have to do a descending order (.)
	sort_of numbers .
%mor:	adv|so prep|on n|program det:num|six adv|actual&dadj-LY pro:per|you
	v|have inf|to v|do det:art|a part|descend-PRESP n|order adv|sort_of
	n|number-PL .
%gra:	1|2|JCT 2|7|JCT 3|2|POBJ 4|5|QUANT 5|7|JCT 6|7|SUBJ 7|0|ROOT 8|9|INF
	9|7|COMP 10|12|DET 11|12|MOD 12|9|OBJ 13|9|JCT 14|13|POBJ 15|7|PUNCT
*S1:	and keep in mind that is definitely &-uh stylewise better to rename
	that (.) one variable .
%mor:	coord|and v|keep prep|in n|mind pro:rel|that cop|be&3S
	adv|definite&dadj-LY adj|style&dn-WISE adj|good&CP prep|to re#n|name
	comp|that det:num|one n|variable .
%gra:	1|2|LINK 2|0|ROOT 3|2|JCT 4|3|POBJ 5|6|LINK 6|4|ROOT 7|8|JCT 8|6|PRED
	9|8|PRED 10|9|JCT 11|10|POBJ 12|14|LINK 13|14|QUANT 14|11|INCROOT
	15|14|PUNCT
*S1:	so change it to something like &-uh large or largest or max or [/]
	or whatever .
%mor:	adv|so v|change pro:per|it prep|to pro:indef|something prep|like
	adj|large coord|or adj|large-SP coord|or v|max coord|or
	pro:int|whatever .
%gra:	1|2|JCT 2|0|ROOT 3|2|OBJ 4|2|JCT 5|4|POBJ 6|5|NJCT 7|6|POBJ 8|7|CONJ
	9|8|COORD 10|2|CONJ 11|10|COORD 12|11|CONJ 13|12|COORD 14|2|PUNCT
*S1:	now we need to talk about efficiency (.) in a little more detail
	(.) and (.) there are two things that go into this discussion (.)
	one is (.) how many comparisons (.) this is a comparison of (.)
	array elements (.) we said that with searches (.) that was really
	the main thing how many comparisons do we do .
%mor:	adv|now pro:sub|we v|need inf|to v|talk prep|about n|efficiency
	prep|in det:art|a adj|little adv|more n|detail coord|and adv|there
	cop|be&PRES det:num|two n|thing-PL pro:rel|that v|go prep|into
	det:dem|this n|discussion det:num|one aux|be&3S pro:int|how qn|many
	n|comparison-PL pro:dem|this cop|be&3S det:art|a n|comparison
	prep|of n|array n|element-PL pro:sub|we v|say&PAST comp|that
	prep|with n|search-PL pro:rel|that cop|be&PAST&13S adv|real&dadj-LY
	det:art|the adj|main n|thing pro:int|how qn|many n|comparison-PL
	v|do pro:sub|we v|do .
%gra:	1|3|JCT 2|3|SUBJ 3|0|ROOT 4|5|INF 5|3|COMP 6|5|JCT 7|6|POBJ 8|7|NJCT
	9|12|DET 10|12|MOD 11|12|JCT 12|8|POBJ 13|3|CONJ 14|15|SUBJ 15|13|COORD
	16|17|QUANT 17|15|PRED 18|19|LINK 19|27|CJCT 20|19|JCT 21|22|DET
	22|20|POBJ 23|27|SUBJ 24|27|AUX 25|27|LINK 26|27|QUANT 27|36|JCT 28|29|SUBJ
	29|27|CMOD 30|31|DET 31|29|PRED 32|31|NJCT 33|34|MOD 34|32|POBJ 35|36|SUBJ
	36|17|CMOD 37|36|OBJ 38|37|JCT 39|38|POBJ 40|41|LINK 41|39|CMOD 42|41|JCT
	43|45|DET 44|45|MOD 45|42|POBJ 46|49|LINK 47|48|QUANT 48|49|JCT
	49|45|CMOD 50|51|SUBJ 51|49|COMP 52|3|PUNCT
*S1:	and with linear search we saw that we did (.) quite a few with the
	binary search we did (.) a smaller number (.) typically (.) with a
	sort we've also got another thing going on and that's how many
	exchanges are there .
%mor:	coord|and prep|with adj|linear n|search pro:sub|we v|see&PAST
	comp|that pro:sub|we v|do&PAST adv|quite det:art|a qn|few prep|with
	det:art|the adj|binary n|search pro:sub|we v|do&PAST det:art|a
	adj|small-CP n|number adv|typical&dadj-LY prep|with det:art|a n|sort
	pro:sub|we~aux|have adv|also part|get&PASTP qn|another n|thing
	part|go-PRESP adv|on coord|and pro:dem|that~cop|be&3S pro:int|how
	qn|many n|exchange-PL cop|be&PRES adv|there .
%gra:	1|6|LINK 2|6|JCT 3|4|MOD 4|2|POBJ 5|6|SUBJ 6|0|ROOT 7|9|LINK 8|9|SUBJ
	9|6|COMP 10|9|JCT 11|12|DET 12|9|OBJ 13|12|NJCT 14|16|DET 15|16|MOD
	16|13|POBJ 17|18|SUBJ 18|12|CJCT 19|21|DET 20|21|MOD 21|18|OBJ 22|18|JCT
	23|18|JCT 24|25|DET 25|23|POBJ 26|29|SUBJ 27|29|AUX 28|29|JCT 29|25|CMOD
	30|31|QUANT 31|29|OBJ 32|31|XMOD 33|32|JCT 34|36|LINK 35|36|SUBJ 36|32|CJCT
	37|40|LINK 38|39|QUANT 39|40|SUBJ 40|36|PRED 41|40|JCT 42|6|PUNCT
*S1:	so when you talk about efficiency with sorts it's comparisons and
	exchanges (.) typically +...
%mor:	co|so conj|when pro:per|you v|talk prep|about n|efficiency
	prep|with n|sort-PL pro:per|it~cop|be&3S n|comparison-PL coord|and
	v|exchange-3S adv|typical&dadj-LY +...
%gra:	1|10|COM 2|4|LINK 3|4|SUBJ 4|10|CJCT 5|4|JCT 6|5|POBJ 7|4|JCT 8|7|POBJ
	9|10|SUBJ 10|0|ROOT 11|10|PRED 12|10|CONJ 13|12|COORD 14|13|JCT
	15|10|PUNCT
*S1:	now again we won't go into the mathematics behind this (.) now some
	of the math majors I don't know if they wish we would or [/] or (.)
	hope that we never do but basically that's the topic of other
	classes especially EECS thirty eighty .
%mor:	adv|now adv|again pro:sub|we mod|will~neg|not v|go prep|into
	det:art|the n:pt|mathematics prep|behind pro:dem|this adv|now
	pro:indef|some prep|of det:art|the n|math v|major-3S pro:sub|I
	mod|do~neg|not v|know comp|if pro:sub|they v|wish pro:sub|we
	mod|will&COND coord|or n|hope pro:rel|that pro:sub|we adv|never v|do
	conj|but adv|basic&dadj-AL-LY pro:dem|that~cop|be&3S det:art|the
	n|topic prep|of qn|other n|class-PL adv|especial&dadj-LY n:prop|EECS
	det:num|thirty det:num|eighty .
%gra:	1|6|JCT 2|6|JCT 3|6|SUBJ 4|6|AUX 5|4|NEG 6|0|ROOT 7|6|JCT 8|9|DET
	9|7|POBJ 10|6|JCT 11|10|POBJ 12|17|JCT 13|17|SUBJ 14|13|NJCT 15|16|DET
	16|14|POBJ 17|6|CJCT 18|21|SUBJ 19|21|AUX 20|19|NEG 21|17|COMP 22|24|LINK
	23|24|SUBJ 24|21|COMP 25|32|SUBJ 26|32|AUX 27|26|CONJ 28|27|COORD 29|32|LINK
	30|32|SUBJ 31|32|JCT 32|24|COMP 33|36|LINK 34|36|JCT 35|36|SUBJ
	36|17|CJCT 37|38|DET 38|36|PRED 39|38|NJCT 40|41|QUANT 41|39|POBJ 42|45|JCT
	43|45|DATE 44|45|QUANT 45|38|XMOD 46|6|PUNCT
*S1:	if anybody gets to that point they spend a_lot_of time (.) on
	efficiency and &-uh the mathematics behind all of this (.) stuff I'm
	basically giving you up here &-uh as just facts .
%mor:	conj|if pro:indef|anybody v|get-3S prep|to det:dem|that n|point
	pro:sub|they v|spend qn|a_lot_of n|time prep|on n|efficiency
	coord|and det:art|the n:pt|mathematics prep|behind pro:indef|all
	prep|of det:dem|this n|stuff pro:sub|I~aux|be&1S
	adv|basic&dadj-AL-LY part|give-PRESP pro:per|you prep|up n|here
	prep|as adv|just n|fact-PL .
%gra:	1|3|LINK 2|3|SUBJ 3|8|CJCT 4|3|JCT 5|6|DET 6|4|POBJ 7|8|SUBJ 8|0|ROOT
	9|10|QUANT 10|8|OBJ 11|8|JCT 12|11|POBJ 13|12|CONJ 14|15|DET 15|13|COORD
	16|8|JCT 17|16|POBJ 18|17|NJCT 19|20|DET 20|18|POBJ 21|24|SUBJ 22|24|AUX
	23|24|JCT 24|8|CJCT 25|24|OBJ 26|24|JCT 27|26|POBJ 28|24|JCT 29|30|JCT
	30|28|POBJ 31|8|PUNCT
*S1:	it's all been proven and that's why I can do that (.) but later on
	if you (.) go on in computer science you'll see how to prove it .
%mor:	pro:per|it~cop|be&3S adv|all cop|be&PASTP part|prove&PASTP
	coord|and pro:dem|that~cop|be&3S pro:int|why pro:sub|I mod|can v|do
	pro:dem|that conj|but adv|later adv|on conj|if pro:per|you v|go
	adv|on prep|in n|compute&dv-AGT n|science pro:per|you~mod|will v|see
	pro:int|how inf|to v|prove pro:per|it .
%gra:	1|2|SUBJ 2|0|ROOT 3|4|JCT 4|2|PRED 5|4|PRED 6|8|LINK 7|8|SUBJ 8|5|COMP
	9|12|LINK 10|12|SUBJ 11|12|AUX 12|8|CPRED 13|12|OBJ 14|26|LINK 15|16|JCT
	16|26|JCT 17|19|LINK 18|19|SUBJ 19|26|CJCT 20|19|JCT 21|19|JCT
	22|23|MOD 23|21|POBJ 24|26|SUBJ 25|26|AUX 26|12|CJCT 27|29|LINK 28|29|INF
	29|26|COMP 30|29|OBJ 31|2|PUNCT
*S1:	now the maximum number of comparisons is given by this formula (.)
	N times N minus one over two +...
%mor:	adv|now det:art|the n|maximum n|number prep|of n|comparison-PL
	aux|be&3S part|give&PASTP prep|by det:dem|this n|formula n:prop|N
	v|time-3S n:prop|N n|minus det:num|one adv|over det:num|two +...
%gra:	1|13|JCT 2|4|DET 3|4|MOD 4|13|SUBJ 5|8|LINK 6|8|SUBJ 7|8|AUX 8|13|CJCT
	9|8|JCT 10|11|DET 11|9|POBJ 12|13|SUBJ 13|0|ROOT 14|15|MOD 15|13|OBJ
	16|17|QUANT 17|15|NJCT 18|13|ENUM 19|13|PUNCT
*S1:	one thing that's (.) actually intuitive (.) is the maximum number
	of exchanges .
%mor:	det:num|one n|thing pro:rel|that~cop|be&3S adv|actual&dadj-LY
	adj|intuitive aux|be&3S det:art|the n|maximum n|number prep|of
	n|exchange-PL .
%gra:	1|2|QUANT 2|0|INCROOT 3|4|LINK 4|2|CMOD 5|4|JCT 6|10|MOD 7|10|AUX
	8|10|DET 9|10|MOD 10|4|PRED 11|10|NJCT 12|11|POBJ 13|2|PUNCT
*S1:	now with that we can look at this number N minus one and say well
	that's the number of passes (.) I can only do one exchange on a pass
	(.) so (.) definitely (.) that is the maximum number of exchanges we
	could possibly do .
%mor:	adv|now prep|with det:dem|that pro:sub|we mod|can v|look prep|at
	det:dem|this n|number n:prop|N n|minus det:num|one coord|and v|say
	adv|well pro:dem|that~cop|be&3S det:art|the n|number prep|of
	n|pass-PL pro:sub|I mod|can adv|only v|do det:num|one n|exchange
	prep|on det:art|a n|pass adv|so adv|definite&dadj-LY pro:rel|that
	cop|be&3S det:art|the n|maximum n|number prep|of n|exchange-PL
	pro:sub|we mod|could adv|possible&dadj-LY v|do .
%gra:	1|0|INCROOT 2|1|JCT 3|6|DET 4|6|SUBJ 5|6|AUX 6|2|POBJ 7|6|JCT 8|9|DET
	9|11|MOD 10|11|MOD 11|7|POBJ 12|11|NJCT 13|12|CONJ 14|13|COORD 15|17|JCT
	16|17|SUBJ 17|14|COMP 18|19|DET 19|17|PRED 20|19|NJCT 21|20|POBJ
	22|25|SUBJ 23|25|AUX 24|25|JCT 25|19|CMOD 26|27|QUANT 27|25|OBJ 28|25|JCT
	29|30|DET 30|28|POBJ 31|32|JCT 32|25|JCT 33|34|LINK 34|32|CMOD 35|37|DET
	36|37|MOD 37|34|PRED 38|37|NJCT 39|38|POBJ 40|43|SUBJ 41|43|AUX 42|43|JCT
	43|37|CMOD 44|1|PUNCT
*S1:	so we could do anywhere from zero up to N minus one (.) exchanges .
%mor:	co|so pro:sub|we mod|could v|do adv|anywhere prep|from n|zero
	adv|up prep|to n:prop|N prep|minus det:num|one n|exchange-PL .
%gra:	1|4|COM 2|4|SUBJ 3|4|AUX 4|0|ROOT 5|4|JCT 6|4|JCT 7|6|POBJ 8|4|JCT
	9|4|JCT 10|9|POBJ 11|4|JCT 12|13|QUANT 13|11|POBJ 14|4|PUNCT
*S1:	the other number is a bit less &-uh intuitive but one way to think
	about that is that you've got (.) two loops (.) two for loops (.)
	and they're both ranging to about N .
%mor:	det:art|the qn|other n|number cop|be&3S det:art|a n|bit adj|less
	adj|intuitive conj|but det:num|one n|way inf|to v|think prep|about
	pro:rel|that aux|be&3S adv|that pro:per|you~aux|have part|get&PASTP
	det:num|two n|loop-PL det:num|two prep|for n|loop-PL coord|and
	pro:sub|they~aux|be&PRES qn|both part|range-PRESP inf|to prep|about
	n:prop|N .
%gra:	1|3|DET 2|3|QUANT 3|4|SUBJ 4|0|ROOT 5|6|DET 6|4|PRED 7|6|POSTMOD
	8|7|JCT 9|7|CONJ 10|11|QUANT 11|9|COORD 12|13|INF 13|11|XMOD 14|13|JCT
	15|20|LINK 16|20|AUX 17|20|JCT 18|20|SUBJ 19|20|AUX 20|14|CMOD 21|22|QUANT
	22|20|OBJ 23|22|OBJ 24|23|JCT 25|24|POBJ 26|23|CONJ 27|30|SUBJ 28|30|AUX
	29|30|QUANT 30|26|COORD 31|32|INF 32|30|COMP 33|32|POBJ 34|4|PUNCT
*S1:	and one thing we saw with nested for loops is that if you have &-uh
	a statement inside the inner loop it'll execute &-uh the number of
	times that the outer loop executes multiplied by the number of times
	(.) that the inner loop (.) executes .
%mor:	coord|and det:num|one n|thing pro:sub|we n|saw prep|with
	v|nest-PAST prep|for n|loop-PL cop|be&3S comp|that conj|if
	pro:per|you v|have det:art|a n|state&dv-MENT adj|inside det:art|the
	adj|inner n|loop pro:per|it~mod|will v|execute det:art|the n|number
	prep|of n|time-PL comp|that det:art|the adj|outer n|loop
	v|execute-3S v|multiply-PAST prep|by det:art|the n|number prep|of
	n|time-PL comp|that det:art|the adj|inner n|loop v|execute-3S .
%gra:	1|10|LINK 2|3|QUANT 3|10|JCT 4|10|SUBJ 5|10|SUBJ 6|5|NJCT 7|6|POBJ
	8|5|NJCT 9|8|POBJ 10|0|ROOT 11|10|PRED 12|14|LINK 13|14|SUBJ 14|11|CJCT
	15|16|DET 16|14|OBJ 17|20|MOD 18|20|DET 19|20|MOD 20|16|APP 21|23|SUBJ
	22|23|AUX 23|20|CMOD 24|25|DET 25|23|OBJ 26|25|NJCT 27|26|POBJ 28|32|LINK
	29|31|DET 30|31|MOD 31|32|SUBJ 32|23|COMP 33|32|OBJ 34|32|JCT 35|36|DET
	36|34|POBJ 37|36|NJCT 38|37|POBJ 39|43|LINK 40|42|DET 41|42|MOD 42|43|SUBJ
	43|38|CMOD 44|10|PUNCT
*S1:	so actually what we've got here is [/] is basically that situation
	.
%mor:	adv|so adv|actual&dadj-LY pro:int|what pro:sub|we~aux|have
	part|get&PASTP pro:exist|here cop|be&3S adv|basic&dadj-AL-LY
	adv|that n|situate&dv-TION .
%gra:	1|2|JCT 2|8|JCT 3|6|LINK 4|6|SUBJ 5|6|AUX 6|8|PRED 7|8|SUBJ 8|0|ROOT
	9|8|JCT 10|11|JCT 11|8|PRED 12|8|PUNCT
*S1:	alright (.) for one thing we did the multiplication example a while
	ago &-uh where we were multiplying &-uh all the numbers from one
	through nine and we made a nice table (.) and each loop went from
	one through nine .
%mor:	co|alright prep|for pro:indef|one n|thing pro:sub|we v|do&PAST
	det:art|the n|multiplication ex#adj|ample det:art|a n|while post|ago
	pro:int|where pro:sub|we aux|be&PAST part|multiply-PRESP adv|all
	det:art|the n|number-PL prep|from det:num|one adj|through
	det:num|nine coord|and pro:sub|we v|make&PAST det:art|a adj|nice
	n|table coord|and qn|each n|loop v|go&PAST prep|from det:num|one
	adj|through det:num|nine .
%gra:	1|6|COM 2|1|JCT 3|4|MOD 4|2|POBJ 5|6|SUBJ 6|0|ROOT 7|8|DET 8|6|OBJ
	9|8|XMOD 10|11|DET 11|9|OBJ 12|11|POSTMOD 13|16|LINK 14|16|SUBJ 15|16|AUX
	16|11|CMOD 17|19|JCT 18|19|DET 19|16|OBJ 20|19|NJCT 21|23|QUANT 22|23|MOD
	23|20|POBJ 24|26|LINK 25|26|SUBJ 26|23|CJCT 27|29|DET 28|29|MOD
	29|26|OBJ 30|29|CONJ 31|30|COORD 32|33|SUBJ 33|29|CMOD 34|33|JCT 35|36|QUANT
	36|37|MOD 37|34|POBJ 38|6|PUNCT
*S1:	we said that the statements inside the inner loop executed eighty
	one times .
%mor:	pro:sub|we v|say&PAST comp|that det:art|the n|state&dv-MENT-PL
	prep|inside det:art|the adj|inner n|loop part|execute-PASTP
	det:num|eighty det:num|one n|time-PL .
%gra:	1|2|SUBJ 2|0|ROOT 3|2|OBJ 4|5|DET 5|3|OBJ 6|5|NJCT 7|9|DET 8|9|MOD
	9|6|POBJ 10|9|XMOD 11|13|QUANT 12|13|QUANT 13|10|OBJ 14|2|PUNCT
*S1:	so nine times nine .
%mor:	co|so det:num|nine n|time-PL det:num|nine .
%gra:	1|3|COM 2|3|QUANT 3|4|MOD 4|0|ROOT 5|4|PUNCT
*S1:	and we've got a pretty similar situation right here +...
%mor:	coord|and pro:sub|we~aux|have part|get&PASTP det:art|a adj|pretty
	adj|similar n|situate&dv-TION adv|right adv|here +...
%gra:	1|4|LINK 2|4|SUBJ 3|4|AUX 4|0|ROOT 5|8|DET 6|7|JCT 7|8|MOD 8|4|OBJ
	9|10|JCT 10|8|NJCT 11|4|PUNCT
*S1:	now with that in mind &-uh actually when we talk about the [/] the
	time required to execute the algorithm (.) we look at the [/] the
	most overriding factor and that is (.) actually (.) the number of
	comparisons .
%mor:	adv|now prep|with pro:dem|that prep|in n|mind adv|actual&dadj-LY
	conj|when pro:sub|we v|talk prep|about det:art|the n|time
	v|require-PAST inf|to v|execute det:art|the n|algorithm pro:sub|we
	v|look prep|at det:art|the qn|most over#n:gerund|ride-PRESP n|factor
	coord|and pro:dem|that cop|be&3S adv|actual&dadj-LY det:art|the
	n|number prep|of n|comparison-PL .
%gra:	1|2|JCT 2|0|INCROOT 3|2|POBJ 4|3|JCT 5|4|POBJ 6|2|JCT 7|9|LINK 8|9|SUBJ
	9|6|CPOBJ 10|13|JCT 11|12|DET 12|13|SUBJ 13|9|COMP 14|15|INF 15|13|COMP
	16|17|DET 17|15|OBJ 18|19|SUBJ 19|13|CJCT 20|19|JCT 21|24|DET
	22|24|QUANT 23|24|MOD 24|20|POBJ 25|24|CONJ 26|25|COORD 27|19|JCT 28|27|JCT
	29|30|DET 30|28|POBJ 31|30|NJCT 32|31|POBJ 33|2|PUNCT
*S1:	and that's proportional to n@l squared .
%mor:	coord|and pro:dem|that~cop|be&3S adj|proportion&dn-AL inf|to
	n:let|n part|square-PASTP .
%gra:	1|3|LINK 2|3|SUBJ 3|0|ROOT 4|3|PRED 5|7|INF 6|7|SRL 7|4|XMOD 8|3|PUNCT
*S1:	we can see that with this formula here we've got N times N minus
	one (.) and that's where the n@l squared comes in .
%mor:	pro:sub|we mod|can v|see pro:dem|that prep|with det:dem|this
	n|formula adv|here pro:sub|we~aux|have part|get&PASTP n:prop|N
	v|time-3S n:prop|N n|minus det:num|one coord|and
	pro:dem|that~cop|be&3S pro:int|where det:art|the n:let|n
	part|square-PASTP v|come-3S adv|in .
%gra:	1|3|SUBJ 2|3|AUX 3|0|ROOT 4|3|OBJ 5|4|JCT 6|7|DET 7|5|POBJ 8|11|JCT
	9|11|SUBJ 10|11|AUX 11|7|CMOD 12|13|SUBJ 13|11|COMP 14|15|MOD 15|13|OBJ
	16|19|SUBJ 17|16|CONJ 18|17|COORD 19|15|CMOD 20|24|LINK 21|22|DET
	22|24|SUBJ 23|24|SUBJ 24|19|CPRED 25|24|JCT 26|3|PUNCT
*S1:	now this could get pretty bad if you're (.) say at a an airline and
	you wanna sort &-uh all of your five thousand flights (.) we've got
	five thousand squared on our hands .
%mor:	adv|now pro:dem|this mod|could v|get adv|pretty adj|bad conj|if
	pro:per|you~cop|be&PRES co|say prep|at det:art|a det:art|a n|airline
	coord|and pro:per|you v|want~prep|to n|sort adv|all prep|of
	det:poss|your det:num|five det:num|thousand n|flight-PL
	pro:sub|we~aux|have part|get&PASTP det:num|five det:num|thousand
	v|square-PAST prep|on det:poss|our n|hand-PL .
%gra:	1|2|JCT 2|4|SUBJ 3|4|AUX 4|0|ROOT 5|6|JCT 6|4|PRED 7|9|LINK 8|9|SUBJ
	9|4|CJCT 10|17|COM 11|17|JCT 12|14|DET 13|14|DET 14|11|POBJ 15|17|LINK
	16|17|SUBJ 17|9|CJCT 18|17|JCT 19|18|POBJ 20|28|JCT 21|20|JCT 22|23|DET
	23|25|QUANT 24|25|QUANT 25|21|POBJ 26|28|SUBJ 27|28|AUX 28|17|XJCT
	29|30|QUANT 30|31|QUANT 31|28|COMP 32|31|JCT 33|34|DET 34|32|POBJ 35|4|PUNCT
*S1:	mkay and that's gonna be a pretty big number .
%mor:	co|mkay coord|and pro:dem|that~aux|be&3S part|go-PRESP~inf|to
	cop|be det:art|a adj|pretty adj|big v|number .
%gra:	1|5|COM 2|1|CONJ 3|2|COORD 4|5|AUX 5|0|ROOT 6|7|INF 7|5|COMP 8|11|DET
	9|11|MOD 10|11|MOD 11|7|PRED 12|5|PUNCT
*S1:	so this is not an efficient sort (.) for large N +...
%mor:	adv|so pro:dem|this cop|be&3S neg|not det:art|a adj|efficient
	n|sort prep|for adj|large n:prop|N +...
%gra:	1|2|JCT 2|3|SUBJ 3|0|ROOT 4|3|NEG 5|7|DET 6|7|MOD 7|3|PRED 8|7|NJCT
	9|10|MOD 10|8|POBJ 11|3|PUNCT
*S1:	it's called a quadratic sort because &-uh I'm sure everybody's seen
	the quadratic equation (.) and you know that the &-uh idea there is
	that you've got a square (.) as one of the elements (.) in the
	equation .
%mor:	pro:per|it~aux|be&3S part|call-PASTP det:art|a adj|quadratic n|sort
	conj|because pro:sub|I~cop|be&1S adj|sure adj|everybody&dn-POSS
	part|see&PASTP det:art|the adj|quadratic n|equate&dv-TION coord|and
	pro:per|you v|know comp|that det:art|the n|idea pro:exist|there
	aux|be&3S adv|that pro:per|you~aux|have part|get&PASTP det:art|a
	adj|square adv|as det:num|one prep|of det:art|the n|element-PL
	prep|in det:art|the n|equate&dv-TION .
%gra:	1|3|SUBJ 2|3|AUX 3|12|JCT 4|6|DET 5|6|MOD 6|3|OBJ 7|9|LINK 8|9|SUBJ
	9|12|AUX 10|12|AUX 11|12|MOD 12|0|ROOT 13|15|DET 14|15|MOD 15|12|OBJ
	16|18|LINK 17|18|SUBJ 18|12|CJCT 19|18|OBJ 20|21|DET 21|19|OBJ 22|27|SUBJ
	23|27|AUX 24|27|JCT 25|27|SUBJ 26|27|AUX 27|21|CMOD 28|31|DET 29|31|MOD
	30|31|COORD 31|27|OBJ 32|31|JCT 33|34|DET 34|32|POBJ 35|31|JCT 36|37|DET
	37|35|POBJ 38|12|PUNCT
*S1:	and that's what we've got here we've got n@l squared .
%mor:	coord|and pro:dem|that~cop|be&3S pro:int|what pro:sub|we~aux|have
	part|get&PASTP adv|here pro:sub|we~aux|have part|get&PASTP n:let|n
	part|square-PASTP .
%gra:	1|3|LINK 2|3|SUBJ 3|0|ROOT 4|7|LINK 5|7|SUBJ 6|7|AUX 7|3|CPRED 8|7|JCT
	9|11|SUBJ 10|11|AUX 11|7|XJCT 12|11|OBJ 13|12|XMOD 14|3|PUNCT
*S1:	now the (.) problem that we've got in a one hundred level class is
	that we can't cover a quick (.) sort .
%mor:	adv|now det:art|the n|problem pro:rel|that pro:sub|we~aux|have
	part|get&PASTP prep|in det:art|a det:num|one det:num|hundred
	adj|level n|class cop|be&3S comp|that pro:sub|we mod|can~neg|not
	v|cover det:art|a adj|quick n|sort .
%gra:	1|14|JCT 2|3|DET 3|14|SUBJ 4|7|LINK 5|7|SUBJ 6|7|AUX 7|3|CMOD 8|7|JCT
	9|10|DET 10|13|QUANT 11|13|QUANT 12|13|MOD 13|8|POBJ 14|0|ROOT 15|19|LINK
	16|19|SUBJ 17|19|AUX 18|17|NEG 19|14|CPRED 20|22|DET 21|22|MOD
	22|19|OBJ 23|14|PUNCT
*S1:	and actually the quick sort is the name of one of the [/] the very
	efficient sorts (.) and it uses recursion very heavily &-uh
	in_order_to (.) perform the process and it works much better than
	(.) this particular sort .
%mor:	coord|and adv|actual&dadj-LY det:art|the adj|quick n|sort cop|be&3S
	det:art|the n|name prep|of det:num|one prep|of det:art|the adv|very
	adj|efficient n|sort-PL coord|and pro:per|it v|use-3S n|recursion
	adv|very adv|heavy&dadj-LY inf|in_order_to v|perform det:art|the
	n|process coord|and pro:per|it v|work-3S adv|much adv|good&CP
	prep|than det:dem|this adj|particular n|sort .
%gra:	1|6|LINK 2|6|JCT 3|5|DET 4|5|MOD 5|6|SUBJ 6|0|ROOT 7|8|DET 8|6|PRED
	9|8|NJCT 10|9|POBJ 11|10|NJCT 12|15|DET 13|14|JCT 14|15|MOD 15|11|POBJ
	16|18|LINK 17|18|SUBJ 18|8|CJCT 19|18|OBJ 20|21|JCT 21|18|JCT 22|23|INF
	23|18|COMP 24|25|DET 25|23|OBJ 26|28|LINK 27|28|SUBJ 28|18|CJCT 29|28|JCT
	30|29|JCT 31|30|JCT 32|34|DET 33|34|MOD 34|31|POBJ 35|6|PUNCT
*S1:	the problem is that we can't cover that in this course .
%mor:	det:art|the n|problem cop|be&3S comp|that pro:sub|we
	mod|can~neg|not v|cover pro:dem|that prep|in det:dem|this n|course .
%gra:	1|2|DET 2|3|SUBJ 3|0|ROOT 4|8|LINK 5|8|SUBJ 6|8|AUX 7|6|NEG 8|3|CPRED
	9|8|OBJ 10|8|JCT 11|12|DET 12|10|POBJ 13|3|PUNCT
*S1:	okay we don't cover recursion &-uh we're not going to (.) if you do
	go on and say take two eighty you'd see that &-uh pretty early in
	the course and then you'd be able to look at the (.) faster sorts at
	that point .
%mor:	adj|okay pro:sub|we mod|do~neg|not v|cover n|recursion
	pro:sub|we~aux|be&PRES neg|not part|go-PRESP inf|to conj|if
	pro:per|you v|do v|go adv|on coord|and co|say v|take det:num|two
	det:num|eighty pro:per|you~mod|genmod co|see adv|that adv|pretty
	adv|early prep|in det:art|the n|course coord|and adv:tem|then
	pro:per|you~mod|genmod cop|be adj|able inf|to v|look prep|at
	det:art|the adj|fast-CP n|sort-PL prep|at det:dem|that n|point .
%gra:	1|5|LINK 2|5|SUBJ 3|5|AUX 4|3|NEG 5|0|ROOT 6|5|OBJ 7|10|SUBJ 8|10|AUX
	9|8|NEG 10|5|XJCT 11|12|INF 12|10|COMP 13|14|SUBJ 14|12|COMP 15|14|OBJ
	16|14|JCT 17|14|CONJ 18|19|COM 19|17|COORD 20|21|QUANT 21|19|OBJ
	22|24|SUBJ 23|24|AUX 24|35|COM 25|26|JCT 26|27|JCT 27|35|JCT 28|27|JCT 29|30|DET
	30|28|POBJ 31|35|LINK 32|35|JCT 33|35|SUBJ 34|35|AUX 35|21|COMP
	36|35|PRED 37|38|INF 38|36|XMOD 39|38|JCT 40|42|DET 41|42|MOD 42|39|POBJ
	43|38|JCT 44|45|DET 45|43|POBJ 46|5|PUNCT
*S1:	now last time we looked at some graphs &-uh the linear search
	versus the binary search &-uh the linear search was &-uh O of N (.)
	and the binary search was O of log two of N (.) and we just settle
	this one as ON squared and the graph for that is (.) approximately
	like this .
%mor:	adv|now adj|last n|time pro:sub|we v|look-PAST prep|at qn|some
	n|graph-PL det:art|the adj|linear n|search prep|versus det:art|the
	adj|binary n|search det:art|the adj|linear n|search cop|be&PAST&13S
	n:prop|O prep|of n:prop|N coord|and det:art|the adj|binary n|search
	cop|be&PAST&13S n:prop|O prep|of n|log det:num|two prep|of n:prop|N
	coord|and pro:sub|we adv|just v|settle det:dem|this pro:indef|one
	prep|as n:prop|ON v|square-PAST coord|and det:art|the n|graph
	prep|for pro:rel|that cop|be&3S adv|approximate&dadj-LY v|like
	pro:dem|this .
%gra:	1|2|JCT 2|3|MOD 3|0|INCROOT 4|5|SUBJ 5|3|CMOD 6|5|JCT 7|8|QUANT
	8|6|POBJ 9|11|DET 10|11|MOD 11|6|POBJ 12|11|NJCT 13|15|DET 14|15|MOD 15|12|POBJ
	16|18|DET 17|18|MOD 18|19|SUBJ 19|11|CMOD 20|19|PRED 21|20|NJCT
	22|21|POBJ 23|27|LINK 24|26|DET 25|26|MOD 26|27|SUBJ 27|19|CJCT 28|27|PRED
	29|28|NJCT 30|29|POBJ 31|32|QUANT 32|28|JCT 33|32|POBJ 34|37|LINK 35|37|SUBJ
	36|37|JCT 37|28|CJCT 38|39|DET 39|37|OBJ 40|42|COORD 41|42|SUBJ
	42|37|CJCT 43|42|CONJ 44|45|DET 45|43|COORD 46|45|NJCT 47|48|LINK 48|46|POBJ
	49|50|JCT 50|48|CPRED 51|50|OBJ 52|3|PUNCT
*S1:	&-uh now I drew this by hand because I was having trouble getting
	my &-uh graphing calculator to allow me to take (.) the image it
	produced for the graph and then put it in the power point show .
%mor:	adv|now pro:sub|I v|draw&PAST pro:dem|this prep|by n|hand
	conj|because pro:sub|I aux|be&PAST&13S part|have-PRESP n|trouble
	part|get-PRESP det:poss|my part|graph-PRESP n|calculator inf|to
	v|allow pro:obj|me inf|to v|take det:art|the n|image pro:per|it
	v|produce-PAST prep|for det:art|the n|graph coord|and adv:tem|then
	v|put&ZERO pro:per|it prep|in det:art|the n|power n|point n|show .
%gra:	1|3|JCT 2|3|SUBJ 3|0|ROOT 4|3|OBJ 5|3|JCT 6|5|POBJ 7|10|LINK 8|10|SUBJ
	9|10|AUX 10|3|CJCT 11|10|OBJ 12|10|XJCT 13|15|DET 14|15|XMOD 15|12|OBJ
	16|17|INF 17|10|XJCT 18|17|OBJ 19|20|INF 20|17|COMP 21|22|DET 22|20|OBJ
	23|24|SUBJ 24|20|CJCT 25|24|JCT 26|27|DET 27|25|POBJ 28|30|LINK 29|30|JCT
	30|24|CJCT 31|30|OBJ 32|30|JCT 33|36|DET 34|36|MOD 35|36|MOD 36|32|POBJ
	37|3|PUNCT
*S1:	but hopefully this is a good enough (.) approximation that you can
	see (.) how the processing time increases .
%mor:	conj|but adj|hope&dn-FUL-LY pro:dem|this cop|be&3S det:art|a
	adj|good adv|enough n|approximate&dv-TION comp|that pro:per|you
	mod|can v|see pro:int|how det:art|the part|process-PRESP n|time
	n|increase-PL .
%gra:	1|4|LINK 2|3|MOD 3|4|SUBJ 4|0|ROOT 5|8|DET 6|8|MOD 7|8|MOD 8|4|PRED
	9|12|LINK 10|12|SUBJ 11|12|AUX 12|8|CMOD 13|17|LINK 14|17|DET 15|17|MOD
	16|17|MOD 17|12|OBJ 18|4|PUNCT
*S1:	and it increases drastically I mean this is just really a (.) you
	know a huge increase as N goes up .
%mor:	coord|and pro:per|it v|increase-3S adv|drastic&dadj-AL-LY pro:sub|I
	v|mean pro:dem|this cop|be&3S adv|just adv|real&dadj-LY det:art|a
	pro:per|you v|know det:art|a adj|huge n|increase conj|as n:prop|N
	v|go-3S adv|up .
%gra:	1|3|LINK 2|3|SUBJ 3|6|CJCT 4|3|JCT 5|6|SUBJ 6|0|ROOT 7|8|SUBJ 8|13|SUBJ
	9|8|JCT 10|13|JCT 11|12|DET 12|13|SUBJ 13|6|COMP 14|16|DET 15|16|MOD
	16|13|OBJ 17|18|COORD 18|19|SUBJ 19|6|CJCT 20|19|JCT 21|6|PUNCT
*S1:	okay .
%mor:	co|okay .
%gra:	1|0|INCROOT 2|1|PUNCT
*S1:	well are there are any questions at all about the selection sort
	(.) or about sorting in general for that matter ?
%mor:	n|well cop|be&PRES adv|there cop|be&PRES qn|any n|question-PL
	prep|at adv|all prep|about det:art|the n|selection n|sort coord|or
	adv|about part|sort-PRESP prep|in adj|general prep|for det:dem|that
	v|matter ?
%gra:	1|2|SUBJ 2|0|ROOT 3|2|JCT 4|2|PRED 5|6|QUANT 6|4|PRED 7|6|NJCT 8|9|JCT
	9|7|POBJ 10|12|DET 11|12|MOD 12|9|POBJ 13|9|CONJ 14|15|JCT 15|13|COORD
	16|15|JCT 17|16|POBJ 18|13|COORD 19|20|DET 20|18|POBJ 21|2|PUNCT
*S1:	(0.7) (o)kay well there are lots_of other sorts (.) and if (.) this
	intrigues you [/] you can ask Jim or me in office hours about &-uh
	you_know what else is out there (.) and we'd be able to talk about
	it +...
%mor:	adj|okay adv|well adv|there cop|be&PRES qn|lots_of qn|other
	n|sort-PL coord|and conj|if det:dem|this n|intrigue-PL pro:per|you
	mod|can v|ask n:prop|Jim coord|or pro:obj|me prep|in n|office
	n|hour-PL adv|about co|you_know pro:int|what post|else aux|be&3S
	prep|out n|there coord|and pro:sub|we~mod|genmod cop|be adj|able
	inf|to v|talk prep|about pro:per|it +...
%gra:	1|4|SUBJ 2|1|JCT 3|1|JCT 4|0|ROOT 5|7|QUANT 6|7|QUANT 7|4|PUNCT
	8|7|CONJ 9|8|COORD 10|11|DET 11|9|POBJ 12|14|SUBJ 13|14|AUX 14|11|ROOT
	15|14|OBJ 16|14|CONJ 17|16|COORD 18|17|JCT 19|20|MOD 20|18|POBJ 21|22|JCT
	22|23|COM 23|17|ROOT 24|23|PQ 25|24|INCROOT 26|25|JCT 27|26|POBJ 28|31|LINK
	29|31|SUBJ 30|31|AUX 31|26|CPOBJ 32|31|PRED 33|34|INF 34|32|XMOD 35|34|JCT
	36|35|POBJ 37|25|PUNCT
*S1:	one last note about (.) this (.) sort (.) and that is that &-uh in
	program six you need to sort parallel arrays (.) if you (.) use that
	data structure .
%mor:	det:num|one adj|last n|note prep|about det:dem|this n|sort
	coord|and pro:dem|that cop|be&3S pro:dem|that prep|in n|program
	det:num|six pro:per|you v|need inf|to v|sort adv|parallel v|array-3S
	conj|if pro:per|you v|use det:dem|that n|data n|structure .
%gra:	1|3|QUANT 2|3|MOD 3|9|SUBJ 4|3|NJCT 5|6|DET 6|4|POBJ 7|3|CONJ 8|7|COORD
	9|0|ROOT 10|9|PRED 11|9|JCT 12|11|POBJ 13|15|QUANT 14|15|SUBJ
	15|9|CPRED 16|17|INF 17|15|COMP 18|17|JCT 19|17|COMP 20|22|LINK 21|22|SUBJ
	22|19|CJCT 23|25|DET 24|25|MOD 25|22|OBJ 26|9|PUNCT
*S1:	&-uh you've also got a choice in that program of using an array of
	structs [: structures] .
%mor:	pro:per|you~aux|have adv|also part|get&PASTP det:art|a n|choice
	prep|in det:dem|that n|program prep|of n:gerund|use-PRESP det:art|a
	n|array prep|of n|structure-PL .
%gra:	1|4|SUBJ 2|4|AUX 3|4|JCT 4|0|ROOT 5|6|DET 6|4|OBJ 7|6|NJCT 8|9|DET
	9|7|POBJ 10|7|JCT 11|10|POBJ 12|13|DET 13|11|OBJ 14|13|NJCT 15|14|POBJ
	16|4|PUNCT
*S1:	and that's something we'll be talking about later &-uh probably not
	today (.) probably tomorrow .
%mor:	coord|and pro:dem|that~cop|be&3S pro:indef|something
	pro:sub|we~mod|will aux|be part|talk-PRESP prep|about adv|later
	adv|probable&dadj-LY neg|not adv:tem|today adv|probable&dadj-LY
	adv:tem|tomorrow .
%gra:	1|3|LINK 2|3|SUBJ 3|0|ROOT 4|8|LINK 5|8|SUBJ 6|8|AUX 7|8|AUX 8|3|CPRED
	9|8|JCT 10|13|JCT 11|13|JCT 12|11|NEG 13|9|POBJ 14|15|JCT 15|13|JCT
	16|3|PUNCT
*S1:	now let's say we had our area codes and our locations array (.)
	that we talked about yesterday (.) and what we'd like to do is sort
	both of them (.) into ascending (.) numeric order by area code .
%mor:	adv|now v|let~pro:obj|us v|say pro:sub|we v|have&PAST det:poss|our
	n|area n|code-PL coord|and det:poss|our n|locate&dv-TION-PL n|array
	pro:rel|that pro:sub|we v|talk-PAST adv|about adv:tem|yesterday
	coord|and pro:int|what pro:sub|we~mod|genmod v|like inf|to v|do
	cop|be&3S v|sort qn|both prep|of pro:obj|them prep|into
	part|ascend-PRESP adj|numeric n|order prep|by n|area n|code .
%gra:	1|2|JCT 2|6|CJCT 3|2|OBJ 4|2|COMP 5|6|SUBJ 6|0|ROOT 7|9|DET 8|9|MOD
	9|6|OBJ 10|6|CONJ 11|13|DET 12|13|MOD 13|10|COORD 14|16|LINK 15|16|SUBJ
	16|13|CMOD 17|18|JCT 18|16|JCT 19|13|CONJ 20|23|LINK 21|23|SUBJ 22|23|AUX
	23|19|COORD 24|25|INF 25|23|COMP 26|27|AUX 27|25|OBJ 28|27|OBJ 29|28|JCT
	30|29|POBJ 31|25|JCT 32|31|POBJ 33|34|MOD 34|32|OBJ 35|34|NJCT 36|37|MOD
	37|35|POBJ 38|6|PUNCT
*S1:	now what we know is we can't sort one array and then leave the
	other one (.) unchanged because we'll lose that parallel
	relationship that we worked so hard to set up .
%mor:	adv|now pro:int|what pro:sub|we v|know aux|be&3S pro:sub|we
	mod|can~neg|not n|sort det:num|one n|array coord|and adv:tem|then
	v|leave det:art|the qn|other pro:indef|one un#part|change-PASTP
	conj|because pro:sub|we~mod|will v|lose comp|that adj|parallel
	n|relate&dv-TION-SHIP comp|that pro:sub|we part|work-PASTP adv|so
	adj|hard inf|to v|set&ZERO adv|up .
%gra:	1|4|JCT 2|4|LINK 3|4|SUBJ 4|0|ROOT 5|9|AUX 6|9|SUBJ 7|9|AUX 8|7|NEG
	9|4|COMP 10|11|QUANT 11|9|APP 12|14|LINK 13|14|JCT 14|11|CMOD 15|17|DET
	16|17|QUANT 17|14|OBJ 18|17|NJCT 19|22|LINK 20|22|SUBJ 21|22|AUX 22|18|CJCT
	23|22|OBJ 24|25|MOD 25|23|PRED 26|28|LINK 27|28|SUBJ 28|25|CMOD
	29|30|JCT 30|28|JCT 31|32|INF 32|30|XMOD 33|32|JCT 34|4|PUNCT
*S1:	so what we need to do with this (0.5) is do the comparisons using
	the (.) area codes array (.) and the area code here would be called
	the sort key .
%mor:	adv|so pro:int|what pro:sub|we v|need inf|to v|do prep|with
	pro:dem|this cop|be&3S v|do det:art|the n|comparison-PL
	part|use-PRESP det:art|the n|area v|code-3S n|array coord|and
	det:art|the n|area n|code adv|here mod|will&COND aux|be
	part|call-PASTP det:art|the n|sort n|key .
%gra:	1|2|JCT 2|4|LINK 3|4|SUBJ 4|10|SUBJ 5|6|INF 6|4|COMP 7|6|JCT 8|7|POBJ
	9|10|AUX 10|0|ROOT 11|12|DET 12|10|OBJ 13|10|XJCT 14|15|DET 15|16|SUBJ
	16|13|COMP 17|16|OBJ 18|25|LINK 19|21|DET 20|21|MOD 21|25|SUBJ 22|25|JCT
	23|25|AUX 24|25|AUX 25|17|CJCT 26|28|DET 27|28|MOD 28|25|OBJ 29|10|PUNCT
*S1:	that means what are you sorting on ?
%mor:	pro:dem|that v|mean-3S pro:int|what aux|be&PRES pro:per|you
	part|sort-PRESP adv|on ?
%gra:	1|2|SUBJ 2|0|ROOT 3|6|SUBJ 4|6|AUX 5|6|SUBJ 6|2|COMP 7|6|JCT 8|2|PUNCT
*S1:	&-uh one thing to notice if you use Excel (.) is that you can (.)
	sort the data that you're looking at (.) and you'll actually see the
	word key in one of their &-uh windows with the options that you're
	picking for the sort .
%mor:	det:num|one n|thing prep|to n|notice conj|if pro:per|you v|use
	n:prop|Excel cop|be&3S comp|that pro:per|you mod|can v|sort
	det:art|the n|data pro:rel|that pro:per|you~aux|be&PRES
	part|look-PRESP prep|at coord|and pro:per|you~mod|will
	adv|actual&dadj-LY v|see det:art|the n|word n|key prep|in
	pro:indef|one prep|of det:poss|their n|window-PL prep|with
	det:art|the n|option-PL pro:rel|that pro:per|you~aux|be&PRES
	part|pick-PRESP prep|for det:art|the n|sort .
%gra:	1|2|QUANT 2|9|SUBJ 3|2|NJCT 4|3|POBJ 5|7|LINK 6|7|SUBJ 7|2|CMOD 8|7|OBJ
	9|0|ROOT 10|13|LINK 11|13|SUBJ 12|13|AUX 13|9|CPRED 14|15|DET 15|13|OBJ
	16|19|LINK 17|19|SUBJ 18|19|AUX 19|15|CMOD 20|19|JCT 21|25|LINK
	22|25|SUBJ 23|25|AUX 24|25|JCT 25|20|POBJ 26|28|DET 27|28|MOD 28|25|OBJ
	29|25|JCT 30|29|POBJ 31|30|NJCT 32|33|DET 33|31|POBJ 34|25|JCT 35|36|DET
	36|34|POBJ 37|40|LINK 38|40|SUBJ 39|40|AUX 40|36|CMOD 41|40|JCT 42|43|DET
	43|41|POBJ 44|9|PUNCT
*S1:	so you can choose what to sort on and that's what you're (.)
	actually looking at .
%mor:	co|so pro:per|you mod|can v|choose pro:int|what inf|to v|sort
	adv|on coord|and pro:dem|that~cop|be&3S pro:int|what
	pro:per|you~aux|be&PRES adv|actual&dadj-LY part|look-PRESP prep|at .
%gra:	1|4|COM 2|4|SUBJ 3|4|AUX 4|0|ROOT 5|7|LINK 6|7|INF 7|4|COMP 8|7|JCT
	9|11|LINK 10|11|SUBJ 11|7|CJCT 12|16|LINK 13|16|SUBJ 14|16|AUX 15|16|JCT
	16|11|CPRED 17|16|JCT 18|4|PUNCT
*S1:	so (.) for a comparison I'd have (.) this if area code sub current
	is less than area code sub small .
%mor:	co|so prep|for det:art|a n|comparison pro:sub|I~mod|genmod v|have
	det:dem|this comp|if n|area n|code n|sub adj|current cop|be&3S
	adj|less prep|than n|area n|code n|sub adj|small .
%gra:	1|7|COM 2|7|JCT 3|4|DET 4|2|POBJ 5|7|SUBJ 6|7|AUX 7|0|ROOT 8|14|DET
	9|14|LINK 10|12|MOD 11|12|MOD 12|14|SUBJ 13|12|POSTMOD 14|7|COMP 15|14|PRED
	16|15|JCT 17|19|MOD 18|19|MOD 19|16|POBJ 20|19|POSTMOD 21|7|PUNCT
*S1:	and that would take care of (.) that part of the selection sort as
	far converting it over to this other array .
%mor:	coord|and pro:dem|that mod|will&COND v|take n|care prep|of
	det:dem|that n|part prep|of det:art|the n|selection n|sort prep|as
	adv|far part|convert-PRESP pro:per|it adv|over prep|to det:dem|this
	qn|other n|array .
%gra:	1|4|LINK 2|4|SUBJ 3|4|AUX 4|0|ROOT 5|4|OBJ 6|5|NJCT 7|8|DET 8|6|POBJ
	9|8|NJCT 10|12|DET 11|12|MOD 12|9|POBJ 13|15|COORD 14|15|JCT 15|4|CJCT
	16|15|OBJ 17|15|JCT 18|15|JCT 19|21|DET 20|21|QUANT 21|18|POBJ 22|4|PUNCT
*S1:	&-uh obviously I'd need to pass in (.) the area codes array itself
	(.) and I'd need to pass in (.) the size of the area codes array .
%mor:	adv|obvious&dadj-LY pro:sub|I~mod|genmod v|need inf|to v|pass
	prep|in det:art|the n|area v|code-3S v|array pro:refl|itself
	coord|and pro:sub|I~mod|genmod v|need inf|to v|pass prep|in
	det:art|the n|size prep|of det:art|the n|area v|code-3S n|array .
%gra:	1|4|JCT 2|4|SUBJ 3|4|AUX 4|0|ROOT 5|6|INF 6|4|COMP 7|6|JCT 8|9|DET
	9|7|POBJ 10|4|XJCT 11|10|OBJ 12|11|OBJ 13|16|LINK 14|16|SUBJ 15|16|AUX
	16|10|CJCT 17|18|INF 18|16|COMP 19|18|JCT 20|21|DET 21|19|POBJ 22|21|NJCT
	23|24|DET 24|25|SUBJ 25|22|POBJ 26|25|OBJ 27|4|PUNCT
*S1:	other than that I could basically take the selection sort &-uh copy
	and paste it into (.) this new program that I'd be working on (.)
	and just substitute the word area codes every place you see &-uh
	array A that we were just looking at .
%mor:	pro:indef|other prep|than adv|that pro:sub|I mod|could
	adv|basic&dadj-AL-LY v|take det:art|the n|selection n|sort n|copy
	coord|and v|paste pro:per|it prep|into det:dem|this adj|new
	n|program comp|that pro:sub|I~mod|genmod aux|be part|work-PRESP
	adv|on coord|and adv|just v|substitute det:art|the n|word n|area
	v|code-3S qn|every n|place pro:per|you co|see v|array n:prop|A
	comp|that pro:sub|we aux|be&PAST adv|just part|look-PRESP prep|at .
%gra:	1|7|XJCT 2|1|NJCT 3|2|POBJ 4|7|SUBJ 5|7|AUX 6|7|JCT 7|0|ROOT 8|11|DET
	9|10|MOD 10|11|MOD 11|7|OBJ 12|7|CONJ 13|12|COORD 14|13|OBJ 15|13|JCT
	16|18|DET 17|18|MOD 18|15|POBJ 19|23|LINK 20|23|SUBJ 21|23|AUX 22|23|AUX
	23|13|COMP 24|23|JCT 25|23|CONJ 26|27|JCT 27|25|COORD 28|30|DET 29|30|MOD
	30|31|SUBJ 31|27|COMP 32|33|QUANT 33|31|OBJ 34|36|SUBJ 35|36|COM
	36|31|COMP 37|36|OBJ 38|42|LINK 39|42|SUBJ 40|42|AUX 41|42|JCT 42|37|COMP
	43|42|JCT 44|7|PUNCT
*S1:	now there's another issue and that is (.) well what about the
	exchanges (.) and this is where parallel arrays get to be a little
	bit (.) awkward .
%mor:	adv|now pro:exist|there~cop|be&3S qn|another n|issue coord|and
	pro:rel|that cop|be&3S adv|well pro:int|what prep|about det:art|the
	n|exchange-PL coord|and pro:dem|this cop|be&3S pro:rel|where
	adj|parallel n|array-PL v|get prep|to cop|be det:art|a adj|little
	n|bit adj|awkward .
%gra:	1|3|JCT 2|3|SUBJ 3|0|ROOT 4|5|QUANT 5|3|PRED 6|5|CONJ 7|8|LINK
	8|6|COORD 9|8|JCT 10|16|LINK 11|16|JCT 12|13|DET 13|16|SUBJ 14|13|CONJ
	15|14|COORD 16|9|CPOBJ 17|20|LINK 18|19|MOD 19|20|SUBJ 20|16|CMOD 21|20|JCT
	22|21|POBJ 23|25|DET 24|25|MOD 25|20|JCT 26|25|POSTMOD 27|3|PUNCT
*S1:	(o)kay if you've got two arrays it's not really too bad but if you
	had three or four or five parallel arrays this could get to be (.)
	very inconvenient (.) because (.) you can compare in one array but
	you have to exchange in all the (.) parallel arrays .
%mor:	adj|okay comp|if pro:per|you~aux|have part|get&PASTP det:num|two
	n|array-PL pro:per|it~cop|be&3S neg|not adv|real&dadj-LY adv|too
	adj|bad conj|but conj|if pro:per|you v|have&PAST det:num|three
	coord|or det:num|four coord|or det:num|five adj|parallel v|array-3S
	det:dem|this mod|could v|get prep|to cop|be adv|very
	in#adj|convenient conj|because pro:per|you mod|can v|compare prep|in
	det:num|one n|array conj|but pro:per|you v|have inf|to v|exchange
	prep|in adv|all det:art|the adj|parallel n|array-PL .
%gra:	1|9|JCT 2|5|LINK 3|5|SUBJ 4|5|AUX 5|1|CMOD 6|7|QUANT 7|5|OBJ 8|9|SUBJ
	9|0|ROOT 10|9|NEG 11|13|JCT 12|13|JCT 13|9|PRED 14|9|CONJ 15|17|LINK
	16|17|SUBJ 17|14|COORD 18|17|OBJ 19|18|CONJ 20|19|COORD 21|24|LINK
	22|23|QUANT 23|24|JCT 24|17|CJCT 25|27|DET 26|27|AUX 27|24|COMP 28|27|JCT
	29|28|POBJ 30|31|JCT 31|27|CJCT 32|35|LINK 33|35|SUBJ 34|35|AUX 35|31|CJCT
	36|35|JCT 37|38|QUANT 38|36|POBJ 39|41|LINK 40|41|SUBJ 41|35|CJCT 42|43|INF
	43|41|COMP 44|43|JCT 45|48|JCT 46|48|DET 47|48|MOD 48|44|POBJ 49|9|PUNCT
*S1:	so you have to do the same exchange (.) with the same indexes in
	both arrays at the same time .
%mor:	co|so pro:per|you v|have inf|to v|do det:art|the adj|same
	n|exchange prep|with det:art|the adj|same n|index-PL prep|in qn|both
	n|array-PL prep|at det:art|the adj|same n|time .
%gra:	1|3|COM 2|3|SUBJ 3|0|ROOT 4|5|INF 5|3|COMP 6|8|DET 7|8|MOD 8|5|OBJ
	9|5|JCT 10|12|DET 11|12|MOD 12|9|POBJ 13|12|NJCT 14|15|QUANT 15|13|POBJ
	16|12|NJCT 17|19|DET 18|19|MOD 19|16|POBJ 20|3|PUNCT
*S1:	and what we just saw was that an exchange takes three lines (.) so
	this would take six lines (.) to exchange area codes sub start with
	(.) the smallest item and then (.) location sub start (.) with the
	same (.) index item in the locations array .
%mor:	coord|and pro:int|what pro:sub|we adv|just n|saw cop|be&PAST&13S
	comp|that det:art|a n|exchange v|take-3S det:num|three n|line-PL
	adv|so pro:dem|this mod|will&COND v|take det:num|six n|line-PL
	prep|to n|exchange n|area v|code-3S n|sub v|start prep|with
	det:art|the adj|small-SP n|item coord|and adv:tem|then
	n|locate&dv-TION n|sub v|start prep|with det:art|the adj|same
	n|index n|item prep|in det:art|the n|locate&dv-TION-PL n|array .
%gra:	1|6|LINK 2|5|OBJ 3|5|SUBJ 4|5|JCT 5|6|SUBJ 6|0|ROOT 7|10|LINK 8|9|DET
	9|10|SUBJ 10|6|CPRED 11|12|QUANT 12|10|OBJ 13|14|JCT 14|16|SUBJ 15|16|AUX
	16|10|COMP 17|18|QUANT 18|16|OBJ 19|18|NJCT 20|21|MOD 21|19|POBJ
	22|18|ENUM 23|24|SUBJ 24|22|COMP 25|24|JCT 26|28|DET 27|28|MOD 28|25|POBJ
	29|33|LINK 30|33|JCT 31|32|MOD 32|33|SUBJ 33|28|CMOD 34|33|JCT 35|38|DET
	36|37|MOD 37|38|MOD 38|34|POBJ 39|38|NJCT 40|42|DET 41|42|MOD 42|39|POBJ
	43|6|PUNCT
*S1:	so &-uh again for program six you've gotta do a sort (.) and if you
	choose to use parallel arrays this is (.) basically what you have to
	go through (.) in_order_to do it .
%mor:	adv|so adv|again prep|for n|program det:num|six
	pro:per|you~aux|have mod|got~inf|to v|do det:art|a n|sort coord|and
	conj|if pro:per|you v|choose inf|to v|use adv|parallel n|array-PL
	det:dem|this aux|be&3S adv|basic&dadj-AL-LY pro:int|what pro:per|you
	v|have inf|to v|go adv|through inf|in_order_to mod|do pro:per|it .
%gra:	1|2|JCT 2|10|JCT 3|2|JCT 4|3|POBJ 5|6|QUANT 6|10|SUBJ 7|10|AUX 8|10|AUX
	9|10|INF 10|0|ROOT 11|12|DET 12|10|OBJ 13|10|CONJ 14|16|LINK 15|16|SUBJ
	16|13|COORD 17|18|INF 18|16|COMP 19|20|JCT 20|18|OBJ 21|26|SUBJ
	22|26|AUX 23|26|JCT 24|26|LINK 25|26|SUBJ 26|20|CMOD 27|28|INF 28|26|COMP
	29|28|JCT 30|32|INF 31|32|AUX 32|28|OBJ 33|10|PUNCT
*S1:	&-uh it doesn't change the selection sort a whole lot you just need
	to plug in the extra code (.) to do the exchange in the other array
	.
%mor:	pro:per|it mod|do&3S~neg|not v|change det:art|the n|selection
	n|sort det:art|a adj|whole n|lot pro:per|you adv|just v|need inf|to
	v|plug prep|in det:art|the adj|extra n|code inf|to v|do det:art|the
	n|exchange prep|in det:art|the qn|other n|array .
%gra:	1|4|SUBJ 2|4|AUX 3|2|NEG 4|0|ROOT 5|7|DET 6|7|MOD 7|4|OBJ 8|10|DET
	9|10|MOD 10|7|APP 11|13|SUBJ 12|13|JCT 13|10|CMOD 14|15|INF 15|13|COMP
	16|15|JCT 17|19|DET 18|19|MOD 19|16|POBJ 20|21|INF 21|15|XJCT 22|23|DET
	23|21|OBJ 24|21|JCT 25|27|DET 26|27|QUANT 27|24|POBJ 28|4|PUNCT
*S1:	(o)kay well are there any questions about this ?
%mor:	co|okay n|well cop|be&PRES adv|there qn|any n|question-PL
	prep|about pro:dem|this ?
%gra:	1|2|COM 2|3|SUBJ 3|0|ROOT 4|3|JCT 5|6|QUANT 6|3|PRED 7|6|NJCT 8|7|POBJ
	9|3|PUNCT
*S1:	(0.5) (o)kay well let's start looking at (.) structs [: structures]
	(0.6) (o)kay so we're taking a (.) drastic turn of topics here away
	from arrays (.) and we'll start talking about this new data
	structure &-uh the struct [: structure] (.) is (.) extremely
	important in programming (.) so is the array (.) but with the struct
	[: structure] actually we (.) open up a whole new &-uh group of
	possibilities in programming .
%mor:	co|okay adv|well v|let~pro:obj|us v|start part|look-PRESP prep|at
	n|structure-PL adj|okay adv|so pro:sub|we~aux|be&PRES
	part|take-PRESP det:art|a adj|drastic n|turn prep|of n|topic-PL
	adv|here adv|away prep|from n|array-PL coord|and pro:sub|we~mod|will
	v|start part|talk-PRESP prep|about det:dem|this adj|new n|data
	n|structure det:art|the n|structure aux|be&3S adv|extreme&dadj-LY
	adj|important prep|in part|program-PRESP adv|so cop|be&3S
	det:art|the n|array conj|but prep|with det:art|the n|structure
	adv|actual&dadj-LY pro:sub|we v|open prep|up det:art|a adj|whole
	adj|new n|group prep|of n|possible&dadj-ITY-PL adv|in
	part|program-PRESP .
%gra:	1|3|COM 2|3|JCT 3|0|ROOT 4|3|OBJ 5|3|COMP 6|5|COMP 7|6|JCT 8|7|POBJ
	9|6|JCT 10|13|JCT 11|13|SUBJ 12|13|AUX 13|9|XMOD 14|16|DET 15|16|MOD
	16|13|OBJ 17|16|NJCT 18|17|POBJ 19|20|JCT 20|13|JCT 21|13|JCT 22|21|POBJ
	23|26|LINK 24|26|SUBJ 25|26|AUX 26|9|CJCT 27|26|COMP 28|41|JCT 29|32|DET
	30|32|MOD 31|32|MOD 32|41|JCT 33|34|DET 34|37|SUBJ 35|37|AUX 36|37|JCT
	37|41|SUBJ 38|37|JCT 39|38|POBJ 40|41|JCT 41|27|CJCT 42|43|DET 43|41|PRED
	44|50|LINK 45|50|JCT 46|47|DET 47|45|POBJ 48|50|JCT 49|50|SUBJ 50|43|CMOD
	51|50|JCT 52|55|DET 53|55|MOD 54|55|MOD 55|51|POBJ 56|55|NJCT 57|56|POBJ
	58|59|JCT 59|57|XMOD 60|3|PUNCT
*S1:	most dynamic data structures are set up with structs [: structures]
	&-uh if you look at (.) object oriented programming &-uh the basic
	unit there is called the class .
%mor:	qn|most adj|dynamic n|data n|structure-PL cop|be&PRES n|set adv|up
	prep|with n|structure-PL conj|if pro:per|you v|look prep|at n|object
	v|orient-PAST part|program-PRESP det:art|the adj|basic n|unit
	adv|there aux|be&3S v|call-PAST det:art|the n|class .
%gra:	1|4|QUANT 2|4|MOD 3|4|MOD 4|5|SUBJ 5|0|ROOT 6|5|PRED 7|6|NJCT 8|7|JCT
	9|8|POBJ 10|12|LINK 11|12|SUBJ 12|5|CJCT 13|12|JCT 14|13|POBJ 15|12|XJCT
	16|22|SUBJ 17|19|DET 18|19|MOD 19|16|OBJ 20|16|JCT 21|22|AUX 22|15|COMP
	23|24|DET 24|22|OBJ 25|5|PUNCT
*S1:	and the class is (.) essentially &-uh something that derived from
	(.) structs [: structures] .
%mor:	coord|and det:art|the n|class cop|be&3S adv|essential&dadj-LY
	pro:indef|something pro:rel|that v|derive-PAST prep|from
	n|structure-PL .
%gra:	1|4|LINK 2|3|DET 3|4|SUBJ 4|0|ROOT 5|4|JCT 6|5|POBJ 7|8|LINK 8|6|CMOD
	9|8|JCT 10|9|POBJ 11|4|PUNCT
*S1:	so once you understand structs [: structures] you're [/] you're
	getting a long way toward learning some more advanced (.)
	programming techniques .
%mor:	adv|so adv|once pro:per|you v|understand n|structure-PL
	pro:per|you~aux|be&PRES part|get-PRESP det:art|a adj|long n|way
	prep|toward part|learn-PRESP qn|some adv|more part|advance-PASTP
	part|program-PRESP n|technique-PL .
%gra:	1|2|JCT 2|4|LINK 3|4|SUBJ 4|0|ROOT 5|4|OBJ 6|8|SUBJ 7|8|AUX 8|4|XJCT
	9|11|DET 10|11|MOD 11|8|OBJ 12|8|JCT 13|12|POBJ 14|13|OBJ 15|16|JCT
	16|14|XMOD 17|16|XJCT 18|17|OBJ 19|4|PUNCT
*S1:	now an array we said was a list .
%mor:	adv|now det:art|a n|array pro:sub|we v|say&PAST cop|be&PAST&13S
	det:art|a n|list .
%gra:	1|6|JCT 2|3|DET 3|6|SUBJ 4|5|SUBJ 5|3|CMOD 6|0|ROOT 7|8|DET 8|6|PRED
	9|6|PUNCT
*S1:	we talked about &-uh the idea of abstract data types (.) and we
	said that people frequently use the word list (.) of something .
%mor:	pro:sub|we v|talk-PAST prep|about det:art|the n|idea prep|of
	n|abstract n|data n|type-PL coord|and pro:sub|we v|say&PAST
	comp|that n|person&PL adv|frequent&dadj-LY v|use det:art|the n|word
	n|list prep|of pro:indef|something .
%gra:	1|2|SUBJ 2|0|ROOT 3|2|JCT 4|5|DET 5|3|POBJ 6|5|NJCT 7|9|MOD 8|9|MOD
	9|6|POBJ 10|12|LINK 11|12|SUBJ 12|2|CJCT 13|16|LINK 14|16|SUBJ 15|16|JCT
	16|12|COMP 17|19|DET 18|19|MOD 19|16|OBJ 20|19|NJCT 21|20|POBJ 22|2|PUNCT
*S1:	and an array very naturally (.) fits that description .
%mor:	coord|and det:art|a n|array adv|very adv|natural&dadj-LY v|fit-3S
	det:dem|that n|description .
%gra:	1|6|LINK 2|3|DET 3|6|SUBJ 4|6|JCT 5|6|JCT 6|0|ROOT 7|8|DET 8|6|OBJ
	9|6|PUNCT
*S1:	a struct [: structure] really fits a record .
%mor:	det:art|a n|structure adv|real&dadj-LY v|fit-3S det:art|a n|record
	.
%gra:	1|2|DET 2|4|SUBJ 3|4|JCT 4|0|ROOT 5|6|DET 6|4|OBJ 7|4|PUNCT
*S1:	&-uh now people don't use that term quite as much but you do hear
	things like (.) a patient record or a student record &-uh if you go
	into the registrar you might wanna find out something about your (.)
	student record for example (.) and the struct [: structure] is a
	very natural data structure for (.) representing that sort of
	information .
%mor:	adv|now n|person&PL mod|do~neg|not v|use det:dem|that n|term
	adv|quite prep|as adv|much conj|but pro:per|you v|do v|hear
	n|thing-PL prep|like det:art|a adj|patient n|record coord|or
	det:art|a n|student n|record conj|if pro:per|you v|go prep|into
	det:art|the n|registrar pro:per|you mod|might v|want~inf|to v|find
	adv|out pro:indef|something prep|about det:poss|your n|student
	n|record prep|for ex#adj|ample coord|and det:art|the n|structure
	cop|be&3S det:art|a adv|very adj|natural n|data n|structure prep|for
	n:gerund|represent-PRESP adv|that n|sort prep|of n|inform&dv-TION .
%gra:	1|5|JCT 2|5|SUBJ 3|5|AUX 4|3|NEG 5|0|ROOT 6|7|DET 7|5|OBJ 8|5|JCT
	9|10|COORD 10|5|JCT 11|5|CONJ 12|13|SUBJ 13|11|COORD 14|13|OBJ 15|14|OBJ
	16|14|JCT 17|19|DET 18|19|MOD 19|16|POBJ 20|19|CONJ 21|23|DET 22|23|MOD
	23|20|COORD 24|26|LINK 25|26|SUBJ 26|32|CJCT 27|26|JCT 28|29|DET 29|27|POBJ
	30|32|SUBJ 31|32|AUX 32|13|CJCT 33|34|INF 34|32|COMP 35|46|JCT
	36|46|SUBJ 37|46|JCT 38|40|DET 39|40|MOD 40|46|SUBJ 41|40|NJCT 42|41|POBJ
	43|42|CONJ 44|45|DET 45|43|COORD 46|34|COMP 47|51|DET 48|49|JCT 49|51|MOD
	50|51|MOD 51|46|PRED 52|51|NJCT 53|52|POBJ 54|53|JCT 55|54|POBJ 56|55|NJCT
	57|56|POBJ 58|5|PUNCT
*S1:	now with a (.) student record you'd expect (.) quite a_lot_of
	information (.) it wouldn't all be the same data type we'd have
	names addresses &-uh phone numbers (.) we'd have grades &-uh GPAs
	for every semester (.) cumulative GPAs &-uh basically you know <what
	you> [/] what you see when you look at Wolverine Access .
%mor:	adv|now prep|with det:art|a n|student n|record
	pro:per|you~mod|genmod v|expect adv|quite qn|a_lot_of
	n|inform&dv-TION pro:per|it mod|will&COND~neg|not adv|all cop|be
	det:art|the adj|same n|data n|type pro:sub|we~mod|genmod aux|have
	n|name-PL v|address-3S n|phone v|number-3S pro:sub|we~mod|genmod
	aux|have v|grade-3S n:prop|GPAs prep|for qn|every n|semester
	adj|cumulative n:prop|GPAs adv|basic&dadj-AL-LY pro:per|you v|know
	pro:int|what pro:per|you v|see conj|when pro:per|you v|look prep|at
	n:prop|Wolverine n:prop|Access .
%gra:	1|8|JCT 2|8|JCT 3|5|DET 4|5|MOD 5|2|POBJ 6|8|SUBJ 7|8|AUX 8|31|CJCT
	9|8|JCT 10|11|QUANT 11|8|OBJ 12|16|SUBJ 13|16|AUX 14|13|NEG 15|16|JCT
	16|11|CMOD 17|20|DET 18|19|MOD 19|20|MOD 20|16|PRED 21|25|SUBJ 22|25|AUX
	23|25|AUX 24|25|SUBJ 25|20|CMOD 26|27|SUBJ 27|25|COMP 28|31|SUBJ 29|31|AUX
	30|31|AUX 31|0|ROOT 32|31|OBJ 33|32|NJCT 34|35|QUANT 35|33|POBJ 36|37|MOD
	37|35|APP 38|40|JCT 39|40|SUBJ 40|31|CJCT 41|43|LINK 42|43|SUBJ
	43|40|COMP 44|46|LINK 45|46|SUBJ 46|43|CJCT 47|46|JCT 48|47|POBJ 49|47|POBJ
	50|31|PUNCT
*S1:	now on the other hand an array we said (.) has a list of things
	they're all the same type .
%mor:	adv|now prep|on det:art|the qn|other n|hand det:art|a n|array
	pro:sub|we v|say&PAST v|have&3S det:art|a n|list prep|of n|thing-PL
	pro:sub|they~cop|be&PRES adv|all det:art|the adj|same n|type .
%gra:	1|10|JCT 2|10|JCT 3|5|DET 4|5|QUANT 5|2|POBJ 6|7|DET 7|10|SUBJ 8|9|SUBJ
	9|7|CMOD 10|16|CJCT 11|12|DET 12|10|OBJ 13|12|NJCT 14|13|POBJ
	15|16|SUBJ 16|0|ROOT 17|20|JCT 18|20|DET 19|20|MOD 20|16|PRED 21|16|PUNCT
*S1:	and now all of a sudden we're talking about (.) storing lots_of
	information that's all different types (.) so we need something a
	little more &-uh complicated than the array to actually set this up
	and do it in [/] &a in appropriate fashion .
%mor:	coord|and adv|now adv|all prep|of det:art|a adj|sudden
	pro:sub|we~aux|be&PRES part|talk-PRESP adv|about part|store-PRESP
	qn|lots_of n|inform&dv-TION pro:rel|that~cop|be&3S adv|all
	adj|different n|type-PL conj|so pro:sub|we v|need
	pro:indef|something det:art|a adj|little adv|more v|complicate-PAST
	prep|than det:art|the n|array inf|to adv|actual&dadj-LY n|set
	det:dem|this adv|up coord|and v|do pro:per|it prep|in
	adj|appropriate n|fashion .
%gra:	1|9|LINK 2|9|JCT 3|4|JCT 4|9|JCT 5|6|DET 6|4|POBJ 7|9|SUBJ 8|9|AUX
	9|0|ROOT 10|11|JCT 11|9|COMP 12|13|QUANT 13|11|OBJ 14|15|LINK 15|13|CMOD
	16|17|JCT 17|18|MOD 18|15|PRED 19|21|LINK 20|21|SUBJ 21|9|CJCT 22|21|OBJ
	23|24|DET 24|21|OBJ 25|26|JCT 26|24|CMOD 27|26|JCT 28|29|DET 29|27|POBJ
	30|32|INF 31|32|JCT 32|29|XMOD 33|34|DET 34|32|JCT 35|26|CONJ 36|35|COORD
	37|36|OBJ 38|36|JCT 39|40|MOD 40|38|POBJ 41|9|PUNCT
*S1:	so first of all let's look at the (.) similarities and differences
	here .
%mor:	adv|so adj|first prep|of qn|all v|let~pro:obj|us v|look prep|at
	det:art|the n|similarity-PL coord|and n|difference-PL adv|here .
%gra:	1|2|JCT 2|0|INCROOT 3|2|JCT 4|5|QUANT 5|3|POBJ 6|7|SUBJ 7|2|CMOD
	8|7|JCT 9|10|DET 10|8|POBJ 11|7|CONJ 12|11|COORD 13|12|NJCT 14|2|PUNCT
*S1:	okay they're both data structures (.) they're both &-uh what the
	book calls composite (.) data types (.) or structured is another
	word for that &-uh meaning that I've got a group of elements .
%mor:	co|okay pro:sub|they~cop|be&PRES qn|both n|data v|structure-3S
	pro:sub|they~cop|be&PRES qn|both pro:int|what det:art|the n|book
	v|call-3S adj|composite n|data n|type-PL coord|or v|structure-PAST
	aux|be&3S qn|another n|word prep|for det:dem|that n|meaning adv|that
	pro:sub|I~aux|have part|get&PASTP det:art|a n|group prep|of
	n|element-PL .
%gra:	1|3|COM 2|3|SUBJ 3|0|ROOT 4|5|QUANT 5|3|PRED 6|3|CPRED 7|8|SUBJ
	8|6|COMP 9|8|PRED 10|13|LINK 11|12|DET 12|13|SUBJ 13|9|COBJ 14|16|MOD 15|16|MOD
	16|13|OBJ 17|13|CONJ 18|17|COORD 19|21|AUX 20|21|QUANT 21|18|OBJ
	22|21|NJCT 23|24|DET 24|22|POBJ 25|28|JCT 26|28|SUBJ 27|28|AUX 28|21|XJCT
	29|30|DET 30|28|OBJ 31|30|NJCT 32|31|POBJ 33|3|PUNCT
*S1:	now (.) with the array we said we have to (.) fix the size (.) and
	that's true with a struct [: structure] also (.) we've got (.) a
	maximum number of elements (.) when we declare the struct
	[: structure] type (.) we establish that and it is set (.) for the
	rest of the program .
%mor:	adv|now prep|with det:art|the n|array pro:sub|we v|say&PAST
	pro:sub|we v|have inf|to v|fix det:art|the n|size coord|and
	pro:dem|that~cop|be&3S adj|true prep|with det:art|a n|structure
	adv|also pro:sub|we~aux|have part|get&PASTP det:art|a n|maximum
	n|number prep|of n|element-PL conj|when pro:sub|we v|declare
	det:art|the n|structure n|type pro:sub|we v|establish pro:dem|that
	coord|and pro:per|it cop|be&3S n|set prep|for det:art|the n|rest
	prep|of det:art|the n|program .
%gra:	1|6|JCT 2|1|JCT 3|4|DET 4|2|POBJ 5|6|SUBJ 6|0|ROOT 7|8|SUBJ 8|6|COMP
	9|10|INF 10|8|COMP 11|12|DET 12|10|OBJ 13|15|LINK 14|15|SUBJ 15|8|CJCT
	16|15|PRED 17|16|JCT 18|19|DET 19|17|POBJ 20|23|JCT 21|23|SUBJ 22|23|AUX
	23|15|CPRED 24|26|DET 25|26|MOD 26|23|OBJ 27|26|NJCT 28|27|POBJ 29|31|LINK
	30|31|SUBJ 31|36|CJCT 32|34|DET 33|34|MOD 34|31|OBJ 35|36|SUBJ
	36|23|CJCT 37|36|OBJ 38|40|LINK 39|40|SUBJ 40|36|CJCT 41|40|PRED 42|41|NJCT
	43|44|DET 44|42|POBJ 45|44|NJCT 46|47|DET 47|45|POBJ 48|6|PUNCT
*S1:	with the array now we get into the differences here &-uh all the
	elements (.) hafta be the same type .
%mor:	prep|with det:art|the n|array adv|now pro:sub|we v|get prep|into
	det:art|the n|difference-PL adv|here qn|all det:art|the n|element-PL
	mod|have~inf|to cop|be det:art|the adj|same n|type .
%gra:	1|6|JCT 2|3|DET 3|1|POBJ 4|6|JCT 5|6|SUBJ 6|0|ROOT 7|6|JCT 8|9|DET
	9|7|POBJ 10|16|JCT 11|13|QUANT 12|13|DET 13|16|SUBJ 14|16|AUX 15|16|INF
	16|6|CJCT 17|19|DET 18|19|MOD 19|16|PRED 20|6|PUNCT
*S1:	so I could have a list of (.) ints [: integers] (.) or a list of
	(.) strings (.) but I can't have a list of ints [: integers] and
	strings .
%mor:	co|so pro:sub|I mod|could v|have det:art|a n|list prep|of
	n|integer-PL coord|or det:art|a n|list prep|of n|string-PL conj|but
	pro:sub|I mod|can~neg|not v|have det:art|a n|list prep|of
	n|integer-PL coord|and n|string-PL .
%gra:	1|4|COM 2|4|SUBJ 3|4|AUX 4|0|ROOT 5|6|DET 6|4|OBJ 7|6|NJCT 8|7|POBJ
	9|6|CONJ 10|11|DET 11|9|COORD 12|11|NJCT 13|12|POBJ 14|18|LINK 15|18|SUBJ
	16|18|AUX 17|16|NEG 18|4|CJCT 19|20|DET 20|18|OBJ 21|20|NJCT 22|21|POBJ
	23|22|CONJ 24|23|COORD 25|4|PUNCT
*S1:	(o)kay for that I could (.) actually set up an array of structs
	[: structures] and then &-uh I could have (.) a list of mixed types
	but I'd hafta use both of these data structures (.) to set that up .
%mor:	co|okay prep|for adv|that pro:sub|I mod|could adv|actual&dadj-LY
	n|set prep|up det:art|a n|array prep|of n|structure-PL coord|and
	adv:tem|then pro:sub|I mod|could v|have det:art|a n|list prep|of
	v|mix-PAST n|type-PL conj|but pro:sub|I~mod|genmod mod|have~inf|to
	v|use qn|both prep|of det:dem|these n|data v|structure-3S inf|to
	v|set&ZERO pro:dem|that adv|up .
%gra:	1|7|COM 2|7|JCT 3|2|POBJ 4|7|SUBJ 5|7|AUX 6|7|JCT 7|17|JCT 8|7|NJCT
	9|10|DET 10|8|POBJ 11|10|NJCT 12|11|POBJ 13|7|CONJ 14|13|COORD 15|17|SUBJ
	16|17|AUX 17|0|ROOT 18|19|DET 19|17|OBJ 20|19|NJCT 21|20|POBJ 22|21|OBJ
	23|17|CONJ 24|28|SUBJ 25|28|AUX 26|28|AUX 27|28|INF 28|23|COORD
	29|33|QUANT 30|33|JCT 31|32|DET 32|30|POBJ 33|28|COMP 34|35|INF 35|33|COMP
	36|35|OBJ 37|35|JCT 38|17|PUNCT
*S1:	arrays by themselves wouldn't do it .
%mor:	n|array-PL prep|by pro:refl|themselves mod|will&COND~neg|not v|do
	pro:per|it .
%gra:	1|6|SUBJ 2|1|NJCT 3|2|POBJ 4|6|AUX 5|4|NEG 6|0|ROOT 7|6|OBJ 8|6|PUNCT
*S1:	now (.) clearly this is a big advantage (.) elements can be
	different types in (.) structs [: structures] .
%mor:	adv|now adv|clear&dadj-LY pro:dem|this cop|be&3S det:art|a adj|big
	n|advantage n|element-PL mod|can cop|be adj|different n|type-PL
	prep|in n|structure-PL .
%gra:	1|3|JCT 2|3|JCT 3|4|SUBJ 4|0|ROOT 5|8|DET 6|7|MOD 7|8|MOD 8|10|SUBJ
	9|10|AUX 10|4|PRED 11|12|MOD 12|10|PRED 13|10|JCT 14|13|POBJ 15|4|PUNCT
*S1:	so that's where we can (.) do the combination of all these
	different types of data .
%mor:	co|so pro:dem|that~cop|be&3S pro:int|where pro:sub|we mod|can v|do
	det:art|the n|combine&dv-TION prep|of qn|all det:dem|these
	adj|different n|type-PL prep|of n|data .
%gra:	1|3|COM 2|3|SUBJ 3|0|ROOT 4|7|LINK 5|7|SUBJ 6|7|AUX 7|3|CPRED 8|9|DET
	9|7|OBJ 10|9|NJCT 11|14|QUANT 12|14|DET 13|14|MOD 14|10|POBJ 15|14|NJCT
	16|15|POBJ 17|3|PUNCT
*S1:	(o)kay another (.) item that we talked about with arrays is that we
	can (.) access any element (.) at any time using the index (.) we've
	got direct access to the elements that way (.) and they're all
	numbered and they're in order (.) the order never changes .
%mor:	co|okay qn|another n|item pro:rel|that pro:sub|we v|talk-PAST
	adv|about prep|with n|array-PL cop|be&3S comp|that pro:sub|we
	mod|can v|access qn|any n|element prep|at qn|any n|time
	part|use-PRESP det:art|the n|index pro:sub|we~aux|have
	part|get&PASTP adj|direct n|access prep|to det:art|the n|element-PL
	det:dem|that n|way coord|and pro:sub|they~aux|be&PRES post|all
	part|number-PASTP coord|and pro:sub|they~cop|be&PRES prep|in n|order
	det:art|the n|order adv|never n|change-PL .
%gra:	1|3|COM 2|3|QUANT 3|10|SUBJ 4|6|LINK 5|6|SUBJ 6|3|CMOD 7|6|JCT 8|6|JCT
	9|8|POBJ 10|0|ROOT 11|14|LINK 12|14|SUBJ 13|14|AUX 14|10|ROOT
	15|16|QUANT 16|14|OBJ 17|14|JCT 18|19|QUANT 19|17|POBJ 20|14|XJCT 21|22|DET
	22|20|OBJ 23|25|SUBJ 24|25|AUX 25|20|ROOT 26|27|MOD 27|25|OBJ 28|27|NJCT
	29|30|DET 30|28|POBJ 31|32|DET 32|27|ROOT 33|36|LINK 34|36|SUBJ 35|36|AUX
	36|32|ROOT 37|36|ROOT 38|40|LINK 39|40|SUBJ 40|37|CJCT 41|40|JCT 42|41|POBJ
	43|44|DET 44|46|MOD 45|46|MOD 46|40|PRED 47|37|PUNCT
*S1:	(o)kay at least the order of the basic array structure .
%mor:	co|okay prep|at adj|least det:art|the n|order prep|of det:art|the
	adj|basic n|array n|structure .
%gra:	1|0|INCROOT 2|1|JCT 3|2|POBJ 4|5|DET 5|2|POBJ 6|5|NJCT 7|10|DET
	8|10|MOD 9|10|MOD 10|6|POBJ 11|1|PUNCT
*S1:	so index is ranging from zero up to (.) and then N minus one .
%mor:	co|so n|index aux|be&3S part|range-PRESP prep|from n|zero adv|up
	prep|to coord|and adv:tem|then n:prop|N prep|minus pro:indef|one .
%gra:	1|4|COM 2|4|SUBJ 3|4|AUX 4|0|ROOT 5|4|JCT 6|5|POBJ 7|4|JCT 8|4|JCT
	9|8|CONJ 10|11|JCT 11|9|COORD 12|11|NJCT 13|12|POBJ 14|4|PUNCT
*S1:	once we define the array we can't (.) alter that .
%mor:	adv|once pro:sub|we v|define det:art|the n|array pro:sub|we
	mod|can~neg|not v|alter pro:dem|that .
%gra:	1|3|LINK 2|3|SUBJ 3|9|CJCT 4|5|DET 5|3|OBJ 6|9|SUBJ 7|9|AUX 8|7|NEG
	9|0|ROOT 10|9|OBJ 11|9|PUNCT
*S1:	now with structs [: structures] we don't have this (.) same (.)
	structure we don't have indexes (.) we don't have numbers (.) and
	we'll access these things in a very different way .
%mor:	adv|now prep|with n|structure-PL pro:sub|we mod|do~neg|not v|have
	pro:dem|this adj|same n|structure pro:sub|we mod|do~neg|not v|have
	n|index-PL pro:sub|we mod|do~neg|not v|have n|number-PL coord|and
	pro:sub|we~mod|will v|access det:dem|these n|thing-PL prep|in
	det:art|a adv|very adj|different n|way .
%gra:	1|7|JCT 2|7|JCT 3|2|POBJ 4|7|SUBJ 5|7|AUX 6|5|NEG 7|0|ROOT 8|10|DET
	9|10|MOD 10|7|OBJ 11|14|SUBJ 12|14|AUX 13|12|NEG 14|10|CMOD 15|14|OBJ
	16|19|SUBJ 17|19|AUX 18|17|NEG 19|10|CMOD 20|19|OBJ 21|24|LINK 22|24|SUBJ
	23|24|AUX 24|19|CJCT 25|26|DET 26|24|OBJ 27|24|JCT 28|31|DET 29|30|JCT
	30|31|MOD 31|27|POBJ 32|7|PUNCT
*S1:	we'll access the (.) elements in a struct [: structure] and they're
	called members (.) with (.) this new operator (.) basically you type
	a period on the keyboard (.) and you get the member operator (.) and
	then we'll use the name .
%mor:	pro:sub|we~mod|will v|access det:art|the n|element-PL prep|in
	det:art|a n|structure coord|and pro:sub|they~aux|be&PRES
	part|call-PASTP n|member-PL prep|with det:dem|this adj|new
	n|operator adv|basic&dadj-AL-LY pro:per|you v|type det:art|a
	n|period prep|on det:art|the n|+n|key+n|board coord|and pro:per|you
	v|get det:art|the n|member n|operator coord|and adv:tem|then
	pro:sub|we~mod|will v|use det:art|the n|name .
%gra:	1|3|SUBJ 2|3|AUX 3|0|ROOT 4|5|DET 5|3|OBJ 6|3|JCT 7|8|DET 8|6|POBJ
	9|12|LINK 10|12|SUBJ 11|12|AUX 12|3|CJCT 13|12|OBJ 14|12|JCT 15|17|DET
	16|17|MOD 17|14|POBJ 18|20|JCT 19|20|SUBJ 20|12|CJCT 21|22|DET 22|20|OBJ
	23|20|JCT 24|25|DET 25|23|POBJ 26|28|LINK 27|28|SUBJ 28|20|CJCT 29|31|DET
	30|31|MOD 31|28|OBJ 32|36|LINK 33|36|JCT 34|36|SUBJ 35|36|AUX 36|31|CMOD
	37|38|DET 38|36|OBJ 39|3|PUNCT
*S1:	so with arrays we use (.) a subscript and an index (.) a numeric
	value (.) and with structs [: structures] we use the dot and then
	(.) the name of the element in the struct [: structure] that we set
	up +...
%mor:	adv|so prep|with n|array-PL pro:sub|we v|use det:art|a sub#n|script
	coord|and det:art|a n|index det:art|a adj|numeric n|value coord|and
	prep|with n|structure-PL pro:sub|we v|use det:art|the n|dot
	coord|and adv:tem|then det:art|the n|name prep|of det:art|the
	n|element prep|in det:art|the n|structure pro:rel|that pro:sub|we
	v|set&ZERO adv|up +...
%gra:	1|2|JCT 2|5|JCT 3|2|POBJ 4|5|SUBJ 5|18|CJCT 6|7|DET 7|5|OBJ 8|7|CONJ
	9|10|DET 10|8|COORD 11|13|DET 12|13|MOD 13|10|APP 14|7|CONJ 15|14|COORD
	16|15|POBJ 17|18|SUBJ 18|0|ROOT 19|20|DET 20|18|OBJ 21|18|CONJ 22|21|COORD
	23|24|DET 24|22|OBJ 25|24|NJCT 26|27|DET 27|25|POBJ 28|27|NJCT
	29|30|DET 30|28|POBJ 31|33|LINK 32|33|SUBJ 33|30|CMOD 34|33|JCT 35|18|PUNCT
*S1:	(o)kay so let's look at some (.) examples here (0.5) and we'll go
	back to MIRLYN (.) and we'll imagine that we're writing (.) a small
	version of MIRLYN .
%mor:	co|okay co|so v|let~pro:obj|us v|look prep|at qn|some n|example-PL
	adv|here coord|and pro:sub|we~mod|will v|go adv|back prep|to
	n:prop|MIRLYN coord|and pro:sub|we~mod|will v|imagine comp|that
	pro:sub|we~aux|be&PRES part|write-PRESP det:art|a adj|small
	n|version prep|of n:prop|MIRLYN .
%gra:	1|3|COM 2|3|COM 3|0|ROOT 4|3|OBJ 5|3|COMP 6|5|JCT 7|8|QUANT 8|6|POBJ
	9|5|JCT 10|13|LINK 11|13|SUBJ 12|13|AUX 13|5|CJCT 14|13|JCT 15|13|JCT
	16|15|POBJ 17|20|LINK 18|20|SUBJ 19|20|AUX 20|13|CJCT 21|24|LINK 22|24|SUBJ
	23|24|AUX 24|20|COMP 25|27|DET 26|27|MOD 27|24|OBJ 28|27|NJCT 29|28|POBJ
	30|3|PUNCT
*S1:	(o)kay so we're gonna set up a book struct [: structure] (.) a book
	record (.) and we'll put a few of the major items in it so that we
	can look at how (.) we could set that up in a real program .
%mor:	co|okay adv|so pro:sub|we~aux|be&PRES part|go-PRESP~inf|to
	v|set&ZERO prep|up det:art|a n|book n|structure det:art|a n|book
	n|record coord|and pro:sub|we~mod|will v|put&ZERO det:art|a qn|few
	prep|of det:art|the adj|major n|item-PL prep|in pro:per|it adv|so
	pro:rel|that pro:sub|we mod|can v|look prep|at pro:int|how
	pro:sub|we mod|could v|set&ZERO pro:dem|that adv|up prep|in
	det:art|a adj|real n|program .
%gra:	1|5|COM 2|5|JCT 3|5|SUBJ 4|5|AUX 5|0|ROOT 6|7|INF 7|5|COMP 8|7|JCT
	9|11|DET 10|11|MOD 11|8|POBJ 12|14|DET 13|14|MOD 14|7|OBJ 15|18|LINK
	16|18|SUBJ 17|18|AUX 18|14|CMOD 19|20|DET 20|18|OBJ 21|20|NJCT 22|24|DET
	23|24|MOD 24|21|POBJ 25|24|NJCT 26|25|POBJ 27|18|JCT 28|31|LINK 29|31|SUBJ
	30|31|AUX 31|27|CMOD 32|31|JCT 33|36|LINK 34|36|SUBJ 35|36|AUX 36|32|CPOBJ
	37|36|OBJ 38|36|JCT 39|36|JCT 40|42|DET 41|42|MOD 42|39|POBJ 43|5|PUNCT
*S1:	so first of all [/] all of this would be global &-uh we said that
	type definitions typically (.) are put in a global position (.) in
	the program (.) and of_course that's so the rest of the program can
	access the type .
%mor:	adv|so adj|first prep|of pro:indef|all prep|of pro:dem|this
	mod|will&COND cop|be adj|global pro:sub|we v|say&PAST adv|that
	n|type n|definition-PL adv|typical&dadj-LY aux|be&PRES
	part|put&PASTP prep|in det:art|a adj|global n|position prep|in
	det:art|the n|program coord|and co|of_course pro:dem|that~cop|be&3S
	co|so det:art|the n|rest prep|of det:art|the n|program mod|can
	v|access det:art|the n|type .
%gra:	1|2|JCT 2|11|JCT 3|8|LINK 4|8|SUBJ 5|4|NJCT 6|5|POBJ 7|8|AUX 8|2|CMOD
	9|8|PRED 10|11|SUBJ 11|0|ROOT 12|13|JCT 13|14|MOD 14|11|OBJ 15|17|JCT
	16|17|AUX 17|14|XMOD 18|17|JCT 19|21|DET 20|21|MOD 21|18|POBJ 22|21|NJCT
	23|24|DET 24|22|POBJ 25|28|LINK 26|28|COM 27|28|SUBJ 28|14|CJCT 29|36|COM
	30|31|DET 31|36|SUBJ 32|31|NJCT 33|34|DET 34|32|POBJ 35|36|AUX
	36|28|CPRED 37|38|DET 38|36|OBJ 39|11|PUNCT
*S1:	and we also know that we can't cause bugs in a program (.) by
	declaring (.) constants and types globally .
%mor:	coord|and pro:sub|we adv|also v|know comp|that pro:sub|we
	mod|can~neg|not n|cause n|bug-PL prep|in det:art|a n|program prep|by
	part|declare-PRESP n|constant-PL coord|and v|type-3S
	adv|global&dadj-LY .
%gra:	1|4|LINK 2|4|SUBJ 3|4|JCT 4|0|ROOT 5|9|LINK 6|9|SUBJ 7|9|AUX 8|7|NEG
	9|10|MOD 10|4|OBJ 11|10|NJCT 12|13|DET 13|11|POBJ 14|4|JCT 15|14|POBJ
	16|15|OBJ 17|18|LINK 18|4|CJCT 19|18|JCT 20|4|PUNCT
*S1:	so we would put this at the beginning of the program in front of
	main (.) and (.) first of all I'll set up a constant for the (.)
	string size (.) and we're gonna have actually authors and titles (.)
	in the book struct [: structure] .
%mor:	co|so pro:sub|we mod|will&COND v|put&ZERO pro:dem|this prep|at
	det:art|the n|beginning prep|of det:art|the n|program prep|in
	n|front prep|of adj|main coord|and adv|first prep|of qn|all
	pro:sub|I~mod|will v|set&ZERO prep|up det:art|a n|constant prep|for
	det:art|the n|string n|size coord|and pro:sub|we~aux|be&PRES
	part|go-PRESP~inf|to v|have adv|actual&dadj-LY n|author-PL coord|and
	n|title-PL prep|in det:art|the n|book n|structure .
%gra:	1|4|COM 2|4|SUBJ 3|4|AUX 4|0|ROOT 5|4|OBJ 6|4|JCT 7|8|DET 8|6|POBJ
	9|8|NJCT 10|11|DET 11|9|POBJ 12|11|NJCT 13|12|POBJ 14|13|NJCT 15|14|POBJ
	16|22|LINK 17|22|JCT 18|22|JCT 19|20|QUANT 20|22|SUBJ 21|22|AUX 22|15|CJCT
	23|22|JCT 24|25|DET 25|23|POBJ 26|22|JCT 27|29|DET 28|29|MOD 29|26|POBJ
	30|33|LINK 31|33|SUBJ 32|33|AUX 33|22|CJCT 34|35|INF 35|33|COMP
	36|35|JCT 37|36|POBJ 38|37|CONJ 39|38|COORD 40|39|NJCT 41|43|DET 42|43|MOD
	43|40|POBJ 44|4|PUNCT
*S1:	so I'm allowing forty one characters for each one of those (.) and
	of_course the [/] the one is for the (.) null character .
%mor:	adv|so pro:sub|I~aux|be&1S part|allow-PRESP det:num|forty
	det:num|one n|character-PL prep|for qn|each pro:indef|one prep|of
	pro:dem|those coord|and co|of_course det:art|the pro:indef|one
	cop|be&3S prep|for det:art|the adj|null n|character .
%gra:	1|4|JCT 2|4|SUBJ 3|4|AUX 4|0|ROOT 5|7|QUANT 6|7|QUANT 7|4|OBJ 8|4|JCT
	9|10|QUANT 10|8|POBJ 11|10|NJCT 12|11|POBJ 13|17|LINK 14|17|COM 15|16|DET
	16|17|SUBJ 17|4|CJCT 18|17|JCT 19|21|DET 20|21|MOD 21|18|POBJ
	22|4|PUNCT
*S1:	so forty characters in a title (.) or forty in the author's name .
%mor:	adv|so det:num|forty n|character-PL prep|in det:art|a n|title
	coord|or det:num|forty prep|in det:art|the adj|author&dn-POSS n|name
	.
%gra:	1|2|JCT 2|3|QUANT 3|0|INCROOT 4|3|NJCT 5|6|DET 6|4|POBJ 7|3|CONJ
	8|7|COORD 9|8|JCT 10|12|DET 11|12|MOD 12|9|POBJ 13|3|PUNCT
*S1:	that sounds like (.) enough to avoid any kind of problems (.) with
	input and range errors .
%mor:	adv|that v|sound-3S prep|like adv|enough inf|to v|avoid qn|any
	n|kind prep|of n|problem-PL prep|with n|input coord|and n|range
	n|error-PL .
%gra:	1|2|JCT 2|0|ROOT 3|2|JCT 4|3|POBJ 5|6|INF 6|4|COMP 7|8|QUANT 8|6|OBJ
	9|8|NJCT 10|9|POBJ 11|6|JCT 12|11|POBJ 13|12|CONJ 14|15|MOD 15|13|COORD
	16|2|PUNCT
*S1:	now the type for the string here is actually (.) course this
	typedef@q &-uh name string is the generic (.) name that I'll use for
	both the authors and the titles (.) and then (.) we used a constant
	there of_course to set up the size .
%mor:	adv|now det:art|the n|type prep|for det:art|the n|string
	pro:exist|here cop|be&3S adv|actual&dadj-LY v|course det:dem|this
	meta|typedef n|name n|string cop|be&3S det:art|the adj|generic
	n|name comp|that pro:sub|I~mod|will v|use prep|for post|both
	det:art|the n|author-PL coord|and det:art|the n|title-PL coord|and
	adv:tem|then pro:sub|we v|use-PAST det:art|a n|constant adv|there
	co|of_course prep|to n|set prep|up det:art|the n|size .
%gra:	1|10|JCT 2|3|DET 3|10|SUBJ 4|3|NJCT 5|6|DET 6|4|POBJ 7|10|SUBJ 8|10|AUX
	9|10|JCT 10|0|ROOT 11|14|DET 12|14|MOD 13|14|MOD 14|15|SUBJ 15|10|ROOT
	16|18|DET 17|18|MOD 18|15|PRED 19|22|LINK 20|22|SUBJ 21|22|AUX
	22|18|ROOT 23|22|JCT 24|23|POBJ 25|26|DET 26|24|INCROOT 27|26|CONJ 28|29|DET
	29|27|COORD 30|26|CONJ 31|30|COORD 32|33|SUBJ 33|26|ROOT 34|35|DET 35|33|OBJ
	36|33|JCT 37|33|INCROOT 38|37|INCROOT 39|38|POBJ 40|38|JCT 41|42|DET
	42|40|POBJ 43|38|PUNCT
*S1:	so we've established (.) the information that we need to declare
	the book record (.) and actually the [/] the definition of the book
	record starts here at the word struct [: structure] (.) and then you
	can see it has braces and closing (.) the (.) body of the structure
	(.) and what I'm defining inside is the members .
%mor:	adv|so pro:sub|we~aux|have part|establish-PASTP det:art|the
	n|inform&dv-TION comp|that pro:sub|we v|need inf|to v|declare
	det:art|the n|book n|record coord|and adv|actual&dadj-LY det:art|the
	n|definition prep|of det:art|the n|book n|record v|start-3S adv|here
	prep|at det:art|the n|word n|structure coord|and adv:tem|then
	pro:per|you mod|can v|see pro:per|it aux|have&3S n|brace-PL
	coord|and part|close-PRESP det:art|the n|body prep|of det:art|the
	n|structure coord|and pro:int|what pro:sub|I~aux|be&1S
	part|define-PRESP n|inside cop|be&3S det:art|the n|member-PL .
%gra:	1|4|JCT 2|4|SUBJ 3|4|AUX 4|0|ROOT 5|6|DET 6|4|OBJ 7|9|LINK 8|9|SUBJ
	9|4|CJCT 10|11|INF 11|9|COMP 12|14|DET 13|14|MOD 14|11|OBJ 15|23|LINK
	16|23|JCT 17|18|DET 18|23|SUBJ 19|18|NJCT 20|22|DET 21|22|MOD 22|19|POBJ
	23|11|CJCT 24|23|JCT 25|23|JCT 26|28|DET 27|28|MOD 28|25|POBJ 29|33|LINK
	30|33|JCT 31|33|SUBJ 32|33|AUX 33|23|CJCT 34|36|SUBJ 35|36|AUX 36|33|OBJ
	37|36|CONJ 38|37|COORD 39|40|DET 40|38|OBJ 41|40|NJCT 42|43|DET 43|41|POBJ
	44|50|LINK 45|48|LINK 46|48|SUBJ 47|48|AUX 48|50|PRED 49|50|SUBJ
	50|36|CJCT 51|52|DET 52|50|PRED 53|4|PUNCT
*S1:	so this struct [: structure] has four (.) members in it (.) they
	are the title (.) the author (.) the number of copies (.) of the
	book (.) and then all taken out .
%mor:	adv|so det:dem|this n|structure v|have&3S det:num|four n|member-PL
	prep|in pro:per|it pro:sub|they cop|be&PRES det:art|the n|title
	det:art|the n|author det:art|the n|number prep|of n|copy-PL prep|of
	det:art|the n|book coord|and adv:tem|then adv|all part|take&PASTP
	adv|out .
%gra:	1|9|JCT 2|3|DET 3|1|POBJ 4|3|CMOD 5|6|QUANT 6|4|OBJ 7|4|JCT 8|7|POBJ
	9|10|SUBJ 10|0|ROOT 11|12|DET 12|10|PRED 13|14|DET 14|12|CMOD 15|16|DET
	16|14|OBJ 17|16|NJCT 18|17|POBJ 19|18|NJCT 20|21|DET 21|19|POBJ 22|16|CONJ
	23|25|JCT 24|25|JCT 25|22|COORD 26|25|JCT 27|10|PUNCT
*S1:	so the title and the author are pretty obvious (.) what they are
	&-uh the number of copies is how many does the library own (.) and
	then all taken out would represent &-uh the obvious also (.) are
	they all taken out or is there something available (.) that you can
	get a copy of .
%mor:	co|so det:art|the n|title coord|and det:art|the n|author
	cop|be&PRES adv|pretty adj|obvious pro:int|what pro:sub|they
	cop|be&PRES det:art|the n|number prep|of n|copy-PL cop|be&3S
	pro:int|how qn|many mod|do&3S det:art|the n|library adj|own
	coord|and adv:tem|then adv|all part|take&PASTP adv|out mod|will&COND
	v|represent det:art|the adj|obvious adv|also cop|be&PRES
	pro:sub|they post|all part|take&PASTP adv|out coord|or cop|be&3S
	adv|there pro:indef|something adj|avail&dv-ABLE comp|that
	pro:per|you mod|can v|get det:art|a n|copy prep|of .
%gra:	1|3|COM 2|3|DET 3|7|SUBJ 4|3|CONJ 5|6|DET 6|4|COORD 7|0|ROOT 8|9|JCT
	9|7|PRED 10|12|LINK 11|12|SUBJ 12|7|ROOT 13|14|DET 14|17|SUBJ 15|14|NJCT
	16|15|POBJ 17|12|ROOT 18|22|LINK 19|22|QUANT 20|22|AUX 21|22|DET
	22|30|SUBJ 23|30|JCT 24|27|LINK 25|27|JCT 26|27|JCT 27|30|SUBJ 28|27|JCT
	29|30|AUX 30|17|ROOT 31|32|DET 32|30|OBJ 33|34|JCT 34|32|ROOT 35|37|SUBJ
	36|37|AUX 37|34|ROOT 38|37|JCT 39|40|LINK 40|38|CPOBJ 41|40|JCT 42|41|POBJ
	43|42|PRED 44|47|LINK 45|47|SUBJ 46|47|AUX 47|43|CMOD 48|49|DET 49|47|OBJ
	50|49|NJCT 51|37|PUNCT
*S1:	now if you just look at this if you take off these braces here (.)
	this looks just like variable declarations that we've done earlier
	(.) in the course .
%mor:	adv|now conj|if pro:per|you adv|just v|look prep|at pro:dem|this
	conj|if pro:per|you v|take prep|off det:dem|these n|brace-PL
	adv|here pro:dem|this v|look-3S adv|just prep|like n|variable
	n|declare&dv-TION-PL adv|that pro:sub|we~aux|have part|do&PASTP
	adj|early-CP prep|in det:art|the n|course .
%gra:	1|16|JCT 2|5|LINK 3|5|SUBJ 4|5|JCT 5|16|CJCT 6|5|JCT 7|6|POBJ 8|10|LINK
	9|10|SUBJ 10|16|CJCT 11|10|JCT 12|13|DET 13|11|POBJ 14|10|JCT
	15|16|SUBJ 16|0|ROOT 17|16|JCT 18|16|JCT 19|20|MOD 20|18|POBJ 21|24|JCT
	22|24|SUBJ 23|24|AUX 24|16|COMP 25|24|JCT 26|25|JCT 27|28|DET 28|26|POBJ
	29|16|PUNCT
*S1:	the difference being that they're inside a struct [: structure] .
%mor:	det:art|the n|difference aux|be-PRESP comp|that
	pro:sub|they~cop|be&PRES prep|inside det:art|a n|structure .
%gra:	1|2|DET 2|6|SUBJ 3|6|AUX 4|3|PRED 5|6|SUBJ 6|0|ROOT 7|6|JCT 8|9|DET
	9|7|POBJ 10|6|PUNCT
*S1:	so I have (.) two strings (.) an int [: integer] (.) and a bool
	[: boolean] (.) and they're being put together here as a unit (.) in
	a data structure that (.) contains all four of them .
%mor:	co|so pro:sub|I v|have det:num|two n|string-PL det:art|a n|integer
	coord|and det:art|a n|boolean coord|and pro:sub|they~aux|be&PRES
	part|be-PRESP v|put&ZERO adv|together pro:exist|here prep|as
	det:art|a n|unit prep|in det:art|a n|data n|structure pro:rel|that
	v|contain-3S adv|all det:num|four prep|of pro:obj|them .
%gra:	1|3|COM 2|3|SUBJ 3|0|ROOT 4|5|QUANT 5|3|OBJ 6|7|DET 7|5|APP 8|5|CONJ
	9|10|DET 10|8|COORD 11|3|CONJ 12|14|SUBJ 13|14|AUX 14|11|COORD 15|14|OBJ
	16|14|JCT 17|14|PRED 18|20|COORD 19|20|DET 20|17|OBJ 21|20|NJCT 22|24|DET
	23|24|MOD 24|21|POBJ 25|26|LINK 26|24|CMOD 27|28|JCT 28|26|COMP
	29|28|JCT 30|29|POBJ 31|3|PUNCT
*S1:	so as far as the syntax for writing (.) the interior here you just
	use what you're (.) accustomed to for declaring variables (.) and
	then keep in mind that these are all components in (.) this overall
	data type .
%mor:	adv|so adv|as adv|far conj|as det:art|the n|syntax prep|for
	n:gerund|write-PRESP det:art|the n|interior adv|here pro:per|you
	adj|just v|use pro:int|what pro:per|you~aux|be&PRES
	part|accustom-PASTP inf|to prep|for n:gerund|declare-PRESP
	n|variable-PL coord|and adv:tem|then v|keep prep|in n|mind comp|that
	pro:dem|these cop|be&PRES adv|all n|component-PL prep|in
	det:dem|this adj|overall n|data n|type .
%gra:	1|2|JCT 2|3|COORD 3|14|JCT 4|6|COORD 5|6|DET 6|14|CJCT 7|6|NJCT
	8|7|POBJ 9|10|DET 10|8|OBJ 11|14|JCT 12|14|SUBJ 13|14|JCT 14|0|ROOT 15|18|LINK
	16|18|SUBJ 17|18|AUX 18|14|COMP 19|20|INF 20|18|COMP 21|22|MOD
	22|20|POBJ 23|25|LINK 24|25|JCT 25|20|ROOT 26|25|JCT 27|26|POBJ 28|30|LINK
	29|30|SUBJ 30|25|COMP 31|32|JCT 32|30|PRED 33|30|JCT 34|37|DET 35|37|MOD
	36|37|MOD 37|33|POBJ 38|25|PUNCT
*S1:	now one thing to notice here is these are not variable (.)
	declarations .
%mor:	adv|now pro:indef|one n|thing prep|to n|notice adv|here cop|be&3S
	pro:dem|these cop|be&PRES neg|not n|variable n|declare&dv-TION-PL .
%gra:	1|3|JCT 2|3|SUBJ 3|7|SUBJ 4|3|NJCT 5|4|POBJ 6|7|JCT 7|0|ROOT 8|9|SUBJ
	9|7|PRED 10|9|NEG 11|12|MOD 12|9|PRED 13|7|PUNCT
*S1:	(o)kay I actually haven't declared any variables yet .
%mor:	co|okay pro:sub|I adv|actual&dadj-LY aux|have~neg|not
	part|declare-PASTP qn|any n|variable-PL adv|yet .
%gra:	1|6|COM 2|6|SUBJ 3|6|JCT 4|6|AUX 5|4|NEG 6|0|ROOT 7|8|QUANT 8|6|OBJ
	9|6|JCT 10|6|PUNCT
*S1:	this is a type definition .
%mor:	pro:dem|this cop|be&3S det:art|a n|type n|definition .
%gra:	1|2|SUBJ 2|0|ROOT 3|5|DET 4|5|MOD 5|2|PRED 6|2|PUNCT
*S1:	so they look like variable declarations but they aren't .
%mor:	co|so pro:sub|they v|look conj|like n|variable n|declare&dv-TION-PL
	conj|but pro:sub|they cop|be&PRES~neg|not .
%gra:	1|3|COM 2|3|SUBJ 3|0|ROOT 4|3|JCT 5|6|MOD 6|4|POBJ 7|9|LINK 8|9|SUBJ
	9|3|CJCT 10|9|NEG 11|3|PUNCT
*S1:	(o)kay what we'll do on the next slide here is actually (.) set up
	the variables (.) and we're gonna start off here with (.) just
	declaring a_couple_of book records (.) book one and book two (.) and
	you can see that (.) I used the type book rec (.) just like other
	types that we've used in the past (.) and then book one and book two
	are the two variables (.) that we're declaring .
%mor:	co|okay pro:int|what pro:sub|we~mod|will v|do prep|on det:art|the
	adj|next n|slide adv|here cop|be&3S adv|actual&dadj-LY n|set prep|up
	det:art|the n|variable-PL coord|and pro:sub|we~aux|be&PRES
	part|go-PRESP~inf|to v|start prep|off n|here prep|with adv|just
	part|declare-PRESP qn|a_couple_of n|book v|record-3S n|book
	det:num|one coord|and n|book det:num|two coord|and pro:per|you
	mod|can v|see comp|that pro:sub|I v|use-PAST det:art|the n|type
	n|book n|rec adv|just prep|like qn|other n|type-PL pro:rel|that
	pro:sub|we~aux|have part|use-PASTP prep|in det:art|the adj|past
	coord|and adv:tem|then n|book det:num|one coord|and n|book
	det:num|two cop|be&PRES det:art|the det:num|two n|variable-PL
	comp|that pro:sub|we~aux|be&PRES part|declare-PRESP .
%gra:	1|5|COM 2|5|LINK 3|5|SUBJ 4|5|AUX 5|0|ROOT 6|5|JCT 7|9|DET 8|9|MOD
	9|6|POBJ 10|11|JCT 11|5|CJCT 12|13|JCT 13|11|PRED 14|13|NJCT 15|16|DET
	16|14|POBJ 17|20|LINK 18|20|SUBJ 19|20|AUX 20|11|CJCT 21|22|INF 22|20|COMP
	23|22|JCT 24|23|POBJ 25|22|JCT 26|27|JCT 27|25|POBJ 28|29|QUANT 29|30|SUBJ
	30|39|JCT 31|30|OBJ 32|31|POSTMOD 33|32|CONJ 34|33|COORD 35|38|QUANT
	36|35|CONJ 37|36|COORD 38|39|AUX 39|27|COMP 40|42|LINK 41|42|SUBJ
	42|39|COMP 43|46|DET 44|45|MOD 45|46|MOD 46|42|OBJ 47|48|JCT 48|42|JCT
	49|50|QUANT 50|48|POBJ 51|54|LINK 52|54|SUBJ 53|54|AUX 54|50|CMOD 55|54|JCT
	56|57|DET 57|55|POBJ 58|61|LINK 59|61|JCT 60|61|MOD 61|57|CMOD 62|61|CONJ
	63|62|COORD 64|65|QUANT 65|61|CJCT 66|68|DET 67|68|QUANT 68|65|PRED
	69|72|LINK 70|72|SUBJ 71|72|AUX 72|68|CMOD 73|5|PUNCT
*S1:	now that's when (.) space gets allocated to store a variable .
%mor:	adv|now pro:rel|that~cop|be&3S conj|when n|space v|get-3S
	v|allocate-PAST inf|to v|store det:art|a n|variable .
%gra:	1|0|INCROOT 2|3|LINK 3|1|CMOD 4|7|LINK 5|7|SUBJ 6|7|SRL 7|3|PRED
	8|9|INF 9|7|COMP 10|11|DET 11|9|OBJ 12|1|PUNCT
*S1:	&-uh remember the data type definition (.) doesn't cause memory
	allocation .
%mor:	v|remember det:art|the n|data n|type n|definition mod|do&3S~neg|not
	n|cause n|memory n|allocate&dv-TION .
%gra:	1|0|ROOT 2|5|DET 3|4|MOD 4|5|MOD 5|10|SUBJ 6|10|AUX 7|6|NEG 8|10|MOD
	9|10|MOD 10|1|OBJ 11|1|PUNCT
*S1:	(o)kay all it does is set up a pattern (.) for variables that when
	you declare them (.) you can use the data type .
%mor:	co|okay adv|all pro:per|it mod|do&3S aux|be&3S part|set&PASTP
	prep|up det:art|a n|pattern prep|for n|variable-PL adv|that
	conj|when pro:per|you v|declare pro:obj|them pro:per|you mod|can
	v|use det:art|the n|data n|type .
%gra:	1|6|COM 2|6|JCT 3|6|SUBJ 4|6|AUX 5|6|AUX 6|19|XJCT 7|6|JCT 8|9|DET
	9|7|POBJ 10|6|JCT 11|10|POBJ 12|6|JCT 13|15|LINK 14|15|SUBJ 15|19|CJCT
	16|15|OBJ 17|19|SUBJ 18|19|AUX 19|0|ROOT 20|22|DET 21|22|MOD 22|19|OBJ
	23|19|PUNCT
*S1:	but the variable declaration that's when we actually get some
	storage space and we can store some (.) data in (th)em .
%mor:	conj|but det:art|the n|variable n|declare&dv-TION
	pro:rel|that~cop|be&3S conj|when pro:sub|we adv|actual&dadj-LY v|get
	qn|some n|storage n|space coord|and pro:sub|we mod|can v|store
	qn|some n|data prep|in pro:obj|them .
%gra:	1|4|LINK 2|4|DET 3|4|MOD 4|0|INCROOT 5|6|LINK 6|4|CMOD 7|10|LINK
	8|10|SUBJ 9|10|JCT 10|6|CPRED 11|13|QUANT 12|13|MOD 13|10|OBJ 14|17|LINK
	15|17|SUBJ 16|17|AUX 17|10|CJCT 18|19|QUANT 19|17|OBJ 20|17|JCT 21|20|POBJ
	22|4|PUNCT
*S1:	so now we've got two books .
%mor:	adv|so adv|now pro:sub|we~aux|have part|get&PASTP det:num|two
	n|book-PL .
%gra:	1|2|JCT 2|5|JCT 3|5|SUBJ 4|5|AUX 5|0|ROOT 6|7|QUANT 7|5|OBJ 8|5|PUNCT
*S1:	and what I've done here is (.) just written (.) assignment
	statements to put data in (.) all four members of book one .
%mor:	coord|and pro:int|what pro:sub|I~aux|have part|do&PASTP
	pro:exist|here cop|be&3S adv|just part|write&PASTP n|assign&dv-MENT
	n|state&dv-MENT-PL inf|to v|put&ZERO n|data prep|in adv|all
	det:num|four n|member-PL prep|of n|book det:num|one .
%gra:	1|5|LINK 2|5|LINK 3|5|SUBJ 4|5|AUX 5|0|ROOT 6|7|SUBJ 7|5|COMP 8|7|JCT
	9|7|XJCT 10|11|MOD 11|9|OBJ 12|13|INF 13|11|XMOD 14|13|OBJ 15|13|JCT
	16|17|JCT 17|18|QUANT 18|15|POBJ 19|18|NJCT 20|19|POBJ 21|13|OBJ 22|5|PUNCT
*S1:	now the title and the author are strings (.) so what we saw (.)
	very recently is that we need to use string copy (.) and what we're
	doing here is putting (.) the title Walden into the title field &-uh
	by the way field is (.) another term that's used for member .
%mor:	adv|now det:art|the n|title coord|and det:art|the n|author
	cop|be&PRES n|string-PL adv|so pro:int|what pro:sub|we v|see&PAST
	adv|very adv|recent&dadj-LY cop|be&3S comp|that pro:sub|we v|need
	inf|to v|use n|string n|copy coord|and pro:int|what
	pro:sub|we~aux|be&PRES part|do-PRESP adv|here aux|be&3S
	part|put-PRESP det:art|the n|title n:prop|Walden prep|into
	det:art|the n|title n|field prep|by det:art|the n|way n|field
	cop|be&3S qn|another n|term pro:rel|that~aux|be&3S part|use-PASTP
	prep|for n|member .
%gra:	1|7|JCT 2|3|DET 3|7|SUBJ 4|3|CONJ 5|6|DET 6|4|COORD 7|0|ROOT 8|7|PRED
	9|12|JCT 10|12|LINK 11|12|SUBJ 12|8|CMOD 13|14|JCT 14|15|JCT 15|12|COMP
	16|18|LINK 17|18|SUBJ 18|15|CPRED 19|20|INF 20|18|COMP 21|22|MOD
	22|20|OBJ 23|20|CONJ 24|27|LINK 25|27|SUBJ 26|27|AUX 27|23|COORD 28|27|JCT
	29|30|AUX 30|27|XJCT 31|32|DET 32|42|SUBJ 33|42|SUBJ 34|33|JCT 35|37|DET
	36|37|MOD 37|34|POBJ 38|33|JCT 39|41|DET 40|41|MOD 41|38|POBJ 42|30|COMP
	43|44|QUANT 44|42|PRED 45|47|LINK 46|47|AUX 47|44|CMOD 48|47|JCT 49|48|POBJ
	50|7|PUNCT
*S1:	and I may use both of those in class .
%mor:	coord|and pro:sub|I mod|may v|use qn|both prep|of pro:dem|those
	prep|in n|class .
%gra:	1|4|LINK 2|4|SUBJ 3|4|AUX 4|0|ROOT 5|4|OBJ 6|5|NJCT 7|6|POBJ 8|7|JCT
	9|8|POBJ 10|4|PUNCT
*S1:	and what we're doing here is putting Henry Thoreau +//.
%mor:	coord|and pro:int|what pro:sub|we~aux|be&PRES part|do-PRESP
	adv|here aux|be&3S part|put-PRESP n:prop|Henry n:prop|Thoreau +//.
%gra:	1|5|LINK 2|5|LINK 3|5|SUBJ 4|5|AUX 5|0|ROOT 6|5|JCT 7|8|AUX 8|5|XJCT
	9|10|NAME 10|8|OBJ 11|5|PUNCT
*S1:	&-uh David didn't fit on the slide so I didn't put that in there .
%mor:	n:prop|David mod|do&PAST~neg|not v|fit&ZERO prep|on det:art|the
	n|slide conj|so pro:sub|I mod|do&PAST~neg|not v|put&ZERO
	pro:dem|that prep|in n|there .
%gra:	1|4|SUBJ 2|4|AUX 3|2|NEG 4|0|ROOT 5|4|JCT 6|7|DET 7|5|POBJ 8|12|LINK
	9|12|SUBJ 10|12|AUX 11|10|NEG 12|4|CJCT 13|12|OBJ 14|12|JCT 15|14|POBJ
	16|4|PUNCT
*S1:	but (.) we're putting his name in the author (.) field here .
%mor:	conj|but pro:sub|we~aux|be&PRES part|put-PRESP det:poss|his n|name
	prep|in det:art|the n|author n|field adv|here .
%gra:	1|4|LINK 2|4|SUBJ 3|4|AUX 4|0|ROOT 5|6|DET 6|4|OBJ 7|4|JCT 8|10|DET
	9|10|MOD 10|7|POBJ 11|4|JCT 12|4|PUNCT
*S1:	and then (.) the library has two copies so we can assign that into
	the (.) known copies field .
%mor:	coord|and adv:tem|then det:art|the n|library v|have&3S det:num|two
	n|copy-PL conj|so pro:sub|we mod|can v|assign pro:dem|that prep|into
	det:art|the part|know&PASTP n|copy-PL v|field .
%gra:	1|5|LINK 2|5|JCT 3|4|DET 4|5|SUBJ 5|0|ROOT 6|7|QUANT 7|5|OBJ 8|11|LINK
	9|11|SUBJ 10|11|AUX 11|17|CJCT 12|11|OBJ 13|11|JCT 14|16|DET 15|16|MOD
	16|13|POBJ 17|5|CJCT 18|5|PUNCT
*S1:	and then what we're saying here is that they aren't all taken out
	at the moment so we'll set this to false .
%mor:	coord|and adv:tem|then pro:int|what pro:sub|we~aux|be&PRES
	part|say-PRESP adv|here cop|be&3S comp|that pro:sub|they
	aux|be&PRES~neg|not adv|all part|take&PASTP adv|out prep|at
	det:art|the n|moment adv|so pro:sub|we~mod|will n|set det:dem|this
	inf|to adv|false .
%gra:	1|6|LINK 2|6|JCT 3|6|LINK 4|6|SUBJ 5|6|AUX 6|0|ROOT 7|8|JCT 8|6|COMP
	9|14|LINK 10|14|SUBJ 11|14|AUX 12|11|NEG 13|14|JCT 14|8|CPRED 15|14|JCT
	16|14|JCT 17|18|DET 18|16|POBJ 19|22|JCT 20|22|SUBJ 21|22|AUX 22|14|OBJ
	23|25|DET 24|25|INF 25|22|JCT 26|6|PUNCT
*S1:	now as far as the notation here &-uh let's look at this last one
	(.) the thing to notice is that the very first item (.) is the name
	of (.) a struct [: structure] variable .
%mor:	adv|now prep|as adj|far conj|as det:art|the n|notate&dv-TION
	adv|here v|let~pro:obj|us v|look prep|at det:dem|this adj|last
	det:num|one det:art|the n|thing inf|to v|notice aux|be&3S comp|that
	det:art|the adv|very adj|first n|item cop|be&3S det:art|the n|name
	prep|of det:art|a n|structure n|variable .
%gra:	1|3|JCT 2|3|COORD 3|0|ROOT 4|6|COORD 5|6|DET 6|3|ENUM 7|3|JCT 8|3|ENUM
	9|10|SUBJ 10|8|COMP 11|10|JCT 12|14|DET 13|14|MOD 14|16|QUANT 15|16|DET
	16|11|POBJ 17|18|INF 18|25|SUBJ 19|25|AUX 20|25|LINK 21|24|DET 22|23|JCT
	23|24|MOD 24|25|SUBJ 25|10|CJCT 26|27|DET 27|25|PRED 28|27|NJCT
	29|31|DET 30|31|MOD 31|28|POBJ 32|3|PUNCT
*S1:	so book one is (.) the name of the variable that I declared up here
	(.) as book rec (.) and then the dot here in this spot that's the
	member operator (.) and then if you look at the word all taken out
	(.) that is from the type definition .
%mor:	co|so n|book det:num|one cop|be&3S det:art|the n|name prep|of
	det:art|the n|variable comp|that pro:sub|I v|declare-PAST prep|up
	n|here conj|as n|book n|rec coord|and adv:tem|then det:art|the n|dot
	adv|here prep|in det:dem|this n|spot pro:rel|that~cop|be&3S
	det:art|the n|member n|operator coord|and adv:tem|then conj|if
	pro:per|you v|look prep|at det:art|the n|word adv|all
	part|take&PASTP adv|out comp|that cop|be&3S prep|from det:art|the
	n|type n|definition .
%gra:	1|3|COM 2|3|MOD 3|4|SUBJ 4|0|ROOT 5|6|DET 6|4|PRED 7|6|NJCT 8|9|DET
	9|7|POBJ 10|12|LINK 11|12|SUBJ 12|6|ROOT 13|12|JCT 14|13|POBJ 15|17|COORD
	16|17|MOD 17|12|ENUM 18|17|CONJ 19|18|COORD 20|21|DET 21|19|INCROOT
	22|21|NJCT 23|22|INCROOT 24|25|DET 25|23|POBJ 26|27|LINK 27|23|ROOT 28|30|DET
	29|30|MOD 30|27|PRED 31|30|CONJ 32|31|COORD 33|35|LINK 34|35|SUBJ
	35|27|CJCT 36|35|JCT 37|38|DET 38|36|POBJ 39|40|JCT 40|35|XJCT 41|40|JCT
	42|43|LINK 43|41|CPOBJ 44|43|JCT 45|47|DET 46|47|MOD 47|44|POBJ 48|27|PUNCT
*S1:	so we've got something a little new here as far as the syntax &-uh
	where this is a variable name (.) and this is something from a type
	.
%mor:	co|so pro:sub|we~aux|have part|get&PASTP pro:indef|something
	det:art|a adj|little adj|new adv|here adv|as adv|far conj|as
	det:art|the n|syntax pro:rel|where det:dem|this cop|be&3S det:art|a
	n|variable n|name coord|and pro:dem|this cop|be&3S
	pro:indef|something prep|from det:art|a n|type .
%gra:	1|4|COM 2|4|SUBJ 3|4|AUX 4|0|ROOT 5|4|OBJ 6|8|DET 7|8|MOD 8|5|POSTMOD
	9|10|JCT 10|11|COORD 11|8|JCT 12|14|COORD 13|14|DET 14|11|POBJ 15|17|LINK
	16|17|DET 17|14|CMOD 18|20|DET 19|20|MOD 20|23|SUBJ 21|20|CONJ
	22|21|COORD 23|17|PRED 24|23|PRED 25|24|NJCT 26|27|DET 27|25|POBJ 28|4|PUNCT
*S1:	(o)kay we're not really used to doing things like that .
%mor:	co|okay pro:sub|we~aux|be&PRES neg|not adv|real&dadj-LY
	part|use-PASTP inf|to n:gerund|do-PRESP n|thing-PL prep|like
	pro:dem|that .
%gra:	1|6|COM 2|6|SUBJ 3|6|AUX 4|3|NEG 5|6|JCT 6|0|ROOT 7|8|INF 8|6|COMP
	9|8|OBJ 10|9|NJCT 11|10|POBJ 12|6|PUNCT
*S1:	now one difficulty that &-uh we see in this class with (.) programs
	where we've got structs [: structures] there's a little confusion
	over the [/] the notation and that's why I'm emphasizing it .
%mor:	adv|now pro:indef|one n|difficulty pro:rel|that pro:sub|we v|see
	prep|in det:dem|this n|class prep|with n|program-PL pro:rel|where
	pro:sub|we~aux|have part|get&PASTP n|structure-PL
	pro:exist|there~cop|be&3S det:art|a adj|little n|confusion prep|over
	det:art|the n|notate&dv-TION coord|and pro:dem|that~cop|be&3S
	pro:int|why pro:sub|I~aux|be&1S part|emphasize-PRESP pro:per|it .
%gra:	1|3|JCT 2|3|SUBJ 3|0|INCROOT 4|6|LINK 5|6|SUBJ 6|3|CMOD 7|6|JCT 8|9|DET
	9|7|POBJ 10|6|JCT 11|10|POBJ 12|15|LINK 13|15|SUBJ 14|15|AUX 15|11|CMOD
	16|18|COM 17|18|SUBJ 18|15|COMP 19|21|DET 20|21|MOD 21|18|PRED
	22|21|NJCT 23|24|DET 24|22|POBJ 25|21|CONJ 26|25|COORD 27|21|CMOD 28|31|LINK
	29|31|SUBJ 30|31|AUX 31|27|CPRED 32|31|OBJ 33|3|PUNCT
*S1:	(o)kay are there any questions about this (.) so far ?
%mor:	co|okay cop|be&PRES adv|there qn|any n|question-PL prep|about
	pro:dem|this adv|so adj|far ?
%gra:	1|2|COM 2|0|ROOT 3|2|JCT 4|5|QUANT 5|2|PRED 6|5|NJCT 7|6|POBJ 8|9|JCT
	9|5|ENUM 10|2|PUNCT
*S1:	(0.4) yeah .
%mor:	co|yeah .
%gra:	1|0|INCROOT 2|1|PUNCT
*S5:	so <you're gonna> [?] have to declare a [/] a (.) record variable
	for every (.) record you wanna enter ?
%mor:	adv|so pro:per|you~aux|be&PRES part|go-PRESP~inf|to v|have inf|to
	v|declare det:art|a n|record n|variable prep|for qn|every n|record
	pro:per|you v|want~inf|to v|enter ?
%gra:	1|4|JCT 2|4|SUBJ 3|4|AUX 4|0|ROOT 5|6|INF 6|4|COMP 7|8|INF 8|6|COMP
	9|11|DET 10|11|MOD 11|8|OBJ 12|11|NJCT 13|14|QUANT 14|12|POBJ 15|16|SUBJ
	16|11|CMOD 17|18|INF 18|16|COMP 19|4|PUNCT
*S1:	well that's a really good question .
%mor:	co|well pro:dem|that~cop|be&3S det:art|a adv|real&dadj-LY adj|good
	n|question .
%gra:	1|3|COM 2|3|SUBJ 3|0|ROOT 4|7|DET 5|6|JCT 6|7|MOD 7|3|PRED 8|3|PUNCT
*S1:	&-uh you're thinking ahead here &-uh if you really were writing
	MIRLYN (.) you wouldn't declare book one book two book three book
	four (.) I mean we'd be sitting there typing all day long .
%mor:	pro:per|you~aux|be&PRES part|think-PRESP adv|ahead pro:exist|here
	conj|if pro:per|you adv|real&dadj-LY aux|be&PAST part|write-PRESP
	n:prop|MIRLYN pro:per|you mod|will&COND~neg|not v|declare n|book
	det:num|one n|book det:num|two n|book det:num|three n|book
	det:num|four pro:sub|I v|mean pro:sub|we~mod|genmod aux|be
	part|sit-PRESP adv|there part|type-PRESP adv|all n|day post|long .
%gra:	1|3|SUBJ 2|3|AUX 3|0|ROOT 4|3|JCT 5|4|POBJ 6|10|LINK 7|10|SUBJ 8|10|JCT
	9|10|AUX 10|3|CJCT 11|10|OBJ 12|15|SUBJ 13|15|AUX 14|13|NEG 15|10|COMP
	16|23|DATE 17|18|QUANT 18|23|DATE 19|20|QUANT 20|23|DATE 21|22|QUANT
	22|23|DATE 23|15|OBJ 24|25|SUBJ 25|15|CJCT 26|29|SUBJ 27|29|AUX 28|29|AUX
	29|25|COMP 30|29|JCT 31|29|XJCT 32|33|JCT 33|31|JCT 34|33|POSTMOD
	35|3|PUNCT
*S1:	&-uh what we'll talk about after our (.) initial discussion of [/]
	of (.) just single structs [: structures] here is how to set up an
	array of structs [: structures] .
%mor:	pro:int|what pro:sub|we~mod|will v|talk adv|about adv:tem|after
	det:poss|our adj|initial n|discussion prep|of adj|just adj|single
	n|structure-PL pro:exist|here cop|be&3S pro:int|how inf|to
	v|set&ZERO prep|up det:art|a n|array prep|of n|structure-PL .
%gra:	1|4|LINK 2|4|SUBJ 3|4|AUX 4|0|ROOT 5|6|JCT 6|4|JCT 7|9|DET 8|9|MOD
	9|15|SUBJ 10|9|NJCT 11|13|MOD 12|13|MOD 13|10|POBJ 14|15|SUBJ 15|6|COMP
	16|18|LINK 17|18|INF 18|15|CPRED 19|18|JCT 20|21|DET 21|19|POBJ 22|21|NJCT
	23|22|POBJ 24|4|PUNCT
*S1:	because (.) of_course the library's not gonna have one book or
	three or [/] or whatever it's gonna have (.) <lots and> [/] lots and
	lots .
%mor:	conj|because co|of_course det:art|the adj|library&dn-POSS neg|not
	part|go-PRESP~inf|to v|have det:num|one n|book coord|or
	det:num|three coord|or pro:int|whatever pro:per|it~aux|be&3S
	part|go-PRESP~inf|to v|have n|lot-PL coord|and n|lot-PL .
%gra:	1|2|LINK 2|0|INCROOT 3|4|DET 4|2|PRED 5|4|NEG 6|4|XMOD 7|8|INF 8|6|COMP
	9|10|QUANT 10|8|OBJ 11|10|CONJ 12|11|COORD 13|8|CONJ 14|17|LINK
	15|17|SUBJ 16|17|AUX 17|13|COORD 18|19|INF 19|17|COMP 20|19|OBJ 21|20|CONJ
	22|21|COORD 23|2|PUNCT
*S1:	so (.) one possible data structure is &-uh to declare this book
	record (.) and then declare an array of (.) book records .
%mor:	adv|so pro:indef|one adj|possible n|data n|structure cop|be&3S
	inf|to v|declare det:dem|this n|book n|record coord|and adv:tem|then
	v|declare det:art|a n|array prep|of n|book n|record-PL .
%gra:	1|2|JCT 2|6|SUBJ 3|5|MOD 4|5|MOD 5|6|SUBJ 6|0|ROOT 7|8|INF 8|6|CPRED
	9|11|DET 10|11|MOD 11|8|OBJ 12|8|CONJ 13|14|JCT 14|12|COORD 15|16|DET
	16|14|OBJ 17|16|NJCT 18|19|MOD 19|17|POBJ 20|6|PUNCT
*S1:	&-uh that's the other possible (.) data structure you can use on
	program six if you would like to .
%mor:	pro:dem|that~cop|be&3S det:art|the qn|other adj|possible n|data
	n|structure pro:per|you mod|can v|use prep|on n|program det:num|six
	conj|if pro:per|you mod|will&COND v|like inf|to .
%gra:	1|2|SUBJ 2|0|ROOT 3|7|DET 4|7|QUANT 5|7|MOD 6|7|MOD 7|2|PRED 8|10|SUBJ
	9|10|AUX 10|7|CMOD 11|10|JCT 12|11|POBJ 13|14|QUANT 14|17|LINK
	15|17|SUBJ 16|17|AUX 17|10|CJCT 18|17|OBJ 19|2|PUNCT
*S1:	&-uh actually you've got a choice either parallel arrays or (.) an
	array of structs [: structures] .
%mor:	adv|actual&dadj-LY pro:per|you~aux|have part|get&PASTP det:art|a
	n|choice coord|either n|parallel n|array-PL coord|or det:art|a
	n|array prep|of n|structure-PL .
%gra:	1|4|JCT 2|4|SUBJ 3|4|AUX 4|0|ROOT 5|6|DET 6|4|OBJ 7|6|CONJ 8|9|MOD
	9|7|COORD 10|6|CONJ 11|12|DET 12|10|COORD 13|12|NJCT 14|13|POBJ 15|4|PUNCT
*S1:	so that's a good point we're gonna get to that &-uh not today
	obviously but we'll [/] we'll probably be talking about that
	tomorrow .
%mor:	co|so pro:dem|that~cop|be&3S det:art|a adj|good n|point
	pro:sub|we~aux|be&PRES part|go-PRESP~inf|to v|get prep|to
	det:dem|that neg|not adv:tem|today adv|obvious&dadj-LY conj|but
	pro:sub|we~mod|will adv|probable&dadj-LY aux|be part|talk-PRESP
	prep|about pro:dem|that adv:tem|tomorrow .
%gra:	1|3|COM 2|3|SUBJ 3|0|ROOT 4|6|DET 5|6|MOD 6|3|PRED 7|9|SUBJ 8|9|AUX
	9|6|CMOD 10|11|INF 11|9|COMP 12|11|JCT 13|15|DET 14|13|NEG 15|12|POBJ
	16|11|JCT 17|22|LINK 18|22|SUBJ 19|22|AUX 20|22|JCT 21|22|AUX 22|16|CPOBJ
	23|22|JCT 24|25|DET 25|23|POBJ 26|3|PUNCT
*S1:	(0.5) (o)kay well let's (.) try to (.) think about how (.) in
	memory we might picture this as being stored &-uh when we talked
	about arrays (.) we drew them like this (.) where they had
	sequential elements (.) they were all the same size (.) because
	they're all exactly the same data type .
%mor:	co|okay adv|well v|let~pro:obj|us v|try inf|to v|think prep|about
	pro:int|how prep|in n|memory pro:sub|we mod|might v|picture
	det:dem|this adv|as n|being part|store-PASTP conj|when pro:sub|we
	v|talk-PAST prep|about n|array-PL pro:sub|we v|draw&PAST
	pro:obj|them prep|like pro:dem|this pro:int|where pro:sub|they
	v|have&PAST adj|sequential n|element-PL pro:sub|they cop|be&PAST
	adv|all det:art|the adj|same n|size conj|because
	pro:sub|they~cop|be&PRES post|all adv|exact&dadj-LY det:art|the
	adj|same n|data n|type .
%gra:	1|3|COM 2|3|JCT 3|0|ROOT 4|5|SUBJ 5|3|COMP 6|7|INF 7|5|COMP 8|7|JCT
	9|14|LINK 10|9|JCT 11|10|POBJ 12|14|SUBJ 13|14|AUX 14|8|CPOBJ 15|17|DET
	16|17|COORD 17|25|SUBJ 18|25|XJCT 19|21|LINK 20|21|SUBJ 21|25|CJCT
	22|21|JCT 23|22|POBJ 24|25|SUBJ 25|14|COMP 26|25|OBJ 27|25|JCT 28|27|POBJ
	29|31|LINK 30|31|SUBJ 31|3|COMP 32|33|MOD 33|31|OBJ 34|35|SUBJ 35|33|CMOD
	36|39|JCT 37|39|DET 38|39|MOD 39|35|PRED 40|3|JCT 41|42|SUBJ 42|40|CPOBJ
	43|42|PRED 44|43|JCT 45|48|DET 46|48|MOD 47|48|MOD 48|44|POBJ 49|3|PUNCT
*S1:	now with a struct [: structure] it [/] it appears that we could use
	something similar to (.) imagine how it's stored but (.) they're not
	all the same size .
%mor:	adv|now prep|with det:art|a n|structure pro:per|it v|appear-3S
	comp|that pro:sub|we mod|could v|use pro:indef|something adj|similar
	inf|to v|imagine pro:int|how pro:per|it~aux|be&3S part|store-PASTP
	conj|but pro:sub|they~cop|be&PRES neg|not qn|all det:art|the
	adj|same n|size .
%gra:	1|6|JCT 2|6|JCT 3|4|DET 4|2|POBJ 5|6|SUBJ 6|0|ROOT 7|10|LINK 8|10|SUBJ
	9|10|AUX 10|6|COMP 11|10|OBJ 12|11|POSTMOD 13|14|INF 14|10|COMP
	15|18|LINK 16|18|SUBJ 17|18|AUX 18|14|COMP 19|21|LINK 20|21|SUBJ 21|6|CJCT
	22|21|NEG 23|26|QUANT 24|26|DET 25|26|MOD 26|21|PRED 27|6|PUNCT
*S1:	so I've tried to represent that here &-uh the strings we know are
	forty one characters (.) so (.) in reality we'd have forty one bytes
	(.) of storage for each one of those &-uh we actually know that
	these are arrays .
%mor:	co|so pro:sub|I~aux|have part|try-PASTP inf|to v|represent adv|that
	adv|here det:art|the n|string-PL pro:sub|we v|know aux|be&PRES
	det:num|forty det:num|one n|character-PL conj|so prep|in
	n|real&dadj-ITY pro:sub|we~mod|genmod v|have det:num|forty
	det:num|one n|byte-PL prep|of n|storage prep|for qn|each det:num|one
	prep|of det:dem|those pro:sub|we adv|actual&dadj-LY v|know comp|that
	pro:dem|these cop|be&PRES n|array-PL .
%gra:	1|4|COM 2|4|SUBJ 3|4|AUX 4|0|ROOT 5|6|INF 6|4|COMP 7|6|JCT 8|6|JCT
	9|10|DET 10|8|POBJ 11|12|SUBJ 12|4|CJCT 13|16|AUX 14|16|QUANT 15|16|QUANT
	16|12|OBJ 17|22|LINK 18|22|JCT 19|18|POBJ 20|22|SUBJ 21|22|AUX 22|16|CJCT
	23|25|QUANT 24|25|QUANT 25|22|OBJ 26|25|NJCT 27|26|POBJ 28|22|JCT
	29|30|QUANT 30|28|POBJ 31|30|NJCT 32|35|DET 33|35|SUBJ 34|35|JCT 35|31|POBJ
	36|38|LINK 37|38|SUBJ 38|35|COMP 39|38|PRED 40|4|PUNCT
*S1:	in fact &-uh we could draw this (.) a little differently
	&=writing:board (o)kay the (.) title here is a string (.) and so is
	the author (.) and (.) we could've drawn it up there very similarly
	but said okay that's an array it's got forty one (.) elements in it
	each one's got its own little box .
%mor:	prep|in n|fact pro:sub|we mod|could v|draw det:dem|this det:art|a
	adj|little adv|different&dadj-LY adj|okay det:art|the n|title
	adv|here cop|be&3S det:art|a n|string coord|and adv|so cop|be&3S
	det:art|the n|author coord|and pro:sub|we mod|could~aux|have
	part|draw&PASTP pro:per|it prep|up n|there adv|very adj|similarly
	conj|but v|say&PAST co|okay pro:dem|that~cop|be&3S det:art|a n|array
	pro:per|it~aux|be&3S part|get&PASTP det:num|forty det:num|one
	n|element-PL prep|in pro:per|it qn|each adj|one&dn-POSS v|get&PAST
	det:poss|its adj|own adj|little n|box .
%gra:	1|5|JCT 2|1|POBJ 3|5|SUBJ 4|5|AUX 5|0|ROOT 6|12|DET 7|12|DET 8|12|MOD
	9|10|JCT 10|12|MOD 11|12|DET 12|5|OBJ 13|14|JCT 14|5|CJCT 15|16|DET
	16|14|PRED 17|16|CONJ 18|19|JCT 19|17|COORD 20|21|DET 21|19|PRED 22|26|LINK
	23|26|SUBJ 24|26|AUX 25|26|AUX 26|21|CMOD 27|26|OBJ 28|26|JCT 29|28|POBJ
	30|31|JCT 31|26|JCT 32|33|LINK 33|31|CMOD 34|36|COM 35|36|SUBJ
	36|33|COMP 37|38|DET 38|36|PRED 39|41|SUBJ 40|41|AUX 41|38|CMOD 42|44|QUANT
	43|44|QUANT 44|41|OBJ 45|41|JCT 46|45|POBJ 47|48|QUANT 48|49|JCT 49|41|CJCT
	50|53|DET 51|53|MOD 52|53|MOD 53|49|OBJ 54|5|PUNCT
*S1:	so actually it's a little more (.) complicated than we've [/] &go
	we've got up here what we're doing with this is (.) basically taking
	a [/] a fairly high level look at it (.) at the whole thing (.) and
	not looking at the (.) individual characters in the strings just yet
	.
%mor:	adv|so adv|actual&dadj-LY pro:per|it~cop|be&3S det:art|a adj|little
	adv|more part|complicate-PASTP prep|than pro:sub|we~aux|have
	part|get&PASTP prep|up n|here pro:int|what pro:sub|we~aux|be&PRES
	part|do-PRESP prep|with pro:dem|this aux|be&3S adv|basic&dadj-AL-LY
	part|take-PRESP det:art|a adv|fair&dadj-LY adj|high n|level v|look
	prep|at pro:per|it prep|at det:art|the adj|whole n|thing coord|and
	neg|not part|look-PRESP prep|at det:art|the n|individual
	n|character-PL prep|in det:art|the n|string-PL adj|just adv|yet .
%gra:	1|2|JCT 2|4|JCT 3|4|SUBJ 4|0|ROOT 5|6|DET 6|4|PRED 7|8|JCT 8|6|XMOD
	9|8|JCT 10|12|SUBJ 11|12|AUX 12|9|CPOBJ 13|12|JCT 14|13|POBJ 15|18|LINK
	16|18|SUBJ 17|18|AUX 18|12|XJCT 19|18|JCT 20|23|SUBJ 21|23|AUX 22|23|JCT
	23|19|POBJ 24|27|DET 25|26|JCT 26|27|MOD 27|28|SUBJ 28|23|OBJ 29|28|JCT
	30|29|POBJ 31|28|JCT 32|34|DET 33|34|MOD 34|31|POBJ 35|28|CONJ 36|37|NEG
	37|35|COORD 38|37|JCT 39|41|DET 40|41|MOD 41|38|POBJ 42|41|NJCT 43|44|DET
	44|42|POBJ 45|37|JCT 46|45|JCT 47|4|PUNCT
*S1:	now the (.) two and the false would be stored in a_lot less storage
	space .
%mor:	adv|now det:art|the det:num|two coord|and det:art|the adj|false
	mod|will&COND aux|be part|store-PASTP adv|in adv|a_lot adj|less
	n|storage n|space .
%gra:	1|9|JCT 2|3|DET 3|9|SUBJ 4|3|CONJ 5|6|DET 6|4|COORD 7|9|AUX 8|9|AUX
	9|0|ROOT 10|9|JCT 11|12|JCT 12|14|MOD 13|14|MOD 14|9|OBJ 15|9|PUNCT
*S1:	&-uh what we saw with ints [: integers] (.) is that they get &-uh
	thirty two bits (.) and booleans we actually haven't talked about
	but they can be stored &-uh typically in one byte .
%mor:	pro:int|what pro:sub|we n|saw prep|with n|integer-PL cop|be&3S
	comp|that pro:sub|they v|get det:num|thirty det:num|two n|bit-PL
	coord|and n|boolean-PL pro:sub|we adv|actual&dadj-LY
	aux|have~neg|not part|talk-PASTP adv|about conj|but pro:sub|they
	mod|can aux|be part|store-PASTP adv|typical&dadj-LY prep|in
	det:num|one n|byte .
%gra:	1|3|LINK 2|3|SUBJ 3|6|SUBJ 4|3|NJCT 5|4|POBJ 6|0|ROOT 7|9|LINK 8|9|SUBJ
	9|6|ROOT 10|12|QUANT 11|12|QUANT 12|9|OBJ 13|12|CONJ 14|13|COORD
	15|9|INCROOT 16|15|JCT 17|19|AUX 18|17|NEG 19|16|CPOBJ 20|19|JCT 21|25|LINK
	22|25|SUBJ 23|25|AUX 24|25|AUX 25|19|CJCT 26|25|JCT 27|25|JCT 28|29|QUANT
	29|27|POBJ 30|15|PUNCT
*S1:	so we'd have a large group of (.) sequential storage locations (.)
	which is like an array .
%mor:	adv|so pro:sub|we~mod|genmod v|have det:art|a adj|large n|group
	prep|of adj|sequential n|storage n|locate&dv-TION-PL pro:rel|which
	cop|be&3S co|like det:art|a n|array .
%gra:	1|4|JCT 2|4|SUBJ 3|4|AUX 4|0|ROOT 5|7|DET 6|7|MOD 7|4|OBJ 8|7|NJCT
	9|11|MOD 10|11|MOD 11|8|POBJ 12|13|LINK 13|11|CMOD 14|16|COM 15|16|DET
	16|13|PRED 17|4|PUNCT
*S1:	these are stored consecutively in memory .
%mor:	det:dem|these aux|be&PRES v|store-PAST adv|consecutive&dadj-LY
	prep|in n|memory .
%gra:	1|3|SUBJ 2|3|AUX 3|0|ROOT 4|3|JCT 5|3|JCT 6|5|POBJ 7|3|PUNCT
*S1:	the difference being that they're not &-uh uniform (.) storage
	locations we've got items of different sizes because they're
	different data types .
%mor:	det:art|the n|difference aux|be-PRESP comp|that
	pro:sub|they~cop|be&PRES neg|not adj|uniform n|storage
	n|locate&dv-TION-PL pro:sub|we~aux|have part|get&PASTP n|item-PL
	prep|of adj|different n|size-PL conj|because
	pro:sub|they~cop|be&PRES adj|different n|data n|type-PL .
%gra:	1|2|DET 2|6|SUBJ 3|6|AUX 4|3|PRED 5|6|SUBJ 6|0|ROOT 7|6|NEG 8|10|MOD
	9|10|MOD 10|6|PRED 11|13|SUBJ 12|13|AUX 13|10|CMOD 14|13|OBJ 15|14|NJCT
	16|17|MOD 17|15|POBJ 18|20|LINK 19|20|SUBJ 20|6|CJCT 21|23|MOD 22|23|MOD
	23|20|PRED 24|6|PUNCT
*S1:	so we could picture a book going like this and I think it's helpful
	&-uh to think about it this way so that when you work with structs
	[: structures] in a program you've got something you're kinda
	pinning it on (.) as far as what it looks like .
%mor:	co|so pro:sub|we mod|could v|picture det:art|a n|book
	n:gerund|go-PRESP co|like det:dem|this coord|and pro:sub|I v|think
	pro:per|it~cop|be&3S adj|help&dn-FULL inf|to v|think prep|about
	pro:per|it pro:dem|this adv|way adv|so adv|that conj|when
	pro:per|you v|work prep|with n|structure-PL prep|in det:art|a
	n|program pro:per|you~aux|have part|get&PASTP pro:indef|something
	pro:per|you~aux|be&PRES adv|kinda part|pin-PRESP pro:per|it adv|on
	adv|as adv|far conj|as pro:int|what pro:per|it v|look-3S conj|like .
%gra:	1|4|COM 2|4|SUBJ 3|4|AUX 4|0|ROOT 5|6|DET 6|4|OBJ 7|6|XMOD 8|7|COM
	9|12|DET 10|12|LINK 11|12|SUBJ 12|7|CJCT 13|14|SUBJ 14|12|COMP 15|14|PRED
	16|17|INF 17|15|XMOD 18|17|JCT 19|18|POBJ 20|19|COORD 21|22|JCT 22|24|JCT
	23|24|JCT 24|26|LINK 25|26|SUBJ 26|34|CJCT 27|26|JCT 28|27|POBJ
	29|28|NJCT 30|31|DET 31|29|POBJ 32|34|SUBJ 33|34|AUX 34|20|COMP 35|34|OBJ
	36|39|SUBJ 37|39|AUX 38|39|JCT 39|35|CMOD 40|39|OBJ 41|39|JCT 42|43|COORD
	43|39|JCT 44|47|COORD 45|47|LINK 46|47|SUBJ 47|43|ENUM 48|47|COMP 49|4|PUNCT
*S1:	(0.6) (o)kay well let's take a look at a_couple_of (.) issues
	before we have to stop (.) we just set up book one and we
	initialized it (.) all four members have values (.) and if I wanted
	to copy (.) all of book one into book two (.) one very convenient
	thing about structs [: structures] is that I can do that with an
	assignment (.) statement .
%mor:	co|okay adv|well v|let~pro:obj|us v|take det:art|a v|look prep|at
	qn|a_couple_of n|issue-PL conj|before pro:sub|we v|have inf|to
	v|stop pro:sub|we adv|just n|set adv|up n|book det:num|one coord|and
	pro:sub|we part|initial-IZE-PASTP pro:per|it adv|all det:num|four
	n|member-PL v|have n|value-PL coord|and conj|if pro:sub|I
	v|want-PAST prep|to n|copy pro:indef|all prep|of n|book det:num|one
	prep|into n|book det:num|two det:num|one adv|very adj|convenient
	n|thing prep|about n|structure-PL cop|be&3S comp|that pro:sub|I
	mod|can v|do pro:dem|that prep|with det:art|a n|assign&dv-MENT
	n|state&dv-MENT .
%gra:	1|3|COM 2|3|JCT 3|0|ROOT 4|3|OBJ 5|3|COMP 6|7|DET 7|5|OBJ 8|7|JCT
	9|10|QUANT 10|8|POBJ 11|13|LINK 12|13|SUBJ 13|7|CJCT 14|15|INF 15|13|COMP
	16|18|SUBJ 17|18|JCT 18|15|OBJ 19|21|JCT 20|21|MOD 21|18|NJCT 22|21|CONJ
	23|22|COORD 24|23|XJCT 25|24|OBJ 26|27|JCT 27|28|QUANT 28|29|SUBJ
	29|25|COMP 30|29|OBJ 31|30|CONJ 32|34|LINK 33|34|SUBJ 34|31|COORD 35|34|JCT
	36|50|SUBJ 37|50|JCT 38|37|NJCT 39|38|POBJ 40|44|ENUM 41|40|JCT 42|41|POBJ
	43|44|DATE 44|47|QUANT 45|46|JCT 46|47|MOD 47|50|SUBJ 48|47|NJCT
	49|48|POBJ 50|35|POBJ 51|54|LINK 52|54|SUBJ 53|54|AUX 54|50|CPRED 55|54|OBJ
	56|54|JCT 57|59|DET 58|59|MOD 59|56|POBJ 60|3|PUNCT
*S1:	so if I write book two equals book one that does the whole thing
	(.) it copies (.) the two strings (.) and the int [: integer] and
	the Bool .
%mor:	co|so conj|if pro:sub|I v|write n|book det:num|two n|equal-PL
	n|book det:num|one adv|that mod|do&3S det:art|the adj|whole n|thing
	pro:per|it v|copy-3S det:art|the det:num|two n|string-PL coord|and
	det:art|the n|integer coord|and det:art|the n:prop|Bool .
%gra:	1|16|COM 2|4|LINK 3|4|SUBJ 4|16|CJCT 5|8|MOD 6|7|QUANT 7|8|MOD 8|4|OBJ
	9|14|QUANT 10|14|JCT 11|14|AUX 12|14|DET 13|14|MOD 14|8|APP 15|16|SUBJ
	16|0|ROOT 17|19|DET 18|19|QUANT 19|16|OBJ 20|19|CONJ 21|22|DET
	22|20|COORD 23|16|CONJ 24|25|DET 25|23|COORD 26|16|PUNCT
*S1:	now that may be a little surprising based on (.) what we talked
	about with arrays (.) and just to compare the two for the moment
	&-uh is it possible to write something like this ?
%mor:	adv|now adv|that mod|may cop|be det:art|a adj|little
	n:gerund|surprise-PRESP part|base-PASTP prep|on pro:int|what
	pro:sub|we v|talk-PAST adv|about prep|with n|array-PL coord|and
	adv|just inf|to v|compare det:art|the det:num|two prep|for
	det:art|the n|moment cop|be&3S pro:per|it adj|possible inf|to
	v|write pro:indef|something prep|like pro:dem|this ?
%gra:	1|4|JCT 2|4|JCT 3|4|AUX 4|0|ROOT 5|7|DET 6|7|MOD 7|4|PRED 8|7|XMOD
	9|8|JCT 10|12|LINK 11|12|SUBJ 12|9|CPOBJ 13|12|JCT 14|12|JCT 15|14|POBJ
	16|8|CONJ 17|19|JCT 18|19|INF 19|16|COORD 20|21|DET 21|25|SUBJ 22|21|NJCT
	23|24|DET 24|22|POBJ 25|19|COMP 26|25|PRED 27|26|PRED 28|29|INF 29|27|XMOD
	30|29|OBJ 31|30|NJCT 32|31|POBJ 33|4|PUNCT
*S1:	(o)kay I've got two arrays of ints [: integers] with ten (.) ints
	[: integers] each (.) and I've initialized B (.) just like I
	initialized book one (.) B would have all zeros in it because of
	that (.) and then (.) can I write A equals B +..?
%mor:	co|okay pro:sub|I~aux|have part|get&PASTP det:num|two n|array-PL
	prep|of n|integer-PL prep|with det:num|ten n|integer-PL qn|each
	coord|and pro:sub|I~aux|have part|initial-IZE-PASTP n:prop|B
	adj|just co|like pro:sub|I part|initial-IZE-PASTP n|book det:num|one
	n:prop|B mod|will&COND v|have qn|all n|zero-PL prep|in pro:per|it
	conj|because prep|of pro:dem|that coord|and adv:tem|then mod|can
	pro:sub|I v|write n:prop|A v|equal-3S n:prop|B +..?
%gra:	1|4|COM 2|4|SUBJ 3|4|AUX 4|0|ROOT 5|6|QUANT 6|4|OBJ 7|6|NJCT 8|7|POBJ
	9|4|JCT 10|11|QUANT 11|9|POBJ 12|16|QUANT 13|16|LINK 14|16|SUBJ 15|16|AUX
	16|4|CJCT 17|16|OBJ 18|20|MOD 19|18|COM 20|17|OM 21|20|XMOD 22|21|OBJ
	23|24|QUANT 24|26|SUBJ 25|26|AUX 26|22|CMOD 27|28|QUANT 28|26|OBJ
	29|26|JCT 30|29|POBJ 31|26|JCT 32|31|JCT 33|32|POBJ 34|38|LINK 35|38|JCT
	36|38|AUX 37|38|SUBJ 38|32|CPOBJ 39|40|SUBJ 40|38|COMP 41|40|OBJ 42|4|PUNCT
*S1:	okay I just wrote book two equals book one (.) but can I (.)
	actually do that ?
%mor:	co|okay pro:sub|I adv|just v|write&PAST n|book det:num|two
	n|equal-PL n|book det:num|one conj|but mod|can pro:sub|I
	adv|actual&dadj-LY v|do pro:dem|that ?
%gra:	1|4|COM 2|4|SUBJ 3|4|JCT 4|0|ROOT 5|8|MOD 6|7|QUANT 7|8|MOD 8|9|MOD
	9|4|OBJ 10|4|CONJ 11|14|AUX 12|14|SUBJ 13|14|JCT 14|10|COORD 15|14|OBJ
	16|4|PUNCT
*S1:	no (.) Polly (.) why not ?
%mor:	co|no n:prop|Polly pro:rel|why neg|not ?
%gra:	1|2|COM 2|0|ROOT 3|2|OM 4|3|NEG 5|2|PUNCT
*S5:	you [/] you can (.) just &-um you can do that in initialization (.)
	like &-um A (.) equals ten but not here &-um the ⌈ xxx ⌉ +/.
%mor:	pro:per|you mod|can adv|just pro:per|you mod|can v|do pro:dem|that
	prep|in n|initial&dv-IZE-TION v|like n:prop|A v|equal-3S det:num|ten
	conj|but neg|not adv|here det:art|the +/.
%gra:	1|4|SUBJ 2|4|AUX 3|4|JCT 4|6|SUBJ 5|6|AUX 6|0|ROOT 7|6|OBJ 8|6|JCT
	9|8|POBJ 10|6|JCT 11|12|SUBJ 12|10|COMP 13|12|OBJ 14|10|CONJ 15|16|NEG
	16|17|JCT 17|14|COORD 18|6|PUNCT
*S1:	⌊ mhm ⌋ .
%mor:	co|mhm=yes .
%gra:	1|0|INCROOT 2|1|PUNCT
*S5:	+, assignments .
%mor:	n|assign&dv-MENT-PL .
%gra:	1|0|INCROOT 2|1|PUNCT
*S1:	yeah you just (.) you can't (.) use assignment with arrays except
	when you declare them and you initialize (th)em that's what Polly
	was saying (.) so no I can't do that .
%mor:	co|yeah pro:per|you adv|just pro:per|you mod|can~neg|not v|use
	n|assign&dv-MENT prep|with n|array-PL prep|except conj|when
	pro:per|you v|declare pro:obj|them coord|and pro:per|you
	v|initial&dadj-IZE pro:obj|them pro:dem|that~cop|be&3S pro:int|what
	n:prop|Polly aux|be&PAST&13S part|say-PRESP adv|so co|no pro:sub|I
	mod|can~neg|not v|do pro:dem|that .
%gra:	1|7|COM 2|7|SUBJ 3|7|JCT 4|7|SUBJ 5|7|AUX 6|5|NEG 7|0|ROOT 8|7|OBJ
	9|7|JCT 10|9|POBJ 11|7|JCT 12|11|POBJ 13|14|SUBJ 14|7|CJCT 15|14|OBJ
	16|18|LINK 17|18|SUBJ 18|14|CJCT 19|18|OBJ 20|21|SUBJ 21|18|COMP 22|25|LINK
	23|25|SUBJ 24|25|AUX 25|21|CPRED 26|27|JCT 27|31|COM 28|31|SUBJ 29|31|AUX
	30|29|NEG 31|25|COMP 32|31|OBJ 33|7|PUNCT
*S1:	even though it looks like an analogous operation (.) it's not
	possible .
%mor:	adv|even adv|though pro:per|it v|look-3S prep|like det:art|a
	adj|analogous n|operate&dv-TION pro:per|it~cop|be&3S neg|not
	adj|possible .
%gra:	1|2|JCT 2|4|JCT 3|4|SUBJ 4|0|ROOT 5|4|JCT 6|8|DET 7|8|MOD 8|5|POBJ
	9|10|SUBJ 10|4|COMP 11|10|NEG 12|10|PRED 13|4|PUNCT
*S1:	&-uh what could I do instead ?
%mor:	pro:int|what mod|could pro:sub|I v|do adv|instead ?
%gra:	1|4|OBJ 2|4|AUX 3|4|SUBJ 4|0|ROOT 5|4|JCT 6|4|PUNCT
*S1:	let's say I did wanna copy all of B into (.) A .
%mor:	v|let~pro:obj|us v|say pro:sub|I v|do&PAST v|want~inf|to v|copy
	pro:indef|all prep|of n:prop|B prep|into n:prop|A .
%gra:	1|0|ROOT 2|1|OBJ 3|1|COMP 4|5|SUBJ 5|1|CJCT 6|5|COMP 7|8|INF 8|6|COMP
	9|8|OBJ 10|9|NJCT 11|10|POBJ 12|8|JCT 13|12|POBJ 14|1|PUNCT
*S1:	what would I be able to do (.) in c@l plus [/] plus that would work
	?
%mor:	pro:int|what mod|will&COND pro:sub|I cop|be adj|able inf|to v|do
	adv|in n:let|c n|plus pro:rel|that mod|will&COND v|work ?
%gra:	1|4|LINK 2|4|AUX 3|4|SUBJ 4|0|ROOT 5|4|PRED 6|7|INF 7|5|XMOD 8|7|JCT
	9|10|MOD 10|8|POBJ 11|13|LINK 12|13|AUX 13|10|CMOD 14|4|PUNCT
*S1:	(0.10) (o)kay no volunteers ?
%mor:	co|okay qn|no n|volunteer-PL ?
%gra:	1|3|COM 2|3|QUANT 3|0|INCROOT 4|3|PUNCT
*S1:	well it is ten o'clock (.) so I'll just quickly say here that &-uh
	to do this we could write a little for loop that went from (.) zero
	up through nine (.) and then (.) brute force method copy every
	single element of B into (.) the (.) corresponding element of A .
%mor:	co|well pro:per|it cop|be&3S det:num|ten n|o'clock adv|so
	pro:sub|I~mod|will adv|just adv|quick&dadj-LY co|say adv|here
	pro:rel|that inf|to v|do pro:dem|this pro:sub|we mod|could v|write
	det:art|a adj|little prep|for n|loop pro:rel|that v|go&PAST
	prep|from det:num|zero adv|up adj|through det:num|nine coord|and
	adv:tem|then n|brute n|force n|method n|copy qn|every adj|single
	n|element prep|of n:prop|B prep|into det:art|the
	part|correspond-PRESP n|element prep|of n:prop|A .
%gra:	1|2|COM 2|3|SUBJ 3|0|ROOT 4|5|QUANT 5|3|PRED 6|10|JCT 7|10|SUBJ
	8|10|AUX 9|10|JCT 10|3|JCT 11|12|COM 12|10|JCT 13|15|LINK 14|15|INF 15|12|CMOD
	16|15|OBJ 17|19|SUBJ 18|19|AUX 19|15|COMP 20|21|DET 21|19|OBJ 22|21|JCT
	23|22|POBJ 24|25|LINK 25|23|CMOD 26|25|JCT 27|30|QUANT 28|27|JCT
	29|30|MOD 30|26|POBJ 31|30|CONJ 32|36|MOD 33|36|MOD 34|36|MOD 35|36|MOD
	36|31|COORD 37|39|QUANT 38|39|MOD 39|36|OBJ 40|39|NJCT 41|40|POBJ 42|36|NJCT
	43|45|DET 44|45|MOD 45|42|POBJ 46|45|NJCT 47|46|POBJ 48|3|PUNCT
*S1:	so I'd hafta write a for loop to do it whereas (.) with structs
	[: structures] I can actually just do the assignment .
%mor:	adv|so pro:sub|I~mod|genmod mod|have~inf|to v|write det:art|a
	prep|for n|loop inf|to v|do pro:per|it conj|whereas prep|with
	n|structure-PL pro:sub|I mod|can adv|actual&dadj-LY adv|just v|do
	det:art|the n|assign&dv-MENT .
%gra:	1|6|JCT 2|6|SUBJ 3|6|AUX 4|6|AUX 5|6|INF 6|0|ROOT 7|8|DET 8|6|JCT
	9|8|POBJ 10|11|INF 11|8|CPOBJ 12|11|OBJ 13|20|LINK 14|20|JCT 15|14|POBJ
	16|20|SUBJ 17|20|AUX 18|20|JCT 19|20|JCT 20|11|CJCT 21|22|DET 22|20|OBJ
	23|6|PUNCT
*S1:	(o)kay well it's after ten so we'll stop here (.) and we'll pick up
	with structs [: structures] tomorrow .
%mor:	co|okay adv|well pro:per|it~cop|be&3S prep|after det:num|ten adv|so
	pro:sub|we~mod|will n|stop adv|here coord|and pro:sub|we~mod|will
	v|pick adv|up prep|with n|structure-PL adv:tem|tomorrow .
%gra:	1|4|COM 2|4|JCT 3|4|SUBJ 4|0|ROOT 5|4|JCT 6|10|QUANT 7|10|JCT 8|10|SUBJ
	9|10|AUX 10|5|POBJ 11|10|NJCT 12|15|LINK 13|15|SUBJ 14|15|AUX
	15|10|CJCT 16|15|JCT 17|15|JCT 18|19|MOD 19|17|POBJ 20|4|PUNCT
@End
